(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{403:function(e,t,a){"use strict";a.r(t);var r=a(45),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("密码学是IT界的重要领域。无数人在网络上互相交流，在信息传递的过程中就可能有人窃取或者劫持，可能有人利用网络弱点窃取个人信息。")])]),e._v(" "),a("p",[e._v("人们如何安全发送信息，以及JS扮演了什么角色？如果你不知道答案，那么这一章就很适合你。\n在这一章，我们将会知道什么是密码学，以及在JS中如何工作，以及如何处理中间人攻击。")]),e._v(" "),a("h1",{attrs:{id:"什么是加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是加密"}},[e._v("#")]),e._v(" 什么是加密")]),e._v(" "),a("p",[e._v("加密是处理安全信息和交流的过程，这样只有发送者和目标接受者才能访问它们。加密有多种技术方式。这些即使包含加密和解密，使用不同的算法来哈希通信过程，签名和验证。")]),e._v(" "),a("p",[e._v("由于很多人使用JS构建的应用来进行通信的，所以有必要理解JS是怎么加密的。下一节。我们会看看JSWEB的加密API以及如何加密的。")]),e._v(" "),a("h1",{attrs:{id:"js-web-的加密api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-web-的加密api"}},[e._v("#")]),e._v(" JS Web 的加密API")]),e._v(" "),a("p",[e._v("由于确保网络通信是很重要的，一些web浏览器已经实现了"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Crypto",target:"_blank",rel:"noopener noreferrer"}},[e._v("crypto"),a("OutboundLink")],1),e._v("接口。\n但是这个接口不能很好的定义或者加密声音信息。JS web 加密API提供了一个更好的接口\n"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto",target:"_blank",rel:"noopener noreferrer"}},[e._v("SubtleCrypto"),a("OutboundLink")],1),a("code",[e._v("SubtleCrypto")]),e._v(".")]),e._v(" "),a("p",[e._v("JS web加密API允许开发者在应用中使用基本的加密方法而不需要第三方的库。你可以签名文档，执行认证，对整个通信进行校验。")]),e._v(" "),a("p",[e._v("比如，你可以这样获得一个加密的数组：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const secure = window.crypto.getRandomValues(new Uint8Array(10));\nconsole.log(secure);\n")])])]),a("p",[e._v("在控制台执行这段代码，能看到10个随机生成的数字")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c36942361504ee8b61471ede8bb0335~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v("\n下面就看看加密API是如何工作的，以及我们的控制台是怎么做到的。")]),e._v(" "),a("p",[e._v("合理使用加密API，服务器就无法看到数据，只有发送者和接受者可以访问到。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0ea2cdeeed847909e838204d5a1ba96~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("从上图中可以看到，发送者使用了API进行加密，接受者对数据进行解密。而服务器和数据库不能加密也不能和解密。\n你可以执行很多加密操作，比哈希，签名，认证等等，我们后面会讨论")]),e._v(" "),a("h1",{attrs:{id:"基础的加密方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础的加密方式"}},[e._v("#")]),e._v(" 基础的加密方式")]),e._v(" "),a("h2",{attrs:{id:"encrypting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encrypting"}},[e._v("#")]),e._v(" Encrypting")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be34a9bda588484f93ac7c7230fbf703~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("JS的API "),a("code",[e._v("encrypt")]),e._v(" 方法就是这样的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//Syntax for encrypt function\nconst result = crypto.subtle.encrypt(algorithm, key, data);\n")])])]),a("p",[e._v("这个加密方法会返回一个"),a("code",[e._v("Promise")]),e._v("，内部是包含密电码的"),a("code",[e._v("ArrayBuffer")]),e._v(" 。在加密时如果发生了异常，就会返回一个新的Promise rejected，内部是一个 序列化算法的结果。\n举个例子，我们加密一个纯文本，使用"),a("code",[e._v("AES-GCM")]),e._v("密钥和算法。把代码复制到你的控制台，看一下输出的密电码。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because \nencrypt method must return a Promise that fulfills with an ArrayBuffer containing the "ciphertext"*/\nfunction strToArrayBuffer(str) {\n  var buf = new ArrayBuffer(str.length * 2);\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintext\nfunction arrayBufferToString(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n//This object below will generate our algorithm key\nvar algoKeyGen = {\n  name: "AES-GCM",\n  length: 256,\n};\n//This will generate random values of 8-bit unsigned integer\nvar iv = window.crypto.getRandomValues(new Uint8Array(12));\n//This object will generate our encryption algorithm\nvar algoEncrypt = {\n  name: "AES-GCM",\n  iv: iv,\n  tagLength: 128,\n};\n//states that key usage is for encryption\nvar keyUsages = ["encrypt"];\nvar plainText = "This is a secure message from Mary";\nvar secretKey;\n//This generates our secret Key with key generation algorithm\nwindow.crypto.subtle\n  .generateKey(algoKeyGen, false, keyUsages)\n  .then(function (key) {\n    secretKey = key;\n  //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer\n    return window.crypto.subtle.encrypt(\n      algoEncrypt,\n      key,\n      strToArrayBuffer(plainText)\n    );\n  })\n  .then(function (cipherText) {\n  //print out Ciphertext in console\n    console.log("Cipher Text: " + arrayBufferToString(cipherText));\n  })\n  .catch(function (err) {\n    console.log("Error: " + err.message);\n  });\n')])])]),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b6b484e4cc4642b48f8c63941aeffb~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v("\n看代码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var algoKeyGen = { name: ‘AES-GCM’, length: 256};\n")])])]),a("p",[e._v("这里声明了密钥")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var algoEncrypt = { name: ‘AES-GCM’, iv: iv, tagLength: 128};\n")])])]),a("p",[e._v("这里声明了加密算法")]),e._v(" "),a("h1",{attrs:{id:"decrypting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decrypting"}},[e._v("#")]),e._v(" Decrypting")]),e._v(" "),a("p",[e._v("Decrypting是跟加密相反，把密电码转换为纯文本。这时候就需要认证用户提供一个密钥。")]),e._v(" "),a("p",[a("code",[e._v("decrypt")]),e._v(" 方法可以来解密，它的语法如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const result = crypto.subtle.decrypt(algorithm, key, data);\n")])])]),a("p",[e._v("上面例子的解密过程如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//This states that the keyusage for decrypting\nvar keyUsages = ["decrypt"];\n//This object below is for algorithm key generation\nvar algoKeyGen = {\n  name: "AES-GCM",\n  length: 256,\n};\nvar plainText = "This is a secure message from Mary";\nvar secretKey;\n//This will generate secrete key with algorithm key and keyusage\nwindow.crypto.subtle\n  .generateKey(algoKeyGen, false, keyUsages)\n  .then(function (key) {\n    secretKey = key;\n    //This will decrypt Cipheretext to plaintext\n    return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText);\n  })\n  //  Print plaintext in console.\n  .then(function (plainText) {\n    console.log("Plain Text: " + arrayBufferToString(plainText));\n  })\n  .catch(function (err) {\n    console.log("Error: " + err.message);\n  });\n')])])]),a("p",[e._v("完整的加密解密代码如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// This code below will encrypt and decrypt plaintext\n\n/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because \nencrypt method must return a Promise that fulfills with an ArrayBuffer containing the "ciphertext"*/\nfunction strToArrayBuffer(str) {\n  var buf = new ArrayBuffer(str.length * 2);\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintext\nfunction arrayBufferToString(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n//This object below will generate our algorithm key\nvar algoKeyGen = {\n  name: "AES-GCM",\n  length: 256,\n};\n//This will generate random values of 8-bit unsigned integer\nvar iv = window.crypto.getRandomValues(new Uint8Array(12));\n//This object will generate our encryption algorithm\nvar algoEncrypt = {\n  name: "AES-GCM",\n  iv: iv,\n  tagLength: 128,\n};\n//states that key usage is for encrypting and decrypting\nvar keyUsages = ["encrypt", "decrypt"];\nvar plainText = "This is a secure message from Mary";\nvar secretKey;\n//This generates our secret Key with key generation algorithm\nwindow.crypto.subtle\n  .generateKey(algoKeyGen, false, keyUsages)\n  .then(function (key) {\n    secretKey = key;\n  //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer\n    return window.crypto.subtle.encrypt(\n      algoEncrypt,\n      key,\n      strToArrayBuffer(plainText)\n    );\n  })\n  .then(function (cipherText) {\n  //This prints out the ciphertext, converting it from ArrayBuffer to 16-bit unsigned String\n    console.log("Cipher Text: " + arrayBufferToString(cipherText));\n  //This will decrypt ciphertext with secret key and algorithm\n    return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText);\n  })\n//This prints out the plaintext, converting it from ArrayBuffer to 16-bit unsigned String\n  .then(function (plainText) {\n    console.log("Plain Text: " + arrayBufferToString(plainText));\n  })\n  .catch(function (err) {\n    console.log("Error: " + err.message);\n  });\n')])])]),a("p",[e._v("运行这段代码，将会看到之前加密的纯文本\n"),a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/431f906c3a534767b4011edbb99693ec~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v("\n看代码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var secretKey;\n\n window.crypto.subtle.generateKey(algoKeyGen, false, keyUsages) \n.then(function (key) { secretKey = key;\n")])])]),a("p",[e._v("这里生成可以密钥来加密信息")]),e._v(" "),a("p",[e._v("加密过程可以宽泛的分为对称和非对称加密。这取决于加密使用的密钥类型。对称机密的话，加密和解密使用相同的密钥。非对称则相反，加密和解密采用不同的密钥。加密使用认证用户之间共享的公钥，接受者使用私钥来解密。\n"),a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a40f27a4d84f3d932090e8432f4f5c~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("h1",{attrs:{id:"hashing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashing"}},[e._v("#")]),e._v(" Hashing")]),e._v(" "),a("p",[e._v("哈希是一个加密方法，可以把任意长度的数据映射成固定尺寸的数组。加密哈希函数，把纯文本数据转换成一个由数组和字母组成的唯一的字符串。哈希不同于上面说的加密，但是单向的。也就是说，你就可以加密，但是基本不可能把哈希后的数据转换为源文本")]),e._v(" "),a("p",[e._v("哈希只能加密不能解析，所以主要用来进行认证。比如，注册或登录。当用户注册是，密码在存进数据库之前先哈希。当用户登录时，登录密码被哈希，然后跟数据库中的数据再对比确保匹配。这样，即使黑客攻入了数据库，获得了用户的账户信息，它还是无法解码出源密码。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3388d60df2a04830ba70e27fe47c4740~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("JS可以调用"),a("code",[e._v("crypto.subtle.digest")]),e._v(" 来进行哈希。你可以使用"),a("code",[e._v("SHA-1")]),e._v(", "),a("code",[e._v("SHA-384")]),e._v(" 和"),a("code",[e._v("SHA-512")]),e._v("几种方式来哈希：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const digest = crypto.subtle.digest(algorithm, data);\n")])])]),a("p",[e._v("看一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const text = "This is a secure message from Mary";\nasync function digestMessage(message) {\n  const encode = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array\n  const hashBuffer = await crypto.subtle.digest("SHA-256", encode); // hash the message\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, "0"))\n    .join(""); // convert bytes to hex string\n  return hashHex;\n}\nconst digestHex = await digestMessage(text);\nconsole.log(digestHex);\n')])])]),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6afb8c5dc45e4c80b16588c44af2df80~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("在这个例子中，我们使用了"),a("code",[e._v("SHA-256")]),e._v(" 算法来加密文本"),a("strong",[e._v("This is a secure message from Mary")]),e._v(" ，将其转换为十六进制的字符串。在生产环境中，不推荐使用"),a("code",[e._v("SHA-1")]),e._v("算法，因为它比较弱。")]),e._v(" "),a("h2",{attrs:{id:"生成签名和验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成签名和验证"}},[e._v("#")]),e._v(" 生成签名和验证")]),e._v(" "),a("p",[e._v("这是另一种加密方式。使用"),a("code",[e._v("sign")]),e._v(" 和 "),a("code",[e._v("verify")]),e._v("函数，你可以用一个密钥给文档加密。接受者使用他们的密钥去验证文档。\n签名和验证的语法如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//syntax to sign document\nconst signature = crypto.subtle.sign(algorithm, key, data);\n//syntax to generate document\nconst result = crypto.subtle.verify(algorithm, key, signature, data);\n")])])]),a("h1",{attrs:{id:"加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加密算法"}},[e._v("#")]),e._v(" 加密算法")]),e._v(" "),a("p",[e._v("加密有很多种不同的SHA算法，每一个都声明了哈希值的bit位长度 。这一节，我们会看看JS支持的加密函数。")]),e._v(" "),a("h2",{attrs:{id:"ecdh-elliptic-curve-diffie-hellman"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ecdh-elliptic-curve-diffie-hellman"}},[e._v("#")]),e._v(" ECDH (Elliptic Curve Diffie-Hellman)")]),e._v(" "),a("p",[e._v("这个加密算法，用来生成和协商密钥。ECDH密钥协商协议，允许通信双方持有一个私有-公有的密钥对来保护通信。")]),e._v(" "),a("p",[e._v("这个算法允许你做这些事情")]),e._v(" "),a("ul",[a("li",[e._v("生成密钥")]),e._v(" "),a("li",[e._v("Bits Derivation")]),e._v(" "),a("li",[e._v("导入密钥")]),e._v(" "),a("li",[e._v("到处密钥")])]),e._v(" "),a("h2",{attrs:{id:"sha-secure-hash-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sha-secure-hash-algorithm"}},[e._v("#")]),e._v(" SHA (Secure Hash Algorithm)")]),e._v(" "),a("p",[e._v("这个算法大多是哈希的时候使用。它将任意数据压缩成定长的比特字符串。JS API允许你使用crypto.subtle.digest ，它支持 "),a("code",[e._v("SHA-1")]),e._v(" 和 "),a("code",[e._v("SHA-2")]),e._v('，也支持"SHA-256”, “SHA-384”, “SHA-512”')]),e._v(" "),a("h2",{attrs:{id:"hmac-hash-based-message-authentication-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hmac-hash-based-message-authentication-code"}},[e._v("#")]),e._v(" HMAC (Hash-based Message Authentication Code)")]),e._v(" "),a("p",[e._v("使用哈希函数哈希之后，需要验证输入的信息是否跟这个哈希值相同。记住，我们无法把哈希值转换成源文本。为了对比值，"),a("code",[e._v("HMAC")]),e._v("算法可以用来签名和认证文档。你可以用这个算法做这个：")]),e._v(" "),a("ul",[a("li",[e._v("签名")]),e._v(" "),a("li",[e._v("验证")]),e._v(" "),a("li",[e._v("生成密钥")]),e._v(" "),a("li",[e._v("导入密钥")]),e._v(" "),a("li",[e._v("导出密钥")]),e._v(" "),a("li",[e._v("获取密钥长度")])]),e._v(" "),a("h2",{attrs:{id:"hkdf-hash-based-key-derivation-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hkdf-hash-based-key-derivation-function"}},[e._v("#")]),e._v(" HKDF (Hash-based Key Derivation Function)")]),e._v(" "),a("p",[e._v("HKDF是一个基于HMAC的加密派生方法。它使用了extraction-then-expansion（先提取后扩充） 方式来实现。使用这个算法，可以把公钥转换成密钥，用来加密，验证或者认证。你可以用这个算法做这些事情：")]),e._v(" "),a("ul",[a("li",[e._v("Bits Derivation")]),e._v(" "),a("li",[e._v("导入密钥")]),e._v(" "),a("li",[e._v("获取密钥长度")])]),e._v(" "),a("h2",{attrs:{id:"ecdsa-elliptic-curve-digital-signature-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ecdsa-elliptic-curve-digital-signature-algorithm"}},[e._v("#")]),e._v(" ECDSA (Elliptic Curve Digital Signature Algorithm)")]),e._v(" "),a("p",[e._v("ECDSA允许用户签名和认证文档，使用"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Elliptic_curve_cryptography",target:"_blank",rel:"noopener noreferrer"}},[e._v(" elliptic curve cryptography"),a("OutboundLink")],1),e._v("。你可以用这个算法做这些事情：")]),e._v(" "),a("ul",[a("li",[e._v("签名")]),e._v(" "),a("li",[e._v("验证")]),e._v(" "),a("li",[e._v("生成密钥")]),e._v(" "),a("li",[e._v("导入密钥")]),e._v(" "),a("li",[e._v("导出密钥")])]),e._v(" "),a("h2",{attrs:{id:"rsa-rivest-shamir-adleman-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rsa-rivest-shamir-adleman-algorithm"}},[e._v("#")]),e._v(" RSA (Rivest–Shamir–Adleman) Algorithm")]),e._v(" "),a("p",[e._v("RSA用来加密网络信息，它是一个异步的算法。加密和解密使用了两个密钥。一个是公钥，在认证用户之间共享，另一个是私钥，必须私人保护。")]),e._v(" "),a("p",[e._v("RSA还支持其他的"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Padding_%28cryptography%29",target:"_blank",rel:"noopener noreferrer"}},[e._v(" padding schemes"),a("OutboundLink")],1),e._v("算法。JS web加密API支持下面这些RSA算法")]),e._v(" "),a("ul",[a("li",[e._v("RSASSA-PKCS1-v1_5")]),e._v(" "),a("li",[e._v("RSA-PSS")]),e._v(" "),a("li",[e._v("RSA-OAEP")])]),e._v(" "),a("h2",{attrs:{id:"aes-advanced-encryption-standard-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aes-advanced-encryption-standard-algorithm"}},[e._v("#")]),e._v(" AES (Advanced Encryption Standard) Algorithm")]),e._v(" "),a("p",[e._v("The advanced encryption standard algorithm is mostly known by its original name "),a("strong",[e._v("Rijndael")]),e._v(". It is used for the encryption of electronic data and was established by the U.S."),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology",target:"_blank",rel:"noopener noreferrer"}},[e._v(" National Institute of Standards and Technology"),a("OutboundLink")],1),e._v(" (NIST) in 2001. JavaScript’s Web Cryptography API supports different encryption models that use the AES block, they are:")]),e._v(" "),a("ul",[a("li",[e._v("AES-CTR")]),e._v(" "),a("li",[e._v("AES-CBC")]),e._v(" "),a("li",[e._v("AES-GCM")]),e._v(" "),a("li",[e._v("AES-KW")])]),e._v(" "),a("h1",{attrs:{id:"jsweb-加密api的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsweb-加密api的使用场景"}},[e._v("#")]),e._v(" JSweb 加密API的使用场景")]),e._v(" "),a("p",[e._v("很多JS应用需要实时加密。在这一节，我们看看实时加密的各类应用。")]),e._v(" "),a("h2",{attrs:{id:"多元素认证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多元素认证"}},[e._v("#")]),e._v(" 多元素认证")]),e._v(" "),a("p",[e._v("即使用户的密码被哈希或者被加密了，但是黑客们还是窃取用户的账户。为了确保登录账户是真正的使用者，很多应用要做多元素认证。")]),e._v(" "),a("p",[e._v("而不是使用传输层的认证，比如TLS客户端认证应用使用灵活的用户密钥，这些密钥是使用用户代理预先生成的。")]),e._v(" "),a("h2",{attrs:{id:"受保护的文档交换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受保护的文档交换"}},[e._v("#")]),e._v(" 受保护的文档交换")]),e._v(" "),a("p",[e._v("加密的一个目标就是在第三方面前，能够确保信息的安全。JS 加密API允许你给文档签名，验证和加密。只允许拥有密钥的认证用户有权限访问文档。")]),e._v(" "),a("h2",{attrs:{id:"云存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#云存储"}},[e._v("#")]),e._v(" 云存储")]),e._v(" "),a("p",[e._v("使用JS加密API可以在上传文档之前就保护他们。应用使用用户选择的密钥，派生出一个加密的密钥，把文档加密了。然后再上传到服务器")]),e._v(" "),a("h2",{attrs:{id:"安全消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全消息"}},[e._v("#")]),e._v(" 安全消息")]),e._v(" "),a("p",[e._v("用户可以在网上使用OTR（无痕）的方式通信。通信双发可以使用验证码密钥（MAC）加密和解密信息，来保护数据。")]),e._v(" "),a("h2",{attrs:{id:"js对象签名和加密-jose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js对象签名和加密-jose"}},[e._v("#")]),e._v(" JS对象签名和加密(JOSE)")]),e._v(" "),a("p",[e._v("可以使用JS加密API来给JOSE的结构和信息进行交互。")]),e._v(" "),a("h1",{attrs:{id:"怎么处理mitm攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么处理mitm攻击"}},[e._v("#")]),e._v(" 怎么处理MitM攻击")]),e._v(" "),a("p",[e._v("MITM可以被称作中间攻击中的机器，也可是指中间攻击中的人。它是一种网络攻击，监听通信的双方，去修改他们的通信内容。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70118e8244594e53a7e5023ed3a08b6d~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("例如，中间人可以在发送者的信息达到接受者之前就劫持信息。假如Nancy和Joy有一个加密会话。")]),e._v(" "),a("p",[e._v("这时一个中间人James,获得了Nacy的密钥，他就可以解密信息，然后再发送给Joy之前进行篡改。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c36e4084774454882bc7830f7a05a55~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),a("p",[e._v("一般怎么处理MITM攻击呢？")]),e._v(" "),a("ol",[a("li",[e._v("使用篡改检测是检验是否发生了MITM攻击的有效方式，通信双方可以对比响应时间的差异。")]),e._v(" "),a("li",[e._v("双向认证可以有效减少MITM攻击，服务端和客户端互相验证")]),e._v(" "),a("li",[e._v("取证分析同样很重要，它可以显示是否发生了MIIT攻击，以及攻击的资源。")])]),e._v(" "),a("h1",{attrs:{id:"安全是个大话题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全是个大话题"}},[e._v("#")]),e._v(" 安全是个大话题")]),e._v(" "),a("p",[e._v("人人都希望自己在网上的通信交流是安全的，不会被泄漏出去。\n开发者必须小心的选择第三方的工具和合作的供应商。要确保使用的工具在安全性和隐私性上都已经被相关的组织认证了。")])])}),[],!1,null,null,null);t.default=n.exports}}]);