(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{401:function(t,e,a){"use strict";a.r(e);var s=a(45),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("影子DOM即Shadow DOM")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b7ccea94174f55a19f1f2df90a3ca5~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),t._v(" "),a("h1",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("网络组件是一种不同的技术，可以让你创建可复用的自定义元素。这些元素是被封装的，跟其他的代码没有关系，可以在网络应用中使用它们。\n我们有4个网络组件的标准：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Shadow DOM")])]),t._v(" "),a("li",[a("p",[t._v("HTML Templates")])]),t._v(" "),a("li",[a("p",[t._v("Custom elements")])]),t._v(" "),a("li",[a("p",[t._v("HTML Imports\n这一章我们讨论Shadow DOM，也即影子DOM。"),a("br"),t._v("\n影子DOM是构建基于组件的应用的工具。它给这些问题提供了一个解决方案：")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("隔离 DOM")]),t._v(": 组件的DOM是独立的（比如document.querySelector()就不会返回组件影子DOM里的节点）。这样就可以使用最简单的CSS选择器，而不用担心命名冲突。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("局部CSS")]),t._v(":影子DOM内部的CSS，作用范围是在DOM内部。局部的样式不会泄漏，也不会被外部影响。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("组合")]),t._v(": 为你的组件设计一个声明式的，基于标签的API。")])])]),t._v(" "),a("h1",{attrs:{id:"影子dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#影子dom"}},[t._v("#")]),t._v(" 影子DOM")]),t._v(" "),a("p",[t._v("如果还不熟悉影子DOM的概念和API，可以看看这里"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction"),a("OutboundLink")],1),t._v("."),a("br"),t._v("\n和普通DOM相比，影子DOM有两点不同：")]),t._v(" "),a("ul",[a("li",[t._v("个其他页面建立和使用关联的形式")]),t._v(" "),a("li",[t._v("跟其他页面关联的变现形式")])]),t._v(" "),a("p",[t._v("一般情况下，你可以创建一个DOM节点，然后添加到其他元素上的子节点上。至于影子DOM，则创建一个局部的DOM树，添加到元素的子节点，这个树是和元素的实际子节点分离的。这个局部的子树，叫做"),a("strong",[t._v("shadow tree")]),t._v("。宿主元素则叫"),a("strong",[t._v("shadow host")]),t._v("。包括 "),a("code",[t._v("<style>")]),t._v(" 在内的所有在 shadow 树下创建的任何标签都只作用于宿主元素内部。此即 shadow DOM 如何实现 CSS 局部样式化的原理。")]),t._v(" "),a("h1",{attrs:{id:"创建影子树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建影子树"}},[t._v("#")]),t._v(" 创建影子树")]),t._v(" "),a("p",[a("strong",[t._v("shadow root")]),t._v(" 是附加到宿主元素的文档片段。宿主元素得到它的影子DOM时，就添加了一个shadow root。调用element.attachShadow()，可以为元素创建一个影子DOM。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var header = document.createElement('header');\nvar shadowRoot = header.attachShadow({mode: 'open'});\nvar paragraphElement = document.createElement('p');\n\nparagraphElement.innerText = 'Shadow DOM';\nshadowRoot.appendChild(paragraphElement);\n")])])]),a("p",[t._v("这个 "),a("a",{attrs:{href:"http://w3c.github.io/webcomponents/spec/shadow/#h-methods",target:"_blank",rel:"noopener noreferrer"}},[t._v("声明"),a("OutboundLink")],1),t._v("定义了一些不能挂载shadow tree的元素。")]),t._v(" "),a("h1",{attrs:{id:"影子dom的组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#影子dom的组合"}},[t._v("#")]),t._v(" 影子DOM的组合")]),t._v(" "),a("p",[t._v("组合是影子DOM最重要的特性之一。\n写HTML时，需要组合来构建网络应用。构建应用，需要合并和嵌套不同的构建块（元素）比如"),a("code",[t._v("<div>")]),t._v(", "),a("code",[t._v("<header>")]),t._v(", "),a("code",[t._v("<form>")]),t._v("等等。"),a("br"),t._v("\n元素组合定义了诸如为何 "),a("code",[t._v("<select>")]),t._v("，"),a("code",[t._v("<form>")]),t._v("，"),a("code",[t._v("<video>")]),t._v(" 及其它元素是可扩展的且接受特定的 HTML 元素作为子元素以便用来对这些元素进行特殊处理。")]),t._v(" "),a("p",[t._v("比如，"),a("code",[t._v("<select>")]),t._v(" 元素知道如何把 "),a("code",[t._v("<option>")]),t._v(" 元素渲染成为带有预定义选项的下拉框组件。")]),t._v(" "),a("p",[t._v("Shadow DOM 引入如下功能，可以用来组合元素。")]),t._v(" "),a("h1",{attrs:{id:"light-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#light-dom"}},[t._v("#")]),t._v(" Light DOM")]),t._v(" "),a("p",[t._v("这是组件书写的用户标记。这个DOM在组件影子DOM之外。它是元素的真实子节点。\n假如你创建了一个自定义组件"),a("better-button",[t._v("，它继承了原生的HTML button，并在内部添加了图像和文本。")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<extended-button>\n  \x3c!-- the image and span are extended-button\'s light DOM --\x3e\n  <img src="boot.png" slot="image">\n  <span>Launch</span>\n</extended-button>\n')])])]),a("p",[t._v('“extended-button”中的HTML就是Light DOM，这是被用户添加的。\n"extended-button"组件就是影子DOM。影子DOM定义了内部结构，局部CSS，封装可很多实现细节。')]),t._v(" "),a("h1",{attrs:{id:"扁平dom树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扁平dom树"}},[t._v("#")]),t._v(" 扁平DOM树")]),t._v(" "),a("p",[t._v("浏览器分发 light DOM 的结果即，由用户在 Shadow DOM 内部创建的 HTML 内容，这些 HTML 内容构成了自定义组件的结构，渲染出最后的产品界面。扁平树即开发者在开发者工具中看到的内容和页面的渲染结果。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<extended-button>\n  #shadow-root\n  <style>…</style>\n  <slot name="image">\n    <img src="boot.png" slot="image">\n  </slot>\n  <span id="container">\n    <slot>\n      <span>Launch</span>\n    </slot>\n  </span>\n</extended-button>\n')])])]),a("h1",{attrs:{id:"templates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#templates"}},[t._v("#")]),t._v(" Templates")]),t._v(" "),a("p",[t._v("如果你需要在页面中重复使用相同的标记结构，那么最好使用一些template。以前就能这么做，但是现在使用"),a("code",[t._v("<template>")]),t._v("更加的方便。"),a("code",[t._v("<template>")]),t._v("不会被渲染，但是可以在JS中引用。\n比如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template id="my-paragraph">\n  <p> Paragraph content. </p>\n</template>\n')])])]),a("p",[t._v("这段代码不会被渲染。你需要在JS中引用，然后把它添加一个dom上")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var template = document.getElementById('my-paragraph');\nvar templateContent = template.content;\ndocument.body.appendChild(templateContent);\n")])])]),a("p",[t._v("也有一些其他的手段实现类似的效果，但是相对来讲，"),a("code",[t._v("<template>")]),t._v("的支持性更好。\n看看它的支持情况：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c991a2c009b945d9ae36435c97d7c360~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),t._v("\nTemplates 可以自己工作，也可以在定制元素时使用效果更佳。\n这一章我们讨论浏览器提供的customElement 接口允许开发者自定义标签内容的渲染。")]),t._v(" "),a("p",[t._v("现在定义一个内容是影子DOM是template的组件，"),a("code",[t._v("<my-paragraph>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("customElements.define('my-paragraph',\n class extends HTMLElement {\n   constructor() {\n     super();\n\n     let template = document.getElementById('my-paragraph');\n     let templateContent = template.content;\n     const shadowRoot = this.attachShadow({mode: 'open'}).appendChild(templateContent.cloneNode(true));\n  }\n});\n")])])]),a("p",[t._v("我们使用了"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.cloneNode()"),a("OutboundLink")],1),t._v("方法来创建一个template的副本，然后添加到shadow root上。\n在template中，我们可以使用"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("<style>")]),a("OutboundLink")],1),t._v("来包含一些样式，这些样式会被组件封装起来。当然，在将其附加到一个标准DOM之前，它是不生效的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template id="my-paragraph">\n  <style>\n    p {\n      color: white;\n      background-color: #666;\n      padding: 5px;\n    }\n  </style>\n  <p>Paragraph content. </p>\n</template>\n')])])]),a("p",[t._v("这样，我们就可以在页面中这么使用它了：\n"),a("my-paragraph")],1),t._v(" "),a("h1",{attrs:{id:"slots"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slots"}},[t._v("#")]),t._v(" Slots")]),t._v(" "),a("p",[t._v("template 有一些弊端，最大的问题是它的内容是静态的，我们无法渲染变量/数据，无法像标准的HTML模板那样使用。\n"),t._t("default",(function(){return[t._v(" 可以解决这个问题。\n可以将"),t._t("default",(function(){return[t._v("理解为占位符，可以让你放置你自己的HTML元素。这样，你可以创建通用性的HTML模板，并且添加"),t._t("default",(function(){return[t._v("来进行定制。\n看看使用slot是怎么工作的：")]}))]}))]}))],2),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template id="my-paragraph">\n  <p> \n    <slot name="my-text">Default text</slot> \n  </p>\n</template>\n')])])]),a("p",[t._v("如果在标记中引用该元素的时候没有定义slot内容，或者浏览器不支持插槽，则 "),a("code",[t._v("<my-paragraph>")]),t._v(' 只会包含默认的 "Default text" 内容。\n为了定义slot内容，我们需要在'),a("my-paragraph",[t._v("中包含HTML结构。我们使用一个slot属性，它的值就是你想插入的slot的名字。\n看下代码：")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<my-paragraph>\n <span slot="my-text">Let\'s have some different text!</span>\n</my-paragraph>\n')])])]),a("p",[t._v("可以插入slot的元素叫"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Slotable",target:"_blank",rel:"noopener noreferrer"}},[t._v("Slotable"),a("OutboundLink")],1),t._v("\n已经插入进去的元素，叫做"),a("em",[t._v("slotted")])]),t._v(" "),a("p",[t._v("上面的例子中"),a("code",[t._v("<span>")]),t._v("就是slotted元素。它具有一个slot属性，值为'my-text'，和模板中插槽定义的 name 属性值相等。\n浏览器渲染之后，我们能看到这样的扁平树结构：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<my-paragraph>\n  #shadow-root\n  <p>\n    <slot name="my-text">\n      <span slot="my-text">Let\'s have some different text!</span>\n    </slot>\n  </p>\n</my-paragraph>\n')])])]),a("p",[t._v("注意#shadow-root只是表示，有一个影子DOM。")]),t._v(" "),a("h1",{attrs:{id:"样式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样式"}},[t._v("#")]),t._v(" 样式")]),t._v(" "),a("p",[t._v("使用影子DOM的组件，可以被主页面定义样式，也可以自己定义，还可以提供一些钩子让用户重写。")]),t._v(" "),a("h2",{attrs:{id:"组件定义样式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件定义样式"}},[t._v("#")]),t._v(" 组件定义样式")]),t._v(" "),a("p",[t._v("影子DOM的重要特性之一是局部CSS")]),t._v(" "),a("ul",[a("li",[t._v("外部页面的CSS选择器不会影响到你的组件内部")]),t._v(" "),a("li",[t._v("组件内部定义的样式，也不会影响页面的其他部分。他们只作用于宿主元素的范围。\n在影子DOM中使用CSS选择器，只会影响组件内部。这样，你就可以使用一些重名的id/类名，不用担心在页面其他部分产生命名冲突。要知道，简单的CSS选择器会有更好的性能。\n看看下面的#shadow-root如何定义样式：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('#shadow-root\n<style>\n  #container {\n    background: white;\n  }\n  #container-items {\n    display: inline-flex;\n  }\n</style>\n\n<div id="container"></div>\n<div id="container-items"></div>\n')])])]),a("p",[t._v("例子中的样式，都只局限于#shadow-root内部。你还可以使用"),a("link"),t._v("标签加载样式脚本，同样只是局部生效。")]),t._v(" "),a("h2",{attrs:{id:"host-伪类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#host-伪类"}},[t._v("#")]),t._v(" :host 伪类")]),t._v(" "),a("p",[t._v(":host允许你选择并且样式化寄宿了shadow tree的元素。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<style>\n  :host {\n    display: block; /* by default, custom elements are display: inline */\n  }\n</style>\n")])])]),a("p",[t._v("使用:host需要注意一个事情，父页面的样式规则具有更高的权重，:host定义的规则权重要低一些。这样，就允许用户从外部来重写顶层样式。同样，:host只会在shadow root的上下文中生效。"),a("br"),t._v("\n:host("),a("selector",[t._v(")功能模式允许你关联匹配"),a("selector",[t._v("的宿主元素。这样你可以封装用户的交互和状态的行为，并且基于宿主节点样式化内部节点。")])],1)],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<style>\n  :host {\n    opacity: 0.4;\n  }\n  \n  :host(:hover) {\n    opacity: 1;\n  }\n  \n  :host([disabled]) { /* 宿主元素拥有 disabled 属性的样式. */\n    background: grey;\n    pointer-events: none;\n    opacity: 0.4;\n  }\n  \n  :host(.pink) > #tabs {\n    color: pink; /* 当宿主元素含有 pink 类时的选项卡样式. */\n  }\n</style>\n")])])]),a("h2",{attrs:{id:"使用-host-context-伪类的主题和元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-host-context-伪类的主题和元素"}},[t._v("#")]),t._v(" 使用:host-context("),a("selector",[t._v(")伪类的主题和元素")])],1),t._v(" "),a("p",[t._v(":host-context("),a("selector",[t._v(")伪类找出宿主元素或者宿主元素任意的祖先元素匹配 "),a("code",[t._v("<selector>")]),t._v("。\n常见的使用场景是定制主题。很多人会给"),a("code",[t._v("<html>")]),t._v(" 或者 "),a("code",[t._v("<body>")]),t._v("上应用样式，来实现定制主题。")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<body class="lightheme">\n  <custom-container>\n  …\n  </custom-container>\n</body>\n')])])]),a("p",[t._v("当"),a("fancy-tabs",[t._v("是.lightheme子节点的时候，:host-context(.lightheme)将会样式化它。")])],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(":host-context(.lightheme) {\n  color: black;\n  background: white;\n}\n")])])]),a("h2",{attrs:{id:"从外部样式化组件的宿主元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从外部样式化组件的宿主元素"}},[t._v("#")]),t._v(" 从外部样式化组件的宿主元素")]),t._v(" "),a("p",[t._v("开发者可以从外部通过把标签名作为选择器来样式化组件宿主元素，如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("custom-container {\n  color: red;\n}\n")])])]),a("p",[t._v("相比影子DOM内部的样式，外部样式的邮件及更高。\n例如，如果用户这么写选择器：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("custom-container {\n  width: 500px;\n}\n")])])]),a("p",[t._v("就会覆盖掉组件的样式规则：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(":host {\n  width: 300px;\n}\n")])])]),a("p",[t._v("样式化组件只能做到这一步了。但是如果我们想样式化组件内部怎么办？我们需要CSS自定义属性")]),t._v(" "),a("h2",{attrs:{id:"使用css自定义属性创建样式钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用css自定义属性创建样式钩子"}},[t._v("#")]),t._v(" 使用CSS自定义属性创建样式钩子")]),t._v(" "),a("p",[t._v("如果组件开发者使用CSS自定义属性提供了样式钩子，我们就可以改变它的内部样式。这概念有点像"),t._t("default",(function(){return[t._v("。\n看一个例子：")]}))],2),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\x3c!-- main page --\x3e\n<style>\n  custom-container {\n    margin-bottom: 60px;\n     - custom-container-bg: black;\n  }\n</style>\n\n<custom-container background>…</custom-container>\n")])])]),a("p",[t._v("影子DOM内部：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(":host([background]) {\n  background: var( - custom-container-bg, #CECECE);\n  border-radius: 10px;\n  padding: 10px;\n}\n")])])]),a("p",[t._v("由于用户提供了背景颜色，所有组件会使用相同的颜色，也就是#CECECE。\n作为组件的作者，你有责任让后面开发之道哪些CSS自定义属性可以使用。将它们作为组件公共接口的一部分。")]),t._v(" "),a("h2",{attrs:{id:"插槽js-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插槽js-api"}},[t._v("#")]),t._v(" 插槽JS API")]),t._v(" "),a("p",[t._v("影子 DOM API 可能用来操作插槽")]),t._v(" "),a("h2",{attrs:{id:"slotchange事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slotchange事件"}},[t._v("#")]),t._v(" slotchange事件")]),t._v(" "),a("p",[t._v("当slot 分发的节点改变了，就会触发这个事件。比如，我们添加/删除了light dom的子节点")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var slot = this.shadowRoot.querySelector('#some_slot');\nslot.addEventListener('slotchange', function(e) {\n  console.log('Light DOM change');\n});\n")])])]),a("p",[t._v("为了维护light DOM其他类型的变化，你可以使用MutationObserver。我们之前章节中已经讨论过。")]),t._v(" "),a("h2",{attrs:{id:"assignednodes-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assignednodes-方法"}},[t._v("#")]),t._v(" assignedNodes()方法")]),t._v(" "),a("p",[t._v("知道slot关联了什么元素有时候很有用。slot.assignedNodes()方法可以告诉你slot渲染了什么元素。\n"),a("code",[t._v("flatten: true}")]),t._v(" 选项会返回插槽的默认内容(若没有分发任何节点)。\n看一个例子：\n"),t._t("’slot1’",(function(){return[a("p",[t._v("Default content")])]})),t._v("\n我们假设它在"),a("my-container",[t._v("组件之中。\n看一下使用这个组件有什么不同，以及调用assignedNodes()返回什么：\n首先，我们添加自己的内容到slot")])],2),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<my-container>\n  <span slot="slot1"> container text </span>\n</my-container>\n')])])]),a("p",[t._v("调用assignedNodes()将会返回["),a("span",{attrs:{slot:"”slot1”"},slot:"”slot1”"},[t._v(" container text ")]),t._v("]，注意这个结果是一个节点数组。")]),t._v(" "),a("p",[t._v("在第二个案例中，我们放一个空内容\n"),a("my-container"),t._v(" "),a("code",[t._v("assignedNodes()")]),t._v("将会返回一个空数组[]\n但是此时如果你传入了{flatten: true}参数，你将会得到一个默认结果："),a("code",[t._v("[<p>Default content</p>]")]),t._v("\n为了方位slot内部的元素，你可以调用assignedNodes()去看看你的元素被分配给了哪个组件slot。")],1),t._v(" "),a("h1",{attrs:{id:"事件模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[t._v("#")]),t._v(" 事件模型")]),t._v(" "),a("p",[t._v("当影子DOM事件冒泡时发生了什么？\n目标事件被调整为维护影子DOM的封闭性。当一个事件被重定位，就好像来自于组件本身，而不是组件中的影子DOM中的元素。\n这里有传播出 Shadow DOM 的事件列表(还有一些只能在 Shadow DOM 内传播)：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[a("br"),t._v("\nFocus Events")]),t._v(": blur, focus, focusin, focusout")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Mouse Events")]),t._v(": click, dblclick, mousedown, mouseenter, mousemove, etc.")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Wheel Events")]),t._v(": wheel")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Input Events")]),t._v(": beforeinput, input")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Keyboard Events")]),t._v(": keydown, keyup")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Composition Events")]),t._v(": compositionstart, compositionupdate, compositionend")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("DragEvent")]),t._v(": dragstart, drag, dragend, drop, etc.")])])]),t._v(" "),a("h1",{attrs:{id:"自定义事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件"}},[t._v("#")]),t._v(" 自定义事件")]),t._v(" "),a("p",[t._v("自定义事件默认不会被影子DOM传递出去。如果你想分发一个自定义事件，并且想传播它，你需要增加bubbles: true和composed: true作为选项。\n看看如何分发这样一个事件:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var container = this.shadowRoot.querySelector('#container');\ncontainer.dispatchEvent(new Event('containerchanged', {bubbles: true, composed: true}));\n")])])]),a("h1",{attrs:{id:"浏览器支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器支持"}},[t._v("#")]),t._v(" 浏览器支持")]),t._v(" "),a("p",[t._v("通过检查attachShadow属性是否存在，可以判断当前浏览器是否支持影子DOM：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;\n")])])]),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91a51a5f2f24422a90ee063f51f07b8~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})])])}),[],!1,null,null,null);e.default=n.exports}}]);