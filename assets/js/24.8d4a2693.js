(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{384:function(e,r,a){"use strict";a.r(r);var n=a(45),t=Object(n.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),a("p",[e._v("异常检测是保证程序能够可靠运行的一个技术手段。")]),e._v(" "),a("p",[e._v("异常检测的一个途径是异常检查。异常检查维持正常的程序流程，同时进行异常的检查，它使用特殊的返回值，辅助的全局变量或者浮点状态值来上报异常。")]),e._v(" "),a("p",[e._v("异常在程序执行的过程中发生，并且会中断正常的流程。这样的中断会触发预定义的异常处理函数。")]),e._v(" "),a("p",[e._v("注意，硬件和软件都可能发生异常。")]),e._v(" "),a("h1",{attrs:{id:"js中的异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中的异常"}},[e._v("#")]),e._v(" JS中的异常")]),e._v(" "),a("p",[e._v("一个JS应用可以运行在各种操作系统，浏览器或者硬件设备中。无论你写多少测试，面对这么复杂的环境，总是会有异常的。\n从终端用户的角度看，JS都是默默处理异常的。但是其背后的机制却有点复杂。\n只要一部分代码出错，JS就会抛出一个异常。JS引擎就不会继续执行代码了，而是要检查一下是否有异常处理的句柄函数。")]),e._v(" "),a("p",[e._v("如果没有异常句柄，引擎就会return，然后抛出一个异常。然后调用栈中的每一个函数都会重复这个步骤，直到找到处理异常的句柄。如果到最后都没有找到句柄，栈中也没有函数了，那么event loop就会把回调队里中的下一个函数加入到栈中。")]),e._v(" "),a("p",[e._v("异常发生时，会生成一个Error对象，并抛出异常。")]),e._v(" "),a("h1",{attrs:{id:"error对象的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#error对象的类型"}},[e._v("#")]),e._v(" Error对象的类型")]),e._v(" "),a("p",[e._v("JS内置了9中异常对象，他们是异常处理的根本：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Error")]),e._v(" - 表示一般通用的异常，经常用来实现用户自定义的异常。")]),e._v(" "),a("li",[a("strong",[e._v("EvalError")]),e._v("- 没有正确使用"),a("code",[e._v("eval()")]),e._v("函数时发生的")]),e._v(" "),a("li",[a("strong",[e._v("RangeError")]),e._v(" - 访问数字变量或者参数时，超出了它的可能范围时发生")]),e._v(" "),a("li",[a("strong",[e._v("ReferenceError")]),e._v(" - 访问一个不存在的变量时发生")]),e._v(" "),a("li",[a("strong",[e._v("SyntaxError")]),e._v(" - 没有遵循JS语法规则时发生。对于静态语言，这个错误是在编译时触发。对于JS则是在执行时触发。")]),e._v(" "),a("li",[a("strong",[e._v("TypeError")]),e._v(" — 当一个值跟预期类型不匹配时发生。调用一个不存在的对象方法，也会引起这个异常")]),e._v(" "),a("li",[a("strong",[e._v("URIError")]),e._v(" —  调用"),a("code",[e._v("encodeURI()")]),e._v(" 和 "),a("code",[e._v("decodeURI()")]),e._v(" 时遇到了不合法的URL")]),e._v(" "),a("li",[a("strong",[e._v("AggregateError")]),e._v(" — 多个异常需要被合并到一次上报中时发生，比如"),a("code",[e._v("Promise.any()")])]),e._v(" "),a("li",[a("strong",[e._v("InternalError")]),e._v(" — JS引擎内部抛出的异常。比如“递归太多”，这个API目前还不是标准化的。")])]),e._v(" "),a("p",[e._v("通过继承内置异常，你还可以自定义异常类型。")]),e._v(" "),a("h1",{attrs:{id:"抛出异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抛出异常"}},[e._v("#")]),e._v(" 抛出异常")]),e._v(" "),a("p",[e._v("JS允许开发者调用"),a("code",[e._v("throw")]),e._v("来触发异常。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('if (denominator === 0) {\n    throw new RangeError("Attempted division by zero");\n}\n')])])]),a("p",[e._v("每一个内置的异常对象，具有一个可选的'message'参数，这样可以异常描述可读性更好。")]),e._v(" "),a("p",[e._v("你可以抛出任何类型的异常，比如数字，字符串，数组等等")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("throw true;\nthrow 113;\nthrow ‘error message’;\nthrow null;\nthrow undefined;\nthrow {x: 1};\nthrow new SyntaxError(‘hard to debug’);\n")])])]),a("p",[e._v("这些都是有效的JS 声明。")]),e._v(" "),a("p",[e._v("使用内置的异常类型比其他对象摇号，因为浏览器会特殊照顾他们，比如引起异常的文件名，行数，调用栈跟踪等。一些浏览器，比如firefox,会为所有类型的异常对象收集这些属性")]),e._v(" "),a("h1",{attrs:{id:"处理异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理异常"}},[e._v("#")]),e._v(" 处理异常")]),e._v(" "),a("p",[e._v("现在看看如何保证异常不会摧毁我们的应用吧。")]),e._v(" "),a("h2",{attrs:{id:"try-语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#try-语句"}},[e._v("#")]),e._v(" “try” 语句")]),e._v(" "),a("p",[e._v("跟其他编程语言类似，JS 具有"),a("code",[e._v("try")]),e._v(", "),a("code",[e._v("catch")]),e._v(", "),a("code",[e._v("finally")]),e._v("声明，让我们得以控制异常流。")]),e._v(" "),a("p",[e._v("比如:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n    // a function that potentially throws an error\n    someFunction();\n} catch (err) {\n    // this code handles exceptions\n    console.log(e.message);\n} finally {\n    // this code will always be executed\n    console.log(finally’);\n}\n")])])]),a("p",[a("code",[e._v("try")]),e._v("语句强制性的包裹住可能抛出异常的代码块。")]),e._v(" "),a("h2",{attrs:{id:"catch-语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#catch-语句"}},[e._v("#")]),e._v(" “catch” 语句")]),e._v(" "),a("p",[e._v("“catch” 语句紧随其后，它包住了异常处理的代码块。“catch” 语句让异常不在扩散，允许程序继续执行。\n异常本身作为一个参数被传递到catch语句。")]),e._v(" "),a("p",[e._v("一些代码块可以抛出不同类型的异常，你的应用可以支持多种异常。\n"),a("code",[e._v("instanceof")]),e._v("操作可以用来区分不同类型的异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n  If (typeof x !== ‘number’) {\n       throw new TypeError(‘x is not a number’);\n  } else if (x <= 0) {\n       throw new RangeError(‘x should be greater than 0’);\n  } else {\n       // Do something useful\n  }\n} catch (err) {\n    if (err instanceof TypeError) {\n      // Handle TypeError exceptions\n    } else if (err instanceof RangeError) {\n      // Handle RangeError exceptions\n  } else {\n      // Handle all other types of exceptions\n  }\n}\n")])])]),a("p",[e._v("这个例子可以重抛一个捕获的异常。比如你虽然捕获了异常，但是它跟你的上下文没有关系，那就可以再次抛出去。、")]),e._v(" "),a("h2",{attrs:{id:"finally-语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finally-语句"}},[e._v("#")]),e._v(" “finally” 语句")]),e._v(" "),a("p",[a("code",[e._v("finally")]),e._v("代码块在"),a("code",[e._v("try")]),e._v(" 和 "),a("code",[e._v("catch")]),e._v("之后执行，无视任何异常（话句话说，只要发生了异常，那么finally就一定会执行）。"),a("code",[e._v("finally")]),e._v("语句可以用来执行一些清理工作，比如关闭WebSocket连接等。")]),e._v(" "),a("p",[e._v("即使异常没有被捕获，"),a("code",[e._v("finally")]),e._v("块也会执行。在这种场景下，finally块执行之后，引擎会继续按顺序检查调用栈中的函数，直到找到正确的异常句柄或者直到应用被关闭。")]),e._v(" "),a("p",[e._v("同样，即使"),a("code",[e._v("try")]),e._v(" 或者"),a("code",[e._v("catch")]),e._v("已经执行了了"),a("code",[e._v("return")]),e._v(" ，finally也还是会执行。")]),e._v(" "),a("p",[e._v("看一个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo1() {\n    try {\n        return true;      \n    } finally {\n        return false;\n    }\n} \n")])])]),a("p",[e._v("执行 "),a("code",[e._v("foo1()")]),e._v("函数，得到返回值"),a("code",[e._v("false")]),e._v(" ，即使"),a("code",[e._v("try")]),e._v("已经有一个"),a("code",[e._v("return")]),e._v(" 声明了。")]),e._v(" "),a("p",[e._v("下面的例子是同样的结果：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo2() {\n    try {\n        throw new Error();      \n    } catch {\n        return true;\n    } finally {\n        return false;\n    }\n} \n")])])]),a("p",[e._v("执行 "),a("code",[e._v("foo1()")]),e._v("函数，得到返回值"),a("code",[e._v("false")])]),e._v(" "),a("h1",{attrs:{id:"处理异步代码中的异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理异步代码中的异常"}},[e._v("#")]),e._v(" 处理异步代码中的异常")]),e._v(" "),a("p",[e._v("之前讨论过JS中异步编程的机制，这里我们看看如果处理“callback functions”, “promises”, 和 “async/await”中的异常。")]),e._v(" "),a("h2",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),a("p",[e._v("定义一个标准的函数，抛出一个异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" async function foo() {\n     throw new Error();\n }\n")])])]),a("p",[e._v("当异常在"),a("code",[e._v("async")]),e._v(" 函数中抛出时，返回的是一个‘rejected’的promise，并伴随了抛出的异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("return Promise.Reject(new Error())\n")])])]),a("p",[e._v("看看当调用"),a("code",[e._v("foo()")]),e._v("时发生了什么")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n    foo();\n} catch(err) {\n    // This block won’t be reached.\n} finally {\n    // This block will be reached before the Promise is rejected.\n}\n")])])]),a("p",[e._v("由于"),a("code",[e._v("foo()")]),e._v("是异步，它分发了一个 "),a("code",[e._v("Promise")]),e._v("。代码不会等待"),a("code",[e._v("async")]),e._v(" 函数结束，所以此时其实没有真正的捕捉到异常。"),a("code",[e._v("finally")]),e._v("块会执行，然后返回一个"),a("code",[e._v("Promise")]),e._v(" 并且rejected。\n我们没有任何代码来处理这个被rejected的"),a("code",[e._v("Promise")]),e._v("。\n在调用"),a("code",[e._v("foo()")]),e._v("时可以添加一个"),a("code",[e._v("await")]),e._v("关键字，并且用"),a("code",[e._v("async")]),e._v("函数包含这段代码，就可以处理这个promise了。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function run() {\n    try {\n        await foo();\n    } catch(err) {\n        // This block will be reached now.\n    } finally {\n        // This block will be reached at the end.\n    }\n}\n run();\n")])])]),a("h2",{attrs:{id:"promises"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promises"}},[e._v("#")]),e._v(" Promises")]),e._v(" "),a("p",[e._v("顶一个函数，在"),a("code",[e._v("Promise")]),e._v("外面扔出一个异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo(x) {\n    if (typeof x !== 'number') {\n        throw new TypeError('x is not a number');\n    }\n\n    return new Promise((resolve, reject) => {\n        resolve(x);\n    });\n}\n")])])]),a("p",[e._v("现在给 "),a("code",[e._v("foo")]),e._v(" 传递一个 "),a("code",[e._v("string")]),e._v("而不是"),a("code",[e._v("number")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("foo(‘test’)\n    .then(x => console.log(x))\n    .catch(err => console.log(err));\n")])])]),a("p",[e._v("这会引起"),a("code",[e._v("Uncaught TypeError: x is not a number")]),e._v(" ，因为promise的"),a("code",[e._v("catch")]),e._v("还不能处理异常--它是在"),a("code",[e._v("Promise")]),e._v("之外抛出的")]),e._v(" "),a("p",[e._v("使用标准的"),a("code",[e._v("try")]),e._v(" 和 "),a("code",[e._v("catch")]),e._v(" 语句可以捕获这个异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n    foo(‘test’)\n    .then(x => console.log(x))\n    .catch(err => console.log(err));\n} catch(err) {\n    // Now the error is handed\n}\n")])])]),a("p",[e._v("如果修改"),a("code",[e._v("foo")]),e._v(" ，在"),a("code",[e._v("Promise")]),e._v("内部抛出异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo(x) {\n    return new Promise((resolve, reject) => {\n       if (typeof x !== 'number') {\n            throw new TypeError('x is not a number');\n       }\n        resolve(x);\n    });\n}\n")])])]),a("p",[e._v("现在"),a("code",[e._v("catch")]),e._v("声明就会处理这个异常")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n    foo(‘test’)\n    .then(x => console.log(x))\n    .catch(err => console.log(err)); // The error is handled here.\n} catch(err) {\n    // This block is not reached since the thrown error is inside of a Promise.\n}\n")])])]),a("p",[e._v("注意，在"),a("code",[e._v("Promise")]),e._v(" 中抛出异常和使用"),a("code",[e._v("reject")]),e._v("回调是一样的。所以可以这样定义"),a("code",[e._v("foo")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo(x) {\n    return new Promise((resolve, reject) => {\n       if (typeof x !== 'number') {\n            reject('x is not a number');\n       }\n        resolve(x);\n    });\n}\n")])])]),a("p",[e._v("如果没有"),a("code",[e._v("catch")]),e._v("方法来处理"),a("code",[e._v("promise")]),e._v("内部的异常，回调队列中的下一个函数就会被添加到调用栈上。")]),e._v(" "),a("h2",{attrs:{id:"callback-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callback-functions"}},[e._v("#")]),e._v(" Callback Functions")]),e._v(" "),a("p",[e._v("使用异常优先的回调策略有两个主要原则：")]),e._v(" "),a("ol",[a("li",[e._v("回调的第一个参数是error对象，如果发生了异常，它的第一个参数会被设置为"),a("code",[e._v("err")]),e._v("然后返回。如果没有异常，"),a("code",[e._v("err")]),e._v("为null")]),e._v(" "),a("li",[e._v("回调的第二个参数是响应过来的数据")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function asyncFoo(x, callback) {\n    // Some async code...\n}\n\nasyncFoo(‘testParam’, (err, result) => {\n    If (err) {\n        // Handle error.\n    }\n    // Do some other work.\n});\n")])])]),a("p",[e._v("如果有一个 "),a("code",[e._v("err")]),e._v("对象，最好不要触碰或者依赖"),a("code",[e._v("result")]),e._v(" 参数。")]),e._v(" "),a("h1",{attrs:{id:"未处理的异常怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未处理的异常怎么办"}},[e._v("#")]),e._v(" 未处理的异常怎么办")]),e._v(" "),a("p",[e._v("如果使用了第三方的库，你就没有权限去处理异常了。当你想处理一些没有句柄的异常时，可以看看下面的例子")]),e._v(" "),a("h2",{attrs:{id:"浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[e._v("#")]),e._v(" 浏览器")]),e._v(" "),a("p",[e._v("浏览器中的"),a("code",[e._v("window.onerror")]),e._v("事件可以处理这种情况：\n例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("window.onerror = (msg, url, line, column, err) => {\n     // ... handle error …\n     return false;\n};\n")])])]),a("p",[e._v("它的参数是这样的：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("msg")]),e._v(" — 异常关联的信息，比如"),a("code",[e._v("Uncaught ReferenceError: foo is not defined")])]),e._v(" "),a("li",[a("strong",[e._v("url")]),e._v(" — 跟这个异常有关的脚本或者文档的URL")]),e._v(" "),a("li",[a("strong",[e._v("lineNo")]),e._v(" — 代码行数(如果有)")]),e._v(" "),a("li",[a("strong",[e._v("columnNo")]),e._v(" — 代码列数(如果有)")]),e._v(" "),a("li",[a("strong",[e._v("err")]),e._v(" — 异常对象(如果有).")])]),e._v(" "),a("p",[e._v("如果一个函数返回true，会阻止默认事件句柄的触发。")]),e._v(" "),a("p",[e._v("每次只能给"),a("code",[e._v("window.onerror")]),e._v(" 赋值一个事件句柄。\n这意味如果你想赋值，那么就要覆盖之前的被第三方库已经写好的句柄。这可能会引起大问题，尤其是像一些异常跟踪的工具，它们可能完全停摆。\n使用下面的小技巧，可以解决这个问题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var oldOnErrorHandler = window.onerror;\nwindow.onerror = (msg, url, line, column, err) => {\n    If (oldOnErrorHandler) {\n        // Call any previously assigned handler.   \n\toldOnErrorHandler.apply(this, arguments);\n    }\n\n    // The rest of your code\n}\n")])])]),a("p",[e._v("这个代码首先检查了是否之前已经定义好了"),a("code",[e._v("window.onerror")]),e._v("，然后在处理前简单的调用一下。使用这种办法，就可以随心所欲的在"),a("code",[e._v("window.onerror")]),e._v("上加句柄了")]),e._v(" "),a("p",[e._v("这种方式在各个浏览器中都能实现。")]),e._v(" "),a("p",[e._v("另外一个不需要替代句柄的方式，是给"),a("code",[e._v("window")]),e._v("对象加事件监听")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("window.addEventListener('error', e => { \n    // Get the error properties from the error event object \n    const { message, filename, lineno, colno, error } = e; \n});\n")])])]),a("p",[e._v("这种方式更好，支持更广泛")]),e._v(" "),a("h2",{attrs:{id:"node-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js"}},[e._v("#")]),e._v(" Node.js")]),e._v(" "),a("p",[a("code",[e._v("EventEmmiter")]),e._v("模块中的"),a("code",[e._v("process")]),e._v("对象，提供两个事件来处理异常：")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("uncaughtException")]),e._v(" -- 当一个未捕获的异常冒泡到了[event loop]时会发生。Node.js默认会把这异常的栈跟踪打印到stderr，然后退出并返回"),a("code",[e._v("code 1")]),e._v("。可以为这这个事件添加一个句柄。使用这个事件的恰当的方式是在线程关闭之前，执行异步的资源清理（比如文件描述符，句柄等等）。这之后再执行正常操作是不安全的。")]),e._v(" "),a("li",[a("code",[e._v("unhandledRejection")]),e._v(" —当"),a("code",[e._v("Promise")]),e._v("被rejected，并且没有异常处理时触发。在探查和跟踪被rejected并且没有异常句柄的promise时，"),a("code",[e._v("unhandledRejection")]),e._v("很有用。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("process\n    .on('unhandledRejection', (reason, promise) => {\n         // Handle failed Promise\n    })\n    .on('uncaughtException', err => {\n        // Handle failed Error   \n        process.exit(1);\n     });\n")])])]),a("p",[e._v("在代码中正确的处理异常是非常重要的，只有理解未处理异常，你才能够正确的处理它们。")]),e._v(" "),a("p",[e._v("你可以自己做，但是可能会有点麻烦，你需要考虑各种浏览器的不同场景。你也可以使用一些第三方的的工具来实现。不管怎么做，你都需要尽可能多的理解异常和异常触发的上下文，这样才能轻松的复现异常。")])])}),[],!1,null,null,null);r.default=t.exports}}]);