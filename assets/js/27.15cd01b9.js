(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{379:function(e,n,r){"use strict";r.r(n);var t=r(45),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("blockquote",[r("p",[e._v("在任何语言中，遍历集合中的每一项都是很常见的操作。JS也不例外的提供了一系列方式来进行集合的遍历，从简单的"),r("code",[e._v("for")]),e._v("循环到复杂的"),r("code",[e._v("map()")]),e._v(" 和 "),r("code",[e._v("filter()")]),e._v(".")])]),e._v(" "),r("p",[r("strong",[e._v("迭代器（Iterators）")]),e._v(" 和 "),r("strong",[e._v("生成器（Generators）")]),e._v(" 带来了迭代的概念，并被内置的JS核心代码中，并且为用户提供了"),r("code",[e._v("for…of")]),e._v(" 循环让用户自定义循环中的逻辑")]),e._v(" "),r("h1",{attrs:{id:"迭代器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[e._v("#")]),e._v(" 迭代器")]),e._v(" "),r("p",[e._v("在JS中，迭代器是一个对象，定义了一个数列，以及在迭代结束时的返回值。\n迭代器是实现了Iterator接口的任意对象。这个对象需要有一个"),r("code",[e._v("next()")]),e._v("方法和一个返回值，这个返回值要包含两个属性：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("value")]),e._v(": 数列中的下一个值")]),e._v(" "),r("li",[r("code",[e._v("done")]),e._v(": 数列全部被访问之后，这个值为true。如果此时value属性也有值，那就是迭代器的返回值。")])]),e._v(" "),r("p",[e._v("迭代器创建之后，只能通过"),r("code",[e._v("next()")]),e._v("方法迭代。访问到最后一个值时，再调用"),r("code",[e._v("next()")]),e._v("将会返回"),r("code",[e._v("{done: true}")])]),e._v(" "),r("h1",{attrs:{id:"使用迭代器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用迭代器"}},[e._v("#")]),e._v(" 使用迭代器")]),e._v(" "),r("p",[e._v("有时为了分配一个数组并遍历它，需要很多的资源。所以迭代器应该在必要的时候才使用。迭代器可以表示不限尺寸的数组。")]),e._v(" "),r("p",[e._v("看一个简单的使用迭代器创建斐波那契数列的例子")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function makeFibonacciSequenceIterator(endIndex = Infinity) {\n  let currentIndex = 0;\n  let previousNumber = 0;\n  let currentNumber = 1;\n\n  return {\n    next: () => {\n      if (currentIndex >= endIndex) { \n          return { value: currentNumber, done: true }; \n      }\n\n      let result = { value: currentNumber, done: false };\n      let nextNumber = currentNumber + previousNumber;\n      previousNumber = currentNumber;\n      currentNumber = nextNumber;\n      currentIndex++;\n\n      return result;\n    }\n  };\n}\n")])])]),r("p",[e._v("这个例子中，迭代器会生成斐波那契数字，一直到"),r("code",[e._v("endIndex")]),e._v("。迭代器每次迭代，回返回当前的斐波那契数字。")]),e._v(" "),r("p",[e._v("我们看一下使用效果：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5); \n// Generates the first 5 numbers.\nlet result = fibonacciSequenceIterator.next();\nwhile (!result.done) {\n    console.log(result.value); // 1 1 2 3 5 8\n    result = fibonacciSequenceIterator.next();\n}\n")])])]),r("h1",{attrs:{id:"定义可迭代对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义可迭代对象"}},[e._v("#")]),e._v(" 定义可迭代对象")]),e._v(" "),r("p",[e._v("上面的代码有一个潜在的问题，就是没有办法验证这个迭代器是否有效。虽然它的返回值中包含了"),r("code",[e._v("next()")]),e._v("方法，但很有可能只是个巧合，很多对象都有这个方法，但是它们并不能迭代。\n因此JS在定义可迭代对象时多了一些要求。")]),e._v(" "),r("p",[e._v("我们用"),r("code",[e._v("for…of")]),e._v("来检验上面的例子，会发现JS是无法识别这个迭代对象的：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);\n\nfor (let x of fibonacciSequenceIterator) {\n    console.log(x);\n}\n")])])]),r("p",[e._v("代码会抛出异常")]),e._v(" "),r("p",[r("code",[e._v("Uncaught TypeError: fibonacciSequenceIterator is not iterable")])]),e._v(" "),r("p",[e._v("一些JS内置类型，比如"),r("code",[e._v("Array")]),e._v(" "),r("code",[e._v("Map")]),e._v(",是默认可以迭代的，而其他的类型就不行。")]),e._v(" "),r("p",[e._v("普通对象要想可迭代，必须实现"),r("code",[e._v("@@iterator")]),e._v("，同时具有一个"),r("code",[e._v("Symbol.iterator")]),e._v("关键属性。这个属性是一个函数，并返回当前迭代到的内容。")]),e._v(" "),r("p",[e._v("上面的例子可以这么改造一下:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function makeFibonacciSequenceIterator(endIndex = Infinity) {\n  let currentIndex = 0;\n  let previousNumber = 0;\n  let currentNumber = 1;\n\n  let iterator = {};\n  iterator[Symbol.iterator] = () => {\n    return {\n      next: () => {\n        if (currentIndex >= endIndex) { \n            return { value: currentNumber, done: true }; \n        }\n        \n        const result = { value: currentNumber, done: false };\n        const nextNumber = currentNumber + previousNumber;\n        previousNumber = currentNumber;\n        currentNumber = nextNumber;\n        currentIndex++;\n\n        return result;\n      }\n    }\n  };\n\n  return iterator;\n}\n")])])]),r("p",[e._v("现在，我们就有了一个可迭代对象了，使用"),r("code",[e._v("for…of")]),e._v("操作试一下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);\n\nfor (let x of fibonacciSequenceIterator) {\n    console.log(x); //1 1 2 3 5 8\n}\n")])])]),r("h1",{attrs:{id:"生成器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成器"}},[e._v("#")]),e._v(" 生成器")]),e._v(" "),r("p",[e._v("自定义迭代器用处很大，在某些场景下非常有效。但是创建和维护它们，需要非常小心的维护它们内部的状态。")]),e._v(" "),r("p",[e._v("而生成器函数提供了一个替代方案，允许开发者定义迭代的步骤，你可以写一个不会持续执行的函数，我们使用"),r("code",[e._v("function*")]),e._v("语法来写。")]),e._v(" "),r("p",[e._v("调用生成器函数，不会初次执行代码，相反它返回了一个特殊类型的迭代器，称之为生成器。调用生成器的next方法生成一个值时，生成器函数就继续执行，直到遇到yield关键字。")]),e._v(" "),r("p",[e._v("生成器可以当做是一个函数，返回一系列的值而不是一个单独的值，并且它是需要被连续调用的。")]),e._v(" "),r("p",[e._v("生成器的语法包含一个"),r("code",[e._v("yield")]),e._v(" ，它可以暂停方法的执行，直到请求下一个值。")]),e._v(" "),r("p",[e._v("看看如何使用生成器生成斐波那契数列")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* makeFibonacciSequenceGenerator(endIndex = Infinity) {\n    let previousNumber = 0;\n    let currentNumber = 1;\n    \n    for (let currentIndex = 0; currentIndex < endIndex; currentIndex++) {\n        yield currentNumber;\n        let nextNumber = currentNumber + previousNumber;\n        previousNumber = currentNumber;\n        currentNumber = nextNumber;\n    }\n}\n\nlet fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(5);\n\nfor (let x of fibonacciSequenceGenerator) {\n    console.log(x);\n}\n")])])]),r("p",[e._v("可以看到这个实现更容易，也更好维护。")]),e._v(" "),r("h2",{attrs:{id:"比生成器更高的控制权"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#比生成器更高的控制权"}},[e._v("#")]),e._v(" 比生成器更高的控制权")]),e._v(" "),r("p",[e._v("迭代器显式定义了"),r("code",[e._v("next()")]),e._v("函数，这是JS接口的需要。使用生成器，则会隐式添加"),r("code",[e._v("next()")]),e._v("函数。这是迭代器生成有效可迭代对象的方式。")]),e._v(" "),r("p",[e._v("迭代器隐式定义的 "),r("code",[e._v("next()")]),e._v(" 函数接受一个参数，这个参数可以用来修改迭代器的内部状态，传递给"),r("code",[e._v("next()")]),e._v("的值会被 "),r("code",[e._v("yield")]),e._v(" 声明接收到。")]),e._v(" "),r("p",[e._v("深度改造一下上面的案例，这样你可以控制每一步可以跳过多少数字")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* makeFibonacciSequenceGenerator(endIndex = Infinity) {\n    let previousNumber = 0;\n    let currentNumber = 1;\n    let skipCount = 0;\n    \n    for (let currentIndex = 0; currentIndex < endIndex; currentIndex++) {\n        if (skipCount === 0) {\n            skipCount = yield currentNumber; // skipCount is the parameter passed through the invocation of `fibonacciSequenceGenerator.next(value)` below.\n            skipCount = skipCount === undefined ? 0 : skipCount; // makes sure that there is an input\n        } else if (skipCount > 0){\n            skipCount--;\n        }\n        \n        let nextNumber = currentNumber + previousNumber;\n        previousNumber = currentNumber;\n        currentNumber = nextNumber;\n    }\n}\n\nlet fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);\n\nconsole.log(fibonacciSequenceGenerator.next().value);  // prints 1\nconsole.log(fibonacciSequenceGenerator.next(3).value); // prints 5 since 1, 2, and 3 are skipped.\nconsole.log(fibonacciSequenceGenerator.next().value);  // prints 8\nconsole.log(fibonacciSequenceGenerator.next(1).value); // prints 21 since 13 is skipped.\n")])])]),r("p",[e._v("需要注意，第一次调用"),r("code",[e._v("next()")]),e._v("传递的参数会被忽略")]),e._v(" "),r("p",[e._v("另一个重要的特性是，可以调用"),r("code",[e._v("throw()")]),e._v("方法来让生成器抛出一个异常。迭代器当前挂起的上下文会抛出这个异常，\n如果迭代器内部没有捕捉这个异常，它会通过调用"),r("code",[e._v("throw()")]),e._v("向上传播，那么后续的"),r("code",[e._v("next()")]),e._v("调用会将done属性设置为true。比如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* makeFibonacciSequenceGenerator(endIndex = Infinity) {\n    let previousNumber = 0;\n    let currentNumber = 1;\n    let skipCount = 0;\n    \n    try {\n      for (let currentIndex = 0; currentIndex < endIndex; currentIndex++) {\n          if (skipCount === 0) {\n              skipCount = yield currentNumber;\n              skipCount = skipCount === undefined ? 0 : skipCount;\n          } else if (skipCount > 0){\n              skipCount--;\n          }\n \n          let nextNumber = currentNumber + previousNumber;\n          previousNumber = currentNumber;\n          currentNumber = nextNumber;\n      }\n    } catch(err) {\n    \tconsole.log(err.message); // will print ‘External throw’ on the fourth iteration.\n    }\n}\n \nlet fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);\n\nconsole.log(fibonacciSequenceGenerator.next(1).value);\nconsole.log(fibonacciSequenceGenerator.next(3).value);\nconsole.log(fibonacciSequenceGenerator.next().value);\nfibonacciSequenceGenerator.throw(new Error('External throw'));\nconsole.log(fibonacciSequenceGenerator.next(1).value); // undefined will be printed since the generator is done.\n")])])]),r("p",[e._v("生成器也是通过调用"),r("code",[e._v("return(value)")]),e._v("方法来结束的。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);\n\nconsole.log(fibonacciSequenceGenerator.next().value); // 1\nconsole.log(fibonacciSequenceGenerator.next(3).value); // 5\nconsole.log(fibonacciSequenceGenerator.next().value);   // 8\nconsole.log(fibonacciSequenceGenerator.return(374).value); // 374\nconsole.log(fibonacciSequenceGenerator.next(1).value); // undefined\n")])])]),r("h2",{attrs:{id:"异步生成器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步生成器"}},[e._v("#")]),e._v(" 异步生成器")]),e._v(" "),r("p",[e._v("可以在异步上下文中定义和使用生成器。异步生成器可以异步的生成一系列的值。\n异步的语法是很好理解的。在定义"),r("code",[e._v("function*")]),e._v("时在加上"),r("code",[e._v("async")]),e._v("就可以了。\n那么在迭代生成的数列时，就需要使用"),r("code",[e._v("await")]),e._v("关键字。\n我们把上面的例子再改造一下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("async function* makeFibonacciSequenceGenerator(endIndex = Infinity) {\n    let previousNumber = 0;\n    let currentNumber = 1;\n    \n    for (let currentIndex = 0; currentIndex < endIndex; currentIndex++) {\n        await new Promise(resolve => setTimeout(resolve, 1000)); // a simple timeout as an example.\n        yield currentNumber;\n        let nextNumber = currentNumber + previousNumber;\n        previousNumber = currentNumber;\n        currentNumber = nextNumber;\n    }\n}\n\n(async () => {\n  const fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(6);\n  for await (let x of fibonacciSequenceGenerator) {\n    console.log(x); // 1, then 1, then 2, then 3, then 5, then 8 (with delay in between).\n  }\n})();\n")])])]),r("p",[e._v("异步生成器中，我们可以使用await，它是基于promise的。"),r("code",[e._v("next()")]),e._v("方法会返回一个"),r("code",[e._v("Promsie")]),e._v("。\n有时候你不想使用生成器，但是你还是想定义一个迭代对象，你可以使用"),r("code",[e._v("Symbol.asyncIterator")]),e._v(" 而不是 "),r("code",[e._v("Symbol.iterator")]),e._v("。\n虽然，相比迭代器，生成器更加简单一点，但是调试起来也麻烦一点。如果使用的是异步上下文的，就更麻烦了，当调用"),r("code",[e._v("throw()")]),e._v("方法时，栈跟踪的信息非常有限，从这些信息中debug是几乎不可能的，你需要向你的用户获取更多的上下文信息。")])])}),[],!1,null,null,null);n.default=o.exports}}]);