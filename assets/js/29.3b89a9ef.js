(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{376:function(a,t,e){"use strict";e.r(t);var n=e(45),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("blockquote",[e("p",[a._v("本文阅读指数:3"),e("br"),a._v("\n函数式编程随有一定的市场，但是目前来看也是说得多做得少。本文帮助你理解一些函数式编程的基本概念。")])]),a._v(" "),e("h1",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" "),e("strong",[a._v("概述")])]),a._v(" "),e("p",[a._v("函数式编程，简单来说就是一个函数，入参是数据，出参是函数。")]),a._v(" "),e("p",[a._v("函数式编程最美妙的地方，是它不会改变我们的入参，也不会产生任何的副作用。状态值是通过函数来表达的。")]),a._v(" "),e("p",[a._v("这一章我们会讨论函数式编程在JS中是如何工作的，以及相关的一些重要概念。")]),a._v(" "),e("h1",{attrs:{id:"面向对象的js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的js"}},[a._v("#")]),a._v(" "),e("strong",[a._v("面向对象的JS")])]),a._v(" "),e("p",[a._v("首先，我们知道JS是基于原型的语言，不是基于类的语言，这种模型经常让开发者困惑。基于类的语言，比如JAVA ,C#的等，主要有两个概念：类和实例。类定义了对象所有的属性，而实例就是将类实例化了。")]),a._v(" "),e("p",[a._v("JS的面向对象风格，只是看起来像，但实际上并不是。表面上看你用的是类语法，但是实际上还是原型")]),a._v(" "),e("p",[a._v("比如：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let Person = class {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  speak() {\n    return `Hello, my name is  ${this.name} and I am ${this.age}`\n  }\n}\n")])])]),e("p",[a._v("注意Person类构造函数有两个参数。关键字"),e("strong",[a._v("this")]),a._v("指向我们的原型，Person。\n我们的方法"),e("strong",[a._v("speak()")]),a._v(" 可以这么使用：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let victor = new Person('Victor', 23);\nconsole.log(victor.speak());\n")])])]),e("p",[e("strong",[a._v("new Person")]),a._v("会调用构造函数，传入的参数就会被设置到"),e("strong",[a._v("victor")]),a._v(" 对象。\n"),e("strong",[a._v("speak()")]),a._v(" 函数会被添加到构造函数的原型上。")]),a._v(" "),e("p",[a._v("我们也可以在Person类之外创建一个新类，扩展它里面的属性和方法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let Work = class extends Person {\n  constructor(name, age, work) {\n    super(name, age);\n    this.work = work\n  }\n  \n  getInfo() {\n    return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.`\n  }\n}\n\nlet alex = new Work('Alex', 30, 'SessionStack');\nconsole.log(alex.getInfo());\n")])])]),e("p",[a._v("我们创建了一个类，继承自Person，并且定义了更多的属性。在基于类的语言中，它被称为子类。")]),a._v(" "),e("p",[a._v("如果使用旧版本的JS该怎么做呢？记住，JS中的类语法实际依然是基于原型的。我们看看发生了什么：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let Person = function(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.speak = function() {\n  return `Hello, my name is  ${this.name} and I am ${this.age}`\n}\n\nlet victor = new Person(`Victor`, 23)\nconsole.log(victor.speak())\n")])])]),e("p",[a._v("上面的代码，我们调用了"),e("strong",[a._v("Person()")]),a._v(" 函数，注意前面还有个关键字"),e("strong",[a._v("new")]),a._v("。new 改变了函数的上下文，所以它被称为构造器。它生成了一个"),e("strong",[a._v("Person")]),a._v(" 对象的实例，并赋值给"),e("strong",[a._v("victor")]),a._v("。\n像上面那样实现对Person的继承，我们可以这么做：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let Work = function(name, age, work) {\n  Person.call(this, name, age);\n  this.work = work;\n}\n")])])]),e("p",[a._v("注意我们没有使用 "),e("strong",[a._v("super()")]),a._v(" 关键字，因为JS中是不存在的。"),e("strong",[a._v("call()")]),a._v(" 接受了"),e("strong",[a._v("this")]),a._v("和其他参数，然后把Person的属性再添加到Workshang 。.call()方法，连接了Person的构造器和Work类。换句话说，我们从"),e("strong",[a._v("Person")]),a._v(" 中借走了属性，并且添加到"),e("strong",[a._v("Work")]),a._v("中。")]),a._v(" "),e("p",[a._v("在原型中，也没有"),e("strong",[a._v("extend")]),a._v("这样的语法。但是可以这么连接Work 和 Person")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Object.setPropertyOf(Work.prototype, Person.prototype);\n")])])]),e("p",[a._v("这样Work就可以使用Person的属性了。给work添加方法的话可以这么做：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Work.prototype.getInfo = function() {\n       return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.`\n}\n\nlet alex = new Work(\"Alex\", 40, 'SessionStack');\nconsole.log(alex.getInfo());\n")])])]),e("p",[a._v("我们需要知道JS是基于原型实现的对象型语言，我们在ES6中使用class 语法，只是一个语法糖。")]),a._v(" "),e("p",[a._v("有了上面的基础，现在来看看JS中的函数式编程：")]),a._v(" "),e("h1",{attrs:{id:"什么是函数式编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是函数式编程"}},[a._v("#")]),a._v(" "),e("strong",[a._v("什么是函数式编程")])]),a._v(" "),e("p",[a._v("在JS中使用函数式编程会容易一点，但是不是对所有开发者都适用。因为JS本身是一个基于原型的语言，它里面的'运行继承’, ‘this’, ‘setPropertyOf’ 已经很让人迷惑了。")]),a._v(" "),e("p",[a._v("不过，跟使用错误的‘this’  banding相比，  JS中的函数式方式会让事情变得简单一点，也更好维护一点。\n使用函数式编程的社区成员还是很多的，在你遇到问题的时候，求助StackOverflow会得到很多帮助。")]),a._v(" "),e("p",[a._v("看一个简单的函数式代码：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const sayHello = function(name) {\n  return `Hello ${name}`;\n}\n\nsayHello('Victor');\n\n# => Hello Victor\n")])])]),e("p",[a._v("我们声明一个函数，有一个参数 "),e("strong",[a._v("name")]),a._v("。非常的简单明了。")]),a._v(" "),e("p",[a._v("但是函数式编程会复杂一点，我们要先理解一些概念：纯函数，高阶函数，不可变性，头等函数等等，")]),a._v(" "),e("h1",{attrs:{id:"js中函数式编程概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js中函数式编程概念"}},[a._v("#")]),a._v(" "),e("strong",[a._v("JS中函数式编程概念")])]),a._v(" "),e("h2",{attrs:{id:"纯函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[a._v("#")]),a._v(" "),e("strong",[a._v("纯函数")])]),a._v(" "),e("p",[a._v("函数式编程的一个主要目标使用纯函数，避免副作用。无副作用的意思就是你的函数逻辑只能跟传入参数有关。我们先看一个有副作用的非纯函数，")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let surname = 'Jonah';\n\nconst sayHi = function() {\n  return `Hi ${surname}`;\n}\n")])])]),e("p",[a._v("上面的代码中，没有输入参数，但是却使用了一个函数之外的全局变量。这就可能引起副作用。")]),a._v(" "),e("p",[a._v("将其改造为纯函数：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const sayHi = function(surname) {\n  return `Hi ${surname}`;\n}\n")])])]),e("p",[a._v("现在函数只关心输入参数，并处理了它。这就是纯函数。\n这就是函数式编程最重要的概念。\n除此之外还有一些小概念要知道")]),a._v(" "),e("h2",{attrs:{id:"高阶函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数"}},[a._v("#")]),a._v(" "),e("strong",[a._v("高阶函数")])]),a._v(" "),e("p",[a._v("高阶函数也是函数，它的入参是函数，出参还是函数，要记住函数也是值，可以被传递来传递去的。例如：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const getSum = function(num) {\n  return num + num;\n}\n\ngetSum(9);\n")])])]),e("p",[a._v("我们创建了一个函数，并赋值给"),e("strong",[a._v("getSum")]),a._v(", 我们还可以把它传递给另一个变量，比如:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const addNum = getSum;\n\naddNum(9);\n")])])]),e("p",[a._v("可以看到，函数可以被当做变量那样传递。因此，也可以被当成是参数传递给"),e("strong",[a._v("高阶函数")]),a._v("。")]),a._v(" "),e("p",[a._v("我们可以持续传递函数到另一个函数中，让我们把很多小函数组合成一个大函数。这被称为"),e("strong",[a._v("组合")]),a._v("。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function a(x) {\n  return x * 2;\n}\n\nfunction b(x) {\n  return x + 1;\n}\n\nfunction c(x) {\n  return x * 3;\n}\n\nconst d = c(b(a(2)));\nconsole.log(d) // 15\n")])])]),e("p",[a._v("我们可以传递每一个函数返回值到下一个函数中。\n这也是我们使用高阶函数的原因，因为它使用组合，让我们的代码更干净")]),a._v(" "),e("p",[a._v("一个比较常用的高阶函数例子是"),e("strong",[a._v("filter()")]),a._v(" 方法。filter()需要传进一个函数，然后返回一个新的数组。例如：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isLarge(value) {\n  return value > 10;\n}\n\nconst dataArray = [10, 11, 12, 3, 4];\n\n\nconst filteredArray = dataArray.filter(isLarge);\nconsole.log(filteredArray); // [11, 12]\n")])])]),e("p",[a._v("回调函数必须返回一个布尔值，如果返回值是true，当前遍历的值就会被加入到新数组中，\n类似的例子还有 map() 和 reduce() 方法。在开始下一节之前，先看看map()的方法：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function squareRoot(value) {\n  return Math.sqrt(value)\n}\n\nconst dataArray = [4, 9, 16];\n\n\nconst mappedArray = dataArray.map(squareRoot);\nconsole.log(mappedArray); // [2, 3, 4]\n")])])]),e("h2",{attrs:{id:"不可变性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不可变性"}},[a._v("#")]),a._v(" "),e("strong",[a._v("不可变性")])]),a._v(" "),e("p",[a._v("函数式编程的另一个重要概述是拒绝异变。异变是指对状态和数据的改变。不可变是指原来的数据不能变，当发生变更时，需要设置一个新的对象。看一个具有异变性的代码：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let data = [1, 2, 3, 4, 4];\n\ndata[4] = 5;\n\nconsole.log(data); // [1, 2, 3, 4, 5]\n")])])]),e("p",[a._v("注意我们把1, 2, 3, 4, 4 改变成了1, 2, 3, 4, 5。这段代码可能引起一些Bug。假设这个数组在某处被使用，但是它其实已经改变了。那么JS中怎么处理不可变性？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('const names = ["Alex", "Victor", "John", "Linda"]\n\nconst newNamesArray = names.slice(1, 3) // ["Victor", "John"]\n')])])]),e("p",[a._v("源数组"),e("strong",[a._v("names")]),a._v(" 没有改变，然后生成了一段新数据。")]),a._v(" "),e("p",[a._v("使用"),e("strong",[a._v("Object.freeze()")]),a._v(" 可以让对象也不可变。这个方法冻结了对象，不允许该对象属性的增加和删除。")]),a._v(" "),e("p",[a._v("例如:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('const employee = {\n  name: "Victor",\n  designation: "Writer",\n  address: {\n    city: "Lagos"\n  }\n};\n\nObject.freeze(employee);\n\nemployee.name = "Max"\n//Outputs: Cannot assign to read-only property \'name\'\n\n//Checks if our object is immutable or not\nObject.isFrozen(employee); // === true\n')])])]),e("p",[a._v("这里，我们的对象就不可变了，并且不能与之交互。\n这里也有一个问题，就是我们如果要改动数组就不得不一遍又一遍的弃用旧数组。如果数组中有成千上万的数据，那么带来的内存消耗和问题会很大。好在现在已经有一些库来帮我们处理这些问题，不如 "),e("a",{attrs:{href:"https://immutable-js.github.io/immutable-js/",target:"_blank",rel:"noopener noreferrer"}},[a._v("immutable.js"),e("OutboundLink")],1),a._v(" 和 "),e("a",{attrs:{href:"https://swannodette.github.io/mori/#immutability",target:"_blank",rel:"noopener noreferrer"}},[a._v("Mori"),e("OutboundLink")],1),a._v(".")]),a._v(" "),e("p",[a._v("有了这些概念，我们已经知道JS 函数式编程的概念和优点了。可以看到我们的代码更易读了，")]),a._v(" "),e("h2",{attrs:{id:"声明式和命令式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明式和命令式"}},[a._v("#")]),a._v(" "),e("strong",[a._v("声明式和命令式")])]),a._v(" "),e("p",[a._v("实现函数式编程，有两种途径：声明式和命令式。命令式是声明你要做的每一步。比如，如果你想做包子，那么命令式会是这样")]),a._v(" "),e("ul",[e("li",[a._v("和面")]),a._v(" "),e("li",[a._v("剁馅儿")]),a._v(" "),e("li",[a._v("包包子")]),a._v(" "),e("li",[a._v("蒸熟")])]),a._v(" "),e("p",[a._v("而声明式只是说出来你想做的。例如，你想做包子，仅此而已，我们不需要去描述每一步。\n不过这些只是简单的描述，告诉你两者的区别。")]),a._v(" "),e("h2",{attrs:{id:"命令式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令式"}},[a._v("#")]),a._v(" "),e("strong",[a._v("命令式:")])]),a._v(" "),e("p",[a._v("这里我们会直接告诉计算机我们做什么事情")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// Function to filter an array; return greater than 5 numbers\n\nconst filterArray = (array) => {\n  let filteredArray = [];\n  for(let i = 0; i < array.length; i++) {\n    if(array[i] > 5) {\n      filteredArray.push(array[i]);\n     }\n  }\n  return filteredArray;\n}\n\nconst array = [1, 2, 3, 4, 5, 6, 7, 8]\nfilterArray(array)\n")])])]),e("p",[a._v("我们没有告诉计算机我们想要什么，只是告诉了我们每一步要做的事情。\n我们的步骤包括：")]),a._v(" "),e("ul",[e("li",[a._v("声明一个空数组")]),a._v(" "),e("li",[a._v("迭代给定数组")]),a._v(" "),e("li",[a._v("如果当前项大于5")]),a._v(" "),e("li",[a._v("如果大于5，就把匹配的项加入到之前声明的空数组中")]),a._v(" "),e("li",[a._v("显示我们的新数组")])]),a._v(" "),e("h2",{attrs:{id:"声明式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明式"}},[a._v("#")]),a._v(" "),e("strong",[a._v("声明式:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// Filter method to give us a new array\n\nconst filterArray = array => array.filter(x => x > 5);\n\nconst array = [1, 2, 3, 4, 5, 6, 7, 8];\n\nconsole.log(filterArray(array)); // [6, 7, 8]\n")])])]),e("p",[a._v("声明式就很简单，我们声明了一个函数，然后让它去做我们想让它做的。")]),a._v(" "),e("h2",{attrs:{id:"为什么大多数人推荐函数式编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么大多数人推荐函数式编程"}},[a._v("#")]),a._v(" "),e("strong",[a._v("为什么大多数人推荐函数式编程")])]),a._v(" "),e("p",[a._v("开发者选择使用函数式编程，有一些共同原因。同时刚学习函数式编程可能会踩坑，但是一旦你彻底理解了整个概念，就会变得很容易。\n这里是一些主要原因：")]),a._v(" "),e("ul",[e("li",[a._v("让代码更加模块化；一个函数可以跟另一个完全不相干的函数合并。由于函数是可组合的，就像React组件那样，可以做到很好的复用。")]),a._v(" "),e("li",[a._v("调试更容易了：更少的Bug，更好的维护性。高阶函数易于调试，且代码量少，我们的代码就会更安全。")]),a._v(" "),e("li",[a._v("开发者更容易读懂你的代码。因为你是按照人类的思维来写的代码，而不是过程性的。")]),a._v(" "),e("li",[a._v("在函数式编程中，开发者倾向于写更加干净快速的代码。而不是迭代代码，像for循环那样。")])]),a._v(" "),e("h1",{attrs:{id:"结论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[a._v("#")]),a._v(" "),e("strong",[a._v("结论")])]),a._v(" "),e("p",[a._v("在这一章，我们总览了以下面向对象的JS工作方式，class语法和传统的基于原型的区别。")]),a._v(" "),e("p",[a._v("介绍了一些函数式编程的概念，帮助你理解使用函数式编程的原因。")]),a._v(" "),e("p",[a._v("没有更好或者更坏的编程模式。这个章节只是帮助你理解函数式编程的概念。")])])}),[],!1,null,null,null);t.default=r.exports}}]);