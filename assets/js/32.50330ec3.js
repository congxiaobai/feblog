(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{377:function(n,t,e){"use strict";e.r(t);var a=e(45),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("blockquote",[e("p",[n._v("本文阅读指数:3"),e("br"),n._v("\n本文对设计模式介绍的比较简单。设计模式其实是非常重要的一个实践，但是大多数前端要么干脆不了解，要么了解了也很少实践。比较推荐大家深入学习一下设计模式。")])]),n._v(" "),e("h1",{attrs:{id:"总览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总览"}},[n._v("#")]),n._v(" 总览")]),n._v(" "),e("p",[n._v("设计模式已经成了标准方案，来解决一些开发中的通用问题。我认为这些设计模式已经成为行业标准了")]),n._v(" "),e("p",[n._v("学习设计模式不仅会让你成为一个更牛掰的开发者，同时也会让你更好的理解一些框架是如何创建的。大多数的框架都采用了某种设计模式，学习之后会让你容易理解一些新出的框架。")]),n._v(" "),e("p",[n._v("可以用任何语言来实现设计模式。它的灵活性很好，你可以随意使用和拓展。")]),n._v(" "),e("p",[n._v("这一章我们会看看JS的设计模式，为什么需要这些模式，以及不同类型的设计模式。")]),n._v(" "),e("h1",{attrs:{id:"设计模式是什么-我们为什么需要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式是什么-我们为什么需要"}},[n._v("#")]),n._v(" "),e("strong",[n._v("设计模式是什么?我们为什么需要？")])]),n._v(" "),e("p",[n._v("设计模式已经成为行业标准，我们可以称之为’templates‘。使用设计模式，可以让我们避免陷入疯狂的代码重复当中。")]),n._v(" "),e("p",[n._v("使用设计模式的主要原因如下：")]),n._v(" "),e("ul",[e("li",[n._v("帮助我们写干净且有组织的代码。因为设计模式可以让我们代码结构更干净，容易调试和维护")]),n._v(" "),e("li",[n._v("他们解决了类似的问题。当我们构建类，解耦代码，复用代码和对象时很容易产生问题。未来，代码的解耦会让开发对代码改动时减少很多Bug。")]),n._v(" "),e("li",[n._v("合理使用设计模式，可以节省很多时间。因为这些模式已经很成熟了，可以明显解决节省时间。")])]),n._v(" "),e("h1",{attrs:{id:"设计模式分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式分类"}},[n._v("#")]),n._v(" "),e("strong",[n._v("设计模式分类")])]),n._v(" "),e("p",[n._v("设计模式主要分三类，创建型，结构型和行为型。\n看看它们是如何被分类的。")]),n._v(" "),e("h2",{attrs:{id:"创建型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建型"}},[n._v("#")]),n._v(" "),e("strong",[n._v("创建型")])]),n._v(" "),e("p",[n._v("这一类主要是为了创建对象。它为特殊的用户场景创建特殊的对象，并隐藏了创建的逻辑，只是暴露接口给我们。")]),n._v(" "),e("p",[n._v("总的来说，我们使用相关接口创建特殊场景下的对象。主要的模式包含：")]),n._v(" "),e("ul",[e("li",[n._v("单例")]),n._v(" "),e("li",[n._v("工厂")]),n._v(" "),e("li",[n._v("抽象工厂")]),n._v(" "),e("li",[n._v("建造者")]),n._v(" "),e("li",[n._v("原型\n我们会看看单例模式的工作原理")])]),n._v(" "),e("p",[e("strong",[n._v("单例模式")])]),n._v(" "),e("p",[n._v("这种模式，确保一个类可以创建一个实例。")]),n._v(" "),e("p",[n._v("这个模式有一些容易误解的参数，但是还是很容易实现。主要的步骤如下：")]),n._v(" "),e("ul",[e("li",[n._v("你的类创建一个对象")]),n._v(" "),e("li",[n._v("创建一个实例")]),n._v(" "),e("li",[n._v("阻止应用在其他地方再次实例化这个对象")]),n._v(" "),e("li",[n._v("把实例当做资源分享")])]),n._v(" "),e("p",[n._v("直接看代码吧，我们先创建一个类，然后稍后让它单例化。")]),n._v(" "),e("p",[n._v("Step 1: 声明一个 "),e("em",[n._v("Manufacture")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Database {\n  constructor() {\n  \tthis.connectionURL = {\n      \tname: "",\n        options: {}\n    }\n  }\n\n  // Our connect method taking in two arguments\n  connect(name, options) {\n  \tthis.connectionURL.name = name;\n  \tthis.connectionURL.options = options;\n        console.log(`DB: ${name} connected!`);\n  }\n\n  // Disconnect method\n  disconnect() {\n    console.log(`${this.connectionURL.name} is disconnected!`);\n  }\n}\n\n// Instantiating our class\nconst db = new Database()\nconsole.log(db.connect("Facebook"))\n')])])]),e("p",[n._v("Step 2:实例化之后，让你的属性无法被修改")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Database {\n  constructor() {\n  \tthis.connectionURL = {\n      \tname: "",\n        options: {}\n    }\n    \n    // This disallows modifying the instance we created\n    Object.freeze(this);\n  }\n\n  // Our connect method taking in two arguments\n  connect(name, options) {\n  \tthis.connectionURL.name = name;\n  \tthis.connectionURL.options = options;\n        console.log(`DB: ${name} connected!`);\n  }\n\n  // Disconnect method\n  disconnect() {\n    console.log(`${this.connectionURL.name} is disconnected!`);\n  }\n}\n\n// Instantiating our class\nconst db = new Database();\nconsole.log(db.connect("Facebook"));\n')])])]),e("p",[n._v("上面的代码中，不允许再增加或者改动属性了。在其他语言，比如JAVA中，我们可以创建一个 "),e("strong",[n._v("getInstance()方法")]),n._v(" ，用来达成单例模式。在上面的JS中，我们使用了"),e("strong",[n._v("constructor()")]),n._v(" 来替代。")]),n._v(" "),e("p",[n._v("Step 3. 让我们的类自己实例化，并检查是否已经实例化过了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Database {\n  constructor() {\n    // Check if our first instance has already been created\n    if (Database.instance instanceof Database) {\n        return Database.instance;   \n    }\n  \tthis.connectionURL = {\n      \tname: "",\n        options: {}\n    }\n    \n    // This disallows modifying the instance we created\n    Object.freeze(this);\n    \n    // Make our class an instance of itself\n    Database.instance = this;\n  }\n\n  // Our connect method taking in two arguments\n  connect(name, options) {\n  \tthis.connectionURL.name = name;\n  \tthis.connectionURL.options = options;\n        console.log(`DB: ${name} connected!`);\n  }\n\n  // Disconnect method\n  disconnect() {\n    console.log(`${this.connectionURL.name} is disconnected!`);\n  }\n}\n\n// Instantiating our class\nconst db = new Database();\nconsole.log(db.connect("Facebook"));\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// Check if our first instance has already been created\nif (Database.instance instanceof Database) {\n   return Database.instance;   \n}\n")])])]),e("p",[n._v("上面的代码中，我们第一次实例化之后，就会检查是否之前已经被实例化了，如果实例化了，就会返回之前实例化的。由此，避免重复实例化。")]),n._v(" "),e("p",[n._v("我们创建两个实例，确认一下它们是否是一样的")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Database {\n  constructor() {\n    if (Database.instance instanceof Database) {\n   \t return Database.instance;   \n    }\n    this.connectionURL = {\n      name: "",\n      options: {}\n    }\n    \n    Database.instance = this;\n }\n\n \n    connect(uri, options) {\n        this.connectionURL.name = name;\n        this.connectionURL.options = options;\n        console.log(`DB: ${uri} connected!`);\n    }\n\n    disconnect() {\n      console.log(`${this.connectionURL.name} is disconnected!`);\n    }\n}\n\nconst db = new Database()\n\nconst db1 = new Database()\n\nconsole.log(db === db1)\n// true\n')])])]),e("p",[n._v("可以看到创建另一个实例是不允许的。\n使用这个模式还要注意一下问题")]),n._v(" "),e("ul",[e("li",[n._v("并发场景。当2个以上的线程想去访问单例中的共享资源，此时有可能不会被立刻获取，会有性能瓶颈。")]),n._v(" "),e("li",[n._v("单例非常像全局变量，所以很难面面俱到的测试到，因为应用中的每一部分都会用到。")])]),n._v(" "),e("h2",{attrs:{id:"结构型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构型"}},[n._v("#")]),n._v(" "),e("strong",[n._v("结构型")])]),n._v(" "),e("p",[n._v("这个模式主要表示实体之间的关系，主要是对象和类的组合。这种模式的两个关键词是组合和继承。")]),n._v(" "),e("p",[n._v("主要的模式包括：")]),n._v(" "),e("ul",[e("li",[n._v("适配模式")]),n._v(" "),e("li",[n._v("外观模式")]),n._v(" "),e("li",[n._v("桥接模式")]),n._v(" "),e("li",[n._v("代理模式")]),n._v(" "),e("li",[n._v("享元模式")])]),n._v(" "),e("p",[n._v("我们主要看一下适配模式")]),n._v(" "),e("p",[e("strong",[n._v("适配模式")])]),n._v(" "),e("p",[n._v("这种模式来桥接两个不兼容的类。我将这种模式当做一个包装器，把两个独立的接口拼接到一起。")]),n._v(" "),e("p",[n._v("比如在真实情况下，我们可以生成一个套接字适配器，连接套接字和不兼容的插件。这种桥接就是适配模式。\n我们看看JS中如何实现。我们会简单解释一下，同时不要跟外观模式混淆。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import { first, middle, last } from "random-name";\n\nclass randomName {\n  generateFirstName() {\n    return first();\n  }\n  \n  generateMiddleName() {\n    return middle();\n  }\n  \n  generateLastName() {\n    return last();\n  }\n}\n\nexport default new randomName();\n')])])]),e("p",[n._v("上面的代码就是适配器，我们可以使用任意库。比如这样：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import name from "./random-name";\n\nclass PlugComponent {\n  constructor() {\n    this.firstName = name.generateFirstName();\n    this.middleName = name.generateMiddleName();\n    this.lastName = name.generateLastName();\n  }\n  \n  generateFullName() {\n    return `${this.firstName} ${this.middleName} ${this.lastName}`\n  }\n}\n\nconst names = new PlugComponent()\nconsole.log(names.generateFullName()) // Victor Victor Jonah\n')])])]),e("p",[n._v("这种模式可以提升复用性和灵活性。")]),n._v(" "),e("h2",{attrs:{id:"行为型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行为型"}},[n._v("#")]),n._v(" "),e("strong",[n._v("行为型")])]),n._v(" "),e("p",[n._v("这种模式聚焦于对象间通信。开发者在让对象间通信时，能够保持解耦性和灵活性。")]),n._v(" "),e("p",[n._v("这种模式主要包含：")]),n._v(" "),e("ul",[e("li",[n._v("责任链")]),n._v(" "),e("li",[n._v("命令模式")]),n._v(" "),e("li",[n._v("解释器")]),n._v(" "),e("li",[n._v("观察者")]),n._v(" "),e("li",[n._v("空对象模式")])]),n._v(" "),e("p",[n._v("我们看一下空对象模式")]),n._v(" "),e("p",[e("strong",[n._v("空对象模式")])]),n._v(" "),e("p",[n._v("这种模式避免返回null，它封装了null行为，并且返回客户端预期的值。大多时候，我们不允许使用null引用。所以我们要做Null检查，这会让我们的代码多很多if/else。使用了这种模式，就不用再写这种逻辑了。")]),n._v(" "),e("p",[n._v("当我们不想返回Null值时，空对象模式很有用。日常中用来捕捉异常也是非常好用的。\n来看看实现：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Cat {\n  sound() {\n    return 'meoow';\n  }\n}\n\nclass NullAnimal {\n  sound() {\n    return \"not an animal\";\n  }\n}\n\nconst getAnimal = (type) => {\n  return type === 'cat' ? new Cat() : new NullAnimal();\n}\n\nconst results = ['cat', null]; \n\nconst response = results.map((animal) => getAnimal(animal).sound());\n// [\"meoow\", \"not an animal\"]\n")])])]),e("p",[n._v("我们没有返回Null引用，返回一个预期的值。")]),n._v(" "),e("h2",{attrs:{id:"最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[n._v("#")]),n._v(" "),e("strong",[n._v("最佳实践")])]),n._v(" "),e("p",[n._v("要最佳实践，看看一些大原则")]),n._v(" "),e("ul",[e("li",[e("strong",[n._v("编码前设计")]),n._v(": 在编码实现之前做设计，是一把利刃。")]),n._v(" "),e("li",[e("strong",[n._v("KISS — 保持简单不做预设")]),n._v(":如果你无法解释它，那它就不够简单。设计模式的目的是保持代码的简单和易于理解。")]),n._v(" "),e("li",[e("strong",[n._v("DRY — 不要重复自己")]),n._v(":让你的函数可复用。不需要到处重复写。")]),n._v(" "),e("li",[e("strong",[n._v("关注分离点")]),n._v(": 分离服务，让每一个子程序承担单一职责。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);