(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{396:function(t,a,r){"use strict";r.r(a);var v=r(45),e=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" OverView")]),t._v(" "),r("p",[t._v("无意中搜到一个系列博客 --[How JS Works ]("),r("a",{attrs:{href:"https://blog.sessionstack.com/how-javascript-works/home",target:"_blank",rel:"noopener noreferrer"}},[t._v("How JavaScript Works – SessionStack Blog"),r("OutboundLink")],1),t._v("),作者是一个叫SessionStack（这个产品没太看懂是做啥的，大概是一种非侵入式的框架，能够监控前端应用的数据，行为，异常等便于你优化应用）的产品的创始人和员工。"),r("br"),t._v("\n博客内容很好，分了两部分。"),r("br"),t._v("\n第一部分有19章，是2017~2018年更新的。这部分已经被翻译成了中文。[详见]("),r("a",{attrs:{href:"https://github.com/Troland/how-javascript-works",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub - Troland/how-javascript-works: Knowledge about how javascript works, event loop,service worker,etc."),r("OutboundLink")],1),t._v(")"),r("br"),t._v("\n第二部分有15章，是今年更新的。国内还没有翻译。")]),t._v(" "),r("h2",{attrs:{id:"为什么要做整个系列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要做整个系列"}},[t._v("#")]),t._v(" 为什么要做整个系列")]),t._v(" "),r("p",[t._v("由于在学习一些小众的框架或者插件的时候，要阅读英文文档，要靠连蒙带猜来应付。"),r("br"),t._v("\n外文文档也是技术宅写的，文笔也很难说流畅，再加上一些计算机术语，读起来也不那么轻松。"),r("br"),t._v("\n因此，我打算自己先译一些文章，提升一下文档阅读能力。"),r("br"),t._v("\n前19章，我会自己翻译+参考大佬们的中文翻译，增加一些注解和删减。"),r("br"),t._v("\n后15章，将会独立翻译。")]),t._v(" "),r("blockquote",[r("p",[t._v("如果读者对运行时，调用栈没有概念，可能要先做一些功课。"),r("br"),t._v("\n本章推荐指数：4（满分5）")])]),t._v(" "),r("p",[r("strong",[t._v("这是 JavaScript 工作原理的第一章。本章会对语言引擎，运行时，调用栈做一个概述。")])]),t._v(" "),r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("p",[t._v("红宝书对JS的定义是，JS = ES+DOM+BOM。"),r("br"),t._v("\n这个定义指出了JS机制的范围，会包含JS引擎，HTML结构，CSS原理，ES等。")]),t._v(" "),r("p",[t._v("我们从V8开始,几乎所有人都已经听说过 V8 引擎的概念，并且很多人知道 JavaScript 是单线程的或者说是使用回调队列的。")]),t._v(" "),r("p",[t._v("本章会详细解释JS的这些概念和工作原理，了解这些细节，帮你跃入黄金段位，写出更流畅的代码。")]),t._v(" "),r("h2",{attrs:{id:"javascript-引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-引擎"}},[t._v("#")]),t._v(" JavaScript 引擎")]),t._v(" "),r("p",[t._v("Chrome 浏览器有一个内核，叫chromium。"),r("br"),t._v("\nchromium中有一个大型的模块，叫渲染引擎。"),r("br"),t._v("\n渲染引擎的责任就是解析HTML，计算CSS，以及执行JS。"),r("br"),t._v("\n其中执行JS的那一部分，就是V8引擎。")]),t._v(" "),r("p",[t._v("V8 引擎有两个常见的宿主环境，一个是Node,一个就是基于chromium的浏览器比如Chrome.")]),t._v(" "),r("p",[t._v("引擎包括两个主要组件：")]),t._v(" "),r("ul",[r("li",[t._v("动态内存管理 － 在这里分配内存")]),t._v(" "),r("li",[t._v("调用栈－这里代码执行即是你的堆栈结构")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04244f7e8fcf4d7e85e1df836201f5f4~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),t._v(" "),r("h2",{attrs:{id:"运行时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时"}},[t._v("#")]),t._v(" 运行时")]),t._v(" "),r("p",[t._v("几乎每个 JavaScript 开发者都使用过一些浏览器 API(比如 setTimeout),要知道这个API并不是引擎所提供的。")]),t._v(" "),r("p",[t._v("那么它们从何而来？我们看一下图，这个图是浏览器的部分架构")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb21a7e0beb3478f9c26a6766b2d64d6~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v("可以看到，除了引擎但是实际上还有更多其它方面的东西。"),r("br"),t._v("\n有被称为 Web API 的东西，这些 Web API 是由浏览器提供的，比如 DOM,AJAX,setTimeout 以及其它。"),r("br"),t._v("\n以及流行的事件循环和回调队列。")]),t._v(" "),r("h2",{attrs:{id:"调用栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用栈"}},[t._v("#")]),t._v(" 调用栈")]),t._v(" "),r("p",[t._v("JavaScript 只是一个单线程的编程语言，这意味着它只有一个调用栈（[什么是调用栈]("),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack",target:"_blank",rel:"noopener noreferrer"}},[t._v("Call stack（调用栈） - 术语表 | MDN (mozilla.org)"),r("OutboundLink")],1),t._v(")）。这样它只能一次做一件事情。")]),t._v(" "),r("p",[t._v("调用栈是一种栈结构，里面会记录我们在程序中的大概位置。")]),t._v(" "),r("p",[t._v("当执行进入一个函数，调用栈把它置于栈的顶部。\n如果函数调用结束，则从栈顶部移除该函数。\n举个栗子。查看如下代码：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function multiply(x, y) {\n  return x * y;\n}\n\nfunction printSquare(x) {\n  var s = multiply(x, x);\n  console.log(s);\n}\n\nprintSquare(5);\n")])])]),r("p",[t._v("当引擎开始执行这段代码的时候"),r("br"),t._v("\n首先调用栈会被清空"),r("br"),t._v("\n之后，产生如下步骤：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80078b87fa5043ec89e204ae419b2e25~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v("调用栈中的每个入口被称为StackFrame。")]),t._v(" "),r("p",[t._v("这正是当浏览器抛出异常的时候，栈追踪是如何被构建的－当发生异常的时候,栈追踪就是调用栈的状态。"),r("br"),t._v("\n如下代码：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function foo() {\n  throw new Error('SessionStack will help you resolve crashes:)');\n}\n\nfunction bar() {\n  foo();\n}\n\nfunction start() {\n  bar();\n}\n\nstart();\n")])])]),r("p",[t._v("如果在 Chrome 中执行（假设代码在 foo.js 的文件中），将会产生如下的堆栈追踪：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1951edacb45d47929700352666441958~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v('"栈溢出"－当栈的空间用完了，还在往上面添加函数执行时会发生这个。这种情况一般发生在有问题的递归或者死循环的时候。查看下如下代码：')]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function foo() {\n  foo();\n}\n\nfoo();\n")])])]),r("p",[t._v("当引擎开始执行这段代码的时候，它开始调用 foo 函数。"),r("br"),t._v("\n但是这个函数会递归调用其自身，而没有任何结束条件。所以在每步执行过程中，调用堆栈会反复地添加同样的函数。执行过程如下所示：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb87092970464f7ebaa4857fbaefa113~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v("终于，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，浏览器就报错了，如下所示：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc68767733eb4120a3b405400b9e6847~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v("单线程的好处是不用处理死锁，并发这种头疼的问题，但是也带来了一些困扰，如果当前的代码运行很慢，浏览器卡顿怎么办？")]),t._v(" "),r("h2",{attrs:{id:"并发和事件循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发和事件循环"}},[t._v("#")]),t._v(" 并发和事件循环")]),t._v(" "),r("p",[t._v("假如你想要在浏览器用 JavaScript 来执行一些复杂的图像转化。")]),t._v(" "),r("p",[t._v("转换的函数会被放在调用栈上执行，此时，浏览器实际上不能做其它任何事－它被阻塞了。浏览器在执行JS的时候，是不能进行渲染的，也就是不能对UI进行更新。如果转换的函数执行太久，那么浏览器的页面就卡住了。")]),t._v(" "),r("p",[t._v("一旦浏览器开始在调用栈中执行这种任务，浏览器将会在相当一段时间内停止交互。大多数浏览器会抛出一个错误，询问你是否关闭网页。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa83de6e19041b28a9cec3fc456f2d8~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),r("p",[t._v("那么，如何不阻塞 UI 且不让浏览器停止响应来执行运行缓慢的代码呢？使用异步回调。")]),t._v(" "),r("p",[t._v("这将会在 『JavaScript 工作原理』\n第二章：『在V8 引擎中如何写最佳代码的 5 条小技巧』中进行详细阐述。")]),t._v(" "),r("h2",{attrs:{id:"单词表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单词表"}},[t._v("#")]),t._v(" 单词表")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th"),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("embedded devices")]),t._v(" "),r("td",[t._v("嵌入式设备")])]),t._v(" "),r("tr",[r("td",[t._v("utilize")]),t._v(" "),r("td",[t._v("利用")])]),t._v(" "),r("tr",[r("td",[t._v("ecosystem")]),t._v(" "),r("td",[t._v("生态系统")])]),t._v(" "),r("tr",[r("td",[t._v("internals")]),t._v(" "),r("td",[t._v("内在，内部")])]),t._v(" "),r("tr",[r("td",[t._v("allocation")]),t._v(" "),r("td",[t._v("分配（一般是内存分配）")])]),t._v(" "),r("tr",[r("td",[t._v("recursion")]),t._v(" "),r("td",[t._v("递归")])]),t._v(" "),r("tr",[r("td",[t._v("scenarios")]),t._v(" "),r("td",[t._v("场景")])]),t._v(" "),r("tr",[r("td",[t._v("concurrency")]),t._v(" "),r("td",[t._v("并发")])])])])])}),[],!1,null,null,null);a.default=e.exports}}]);