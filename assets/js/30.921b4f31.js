(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{380:function(e,n,t){"use strict";t.r(n);var a=t(45),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("本文阅读指数:3"),t("br"),e._v("\n多态的概念其实比较成熟了，但是本文作者理解的多态似乎跟静态语言里的多态不尽相同。")])]),e._v(" "),t("p",[e._v("在现实世界中，一个女性可以具有不同的角色。她可以是同时是妈妈，职工，妻子。根据不同的角色，她需要做不同的行为。这就是多态的概念，只是用另一种形式表现。")]),e._v(" "),t("p",[e._v("在JS中，多态这个概念并不广为人知，但是在面向对象编程中，它是非常核心的一个概念。")]),e._v(" "),t("p",[e._v("面向数据的编程语言，比如Rust。也会用Entity Component System (ECS)实现多态。JS中的编程写法具有不同的模式。在这个主题里，我们将会揭示多态是什么，在JS中怎么使用，多态的不同类型。")]),e._v(" "),t("h1",{attrs:{id:"什么是多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("什么是多态")])]),e._v(" "),t("p",[e._v("假如我们要计算一个区域的面积和周长，我们可能会定义两个方法"),t("code",[e._v("area()")]),e._v(" 和 "),t("code",[e._v("perimeter()")]),e._v("。但是我们不可能用一套算法，来计算不同的形状。比如圆形和三角形的周长公式是不一样的。\n那我们要先定义出基类 "),t("strong",[e._v("shapes")]),e._v("，然后把不同的形状当做它的子类或派生类，他们具有各自的周长计算公式。这就叫多态。\n在编程中，多态的定义是一个对象的能力具有多种模式。下一小节，我们会更加深入的理解JS是如何处理多态的。")]),e._v(" "),t("h1",{attrs:{id:"js如何处理多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js如何处理多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("JS如何处理多态")])]),e._v(" "),t("p",[e._v("不同语言实现多态的方式有所不同。比如JS和JAVA都是面向对象的编程语言，但是实现多态的方式也不同。我们也会看到在封装和继承中多态是如何工作的。")]),e._v(" "),t("h2",{attrs:{id:"多态和面向对象编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态和面向对象编程"}},[e._v("#")]),e._v(" "),t("strong",[e._v("多态和面向对象编程")])]),e._v(" "),t("p",[e._v("面向对象模型依赖的概念是对象和类。通过"),t("code",[e._v("this")]),e._v(" 或 "),t("code",[e._v("self")]),e._v("来改变它的数据字段")]),e._v(" "),t("p",[e._v("我们会对比一下，用JS实现多态和其他面向数据编程实现多态有什么区别（使用ECS）。\n使用面向对象编程，我们可以创建一个类来计算不同形状的面积和周长：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8213aa6523b4ca4ab77cf268d1a6a6b~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('class Shape {\n  area() {\n    return 0;\n  }\n  perimeter() {\n    return 0;\n  }\n  toString() {\n    return Object.getPrototypeOf(this).constructor.name;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(r) {\n    super();\n    this.radius = r;\n  }\n\n  area() {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter() {\n    return Math.PI * this.radius * 2;\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(w, h) {\n    super();\n    this.width = w;\n    this.height = h;\n  }\n\n  area() {\n    return this.width * this.height;\n  }\n  perimeter() {\n    return 2 * (this.width + this.height);\n  }\n}\n\nfunction cumulateShapes(shapes) {\n  return shapes.reduce((sum, shape) => {\n    if (shape instanceof Shape) {\n      console.log(`Shape: ${shape.toString()} - area: ${shape.area()}`);\n      console.log(\n        `Shape: ${shape.toString()} - perimeter: ${shape.perimeter()}`\n      );\n      return sum + shape.area();\n    }\n    throw Error("Bad argument shape.");\n  }, 0);\n}\n\nconst shapes = [new Circle(3), new Rectangle(2, 3)];\n\nconsole.log(cumulateShapes(shapes));\n')])])]),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c65a0cd702646db8b196ce8eb1594b2~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("p",[e._v("如果使用ECS，那么会变成这样")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var Position;\nvar Circle;\nvar Rectangle;\n\nclass CirlceSystem extends Position {\n  OnUpdate() {\n    ComponentQuery.SelectReadOnly(typeof Position, typeof Circle).ForEachEntity(\n      (Entity, Position, Circle) => {\n        /* find area and perimeter */\n      }\n    );\n  }\n}\n\nclass RectangleSystem extends Position {\n  OnUpdate() {\n    ComponentQuery.SelectReadOnly(\n      typeof Position,\n      typeof Rectangle\n    ).ForEachEntity((entity, Position, Rectangle) => {\n      /* find area and perimeter */\n    });\n  }\n}\n")])])]),t("p",[e._v("在JS代码中，我们使用了继承。在ECS代码中，我们使用了ECS模型来实体分发到组件中，解耦数据。")]),e._v(" "),t("p",[e._v("我们深入理解一下，JS中的继承，以及它如何跟多态相关")]),e._v(" "),t("h2",{attrs:{id:"多态和继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态和继承"}},[e._v("#")]),e._v(" "),t("strong",[e._v("多态和继承")])]),e._v(" "),t("p",[e._v("在面向对象的多态中，继承是非常重要的一个特性。\n看一个"),t("code",[e._v("car")]),e._v("的例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Car {\n  constructor(color, speed) {\n    this._speed = speed;\n    this._color = color;\n  }\n}\n")])])]),t("p",[e._v("现在我们有不同的子类了，比如宝马，丰田，本田等等，他们的属性比如颜色和速度有所不同")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('class BMW extends Car {\n  constructor(color, speed, make) {\n    super(color, speed);\n    this._make = make;\n  }\n\n  showInfo() {\n    console.log(\n      "I’m " +\n        this._make +\n        ", my color is " +\n        this._color +\n        ", and my speed is " +\n        this._speed\n    );\n  }\n}\n\nclass Toyota extends Car {\n  constructor(color, speed, make) {\n    super(color, speed);\n    this._make = make;\n  }\n\n  showInfo() {\n    console.log(\n      "I’m " +\n        this._make +\n        ", my color is " +\n        this._color +\n        ", and my speed is " +\n        this._speed\n    );\n  }\n}\n\nclass Bentely extends Car {\n  constructor(color, speed, make) {\n    super(color, speed);\n    this._make = make;\n  }\n\n  showInfo() {\n    console.log(\n      "I’m " +\n        this._make +\n        ", my color is " +\n        this._color +\n        ", and my speed is " +\n        this._speed\n    );\n  }\n}\n')])])]),t("p",[e._v("现在，我们给我们的车添加不同的颜色，速度。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var myBentely = new Bentely('Red', '20mph', 'Bentely');\nvar myBMW = new BMW('Green', '40mph', 'BMW');\nvar myToyota = new Toyota('White', '60mph', 'Toyota');\nconsole.log(myBentely.showInfo()); \nconsole.log(myBMW.showInfo());  \nconsole.log(myToyota.showInfo());\n")])])]),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5088b547ac4a4b87cb1bd9cf36625f~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v("\n在例子中，子类获取了父类的属性，并定义它。继承可以由当前的从父类甚至祖父类中派生。")]),e._v(" "),t("h2",{attrs:{id:"js种继承的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js种继承的类型"}},[e._v("#")]),e._v(" "),t("strong",[e._v("JS种继承的类型")])]),e._v(" "),t("p",[e._v("JS 继承时一个很大的话题，有很多不同的实现方式，比如基于原型的，类的（虚假的类），函数的。我们简单看一下区别，以及他们如何实现多态：")]),e._v(" "),t("p",[t("strong",[e._v("1.")]),e._v(" "),t("strong",[e._v("原型继承")]),e._v("\n原型的比较简单，就在原型上加方法就可以了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let Car = {\n  color: "Red",\n};\nlet BMW = {\n  make: "BMW",\n};\n\nBMW.__proto__ = Car;\n\n// we can find both properties in BMW now:\nconsole.log("This is a " + BMW.color + " " + BMW.make);\n')])])]),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c862295b18104faba9fc423142c2da38~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v(" "),t("strong",[e._v("2.")]),e._v(" "),t("strong",[e._v("类继承")])]),e._v(" "),t("p",[e._v("前面说过，JS种的类时为伪概念，语法糖，所以我们称之为伪类。\nclass的实现是基于new关键字，但是调用的是一个函数。比如，我们有一个car对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Car(make, color, speed) {\n  this.make = make;\n  this.color = color;\n  this.speed = speed;\n}\n")])])]),t("p",[e._v("我们可以使用new 关键字，来给他创建不同的子类。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var Toyota = new Car ("Toyota", "Red", "100mph");\nvar Bentley = new Car ("Bentley", "White", "120mph");\nvar BMW = new Car ("BMW", "Green", "90mph");\n')])])]),t("p",[e._v("使用原型，我们创建了不同的car对象。下一步，我们会看一下如何像继承意向传递原型，以及这样做对多态有什么样的影响\n首先，我们创建一个"),t("code",[e._v("dialogue")]),e._v("函数，让我们的card继承它。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function dialogue() {\n  console.log('I am ' + this.make);\n}\n")])])]),t("p",[e._v("利用原型，让我们的cars来继承它")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Car.prototype.dialogue = function () {\n  console.log(\n    "I am a " +\n      this.color +\n      "  " +\n      this.make +\n      " with  " +\n      this.speed +\n      "  speed "\n  );\n};\nconsole.log(Toyota.dialogue());\nconsole.log(BMW.dialogue());\nconsole.log(Bentley.dialogue());\n')])])]),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cff6e3d1e374f98bd9c2af9a5a23225~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("p",[t("strong",[e._v("3.")]),e._v(" "),t("strong",[e._v("基于函数的继承")])]),e._v(" "),t("p",[e._v("基于函数的继承，是给对象加上增强函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function Person(data) {\n  var that = {};\n  that.name = data.name;\n  return that;\n}\n\n// Create a child object, to inherit from the base Person\nfunction Employee(data) {\n  var that = Person(data);\n  that.sayHello = function () {\n    return "Hello, I\'m " + that.name;\n  };\n  return that;\n}\n\nvar myEmployee = Employee({ name: "Rufi" });\nconsole.log(myEmployee.sayHello());\n')])])]),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1008009e5f4d168b6bd415f11ba443~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("h2",{attrs:{id:"多态和封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态和封装"}},[e._v("#")]),e._v(" "),t("strong",[e._v("多态和封装")])]),e._v(" "),t("p",[e._v("理解了继承，再理解封装就很容易了。在写代码的时候，我们经常需要把一些代码封装起来，这样用户从外面就无法访问里面的值。")]),e._v(" "),t("p",[e._v("例如，我们把验证学生特征的数据组合在一起，然后使用基于原型多态的方式来继承。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function Student(name, marks) {\n  var student_name = name;\n  var student_marks = marks;\n  Object.defineProperty(this, "name", {\n    get: function () {\n      return student_name;\n    },\n    set: function (student_name) {\n      this.student_name = student_name;\n    },\n  });\n\n  Object.defineProperty(this, "marks", {\n    get: function () {\n      return student_marks;\n    },\n    set: function (student_marks) {\n      this.student_marks = student_marks;\n    },\n  });\n}\nvar stud = new Student("Mercy\'s score is: ", 60);\nconsole.log(stud.name + " " + stud.marks);\n')])])]),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5727f21ee2ac4611872e15e6ca838a10~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("p",[e._v("这个例子很好的帮助我们理解JS中的封装和多态。\n很多人不理解抽象和封装的区别。抽象，只能看到一部分信息，其他的部分被隐藏了。而封装，是把数据包带一个单独的实体中，外界无法访问。使用封装最主要的原因是控制和校验数据--就像上面的例子一样。")]),e._v(" "),t("h1",{attrs:{id:"多态的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态的类型"}},[e._v("#")]),e._v(" "),t("strong",[e._v("多态的类型")])]),e._v(" "),t("p",[e._v("JS中实现多态有多种方式，我们讨论以下几种")]),e._v(" "),t("h2",{attrs:{id:"ad-hoc-polymorphism-特设多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ad-hoc-polymorphism-特设多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Ad-hoc Polymorphism（特设多态）")])]),e._v(" "),t("p",[e._v("特设多态是指'视觉上'不同的类型，表现的行为也是不同的。特设多态可以包含同名的，但是参数或返回值不同的函数。")]),e._v(" "),t("p",[e._v("这种类型也被叫做重载，我们看一个操作符的重载。")]),e._v(" "),t("p",[t("strong",[e._v("Operator Overloading")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("5 + 5; // will print 10\n 'I am' + ' ' + '5 years old' // will print I am 5 years old\n")])])]),t("p",[e._v("在上面的例子中，"),t("code",[e._v("+")]),e._v(" 表示了数字相加以及字符串拼接两种范式。")]),e._v(" "),t("h2",{attrs:{id:"参数化多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数化多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("参数化多态")])]),e._v(" "),t("p",[e._v("参数化多态处理普通的函数和数据类型，同时维持静态类型安全。普通函数和数据类型，可以被重写，所以不会基于他们的类型进行区分对待。\n例如，对象保存了不同的数据类型。它不会基于他们的类型来区分他们的值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const Ann = {\nfirstName: 'Ann',\nlastName: 'Kim',\nAge: 4,\nAdult: false\n}\n")])])]),t("p",[e._v("上面的"),t("strong",[e._v("Ann")]),e._v("对象，包含了Ann的名字-字符串类型，年龄--数字类型，是否成年--布尔类型。尽管他们的类型不同，但是对于对象说，处理的方式是差不多的。\n类似的例子还有数组。在JS中，数组可以承载不同的元素。\n"),t("code",[e._v("const Ann = [‘Ann’, ‘Kim’, 4, false];")])]),e._v(" "),t("p",[e._v("数组对它包含的元素处理也是类似的，如果你在控制台运行"),t("code",[e._v("console.log(Ann)")]),e._v("，能发现所有的元素都被打印出来。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee79af01ae34dd38800ee6bc9a64cae~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04ceee391ad34431a3b84794a510237d~tplv-k3u1fbpfcp-watermark.image",alt:"image.png"}}),e._v("\n看另外一个例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const id = (x) => x;\nid(1); // 1\nid("foo"); // "foo"\n')])])]),t("p",[t("code",[e._v("id")]),e._v("不会因为参数"),t("code",[e._v("1")]),e._v(" and "),t("code",[e._v("foo")]),e._v("的类型来判断他们的值。所以你可以给 "),t("code",[e._v("id")]),e._v(" 传入不同类型的参数。")]),e._v(" "),t("h2",{attrs:{id:"子类型多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子类型多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("子类型多态")])]),e._v(" "),t("p",[e._v("子类型多态包含子类型和子类型数据类型。它不会包含新对象的创建，主要基于接口的实现，以及不同的实现方式。")]),e._v(" "),t("p",[e._v("假如你获得了亲人的遗产---一个书店。那么你可以查阅里面的书，查阅遗产账户，书店客户等等，这叫做继承，你获得了遗产里所有的东西。")]),e._v(" "),t("p",[e._v("假如亲人这份遗产没有给你，你可以选择自己重新开一个，然后承担起你亲戚原来的角色，但是根据自己的喜欢做一些改变---这叫子类型。")]),e._v(" "),t("p",[e._v("看个例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function Animal () {\n\n}\n\nAnimal cat = new Cat ("Kitty");\nAnimal Dog = new Cat ("puppy");\nAnimal cat = new Cat ("Kiddy");\n\n//you can go ahead to create different properties for different animals\n')])])]),t("p",[e._v("cat ,dog,goat都是animals的子类型。一个animal可以是任何一个。你可以不同的animal做不同的实现。")]),e._v(" "),t("h1",{attrs:{id:"常见的js多态陷阱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的js多态陷阱"}},[e._v("#")]),e._v(" "),t("strong",[e._v("常见的JS多态陷阱")])]),e._v(" "),t("p",[e._v("我们大概的讲了一下多态，但是也要谨记一些陷阱：")]),e._v(" "),t("ol",[t("li",[e._v("多态会影响你代码的性能。一个单一的函数要比多态函数运行的快。")]),e._v(" "),t("li",[e._v("多态会降低代码的可阅读性。为了解决这个问题，所以在使用多态时写好注释。")]),e._v(" "),t("li",[e._v("JS中实现多态很容易，但是要理解继承。因为JS中多态时围绕继承实现的。")])]),e._v(" "),t("h1",{attrs:{id:"为什么使用多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用多态"}},[e._v("#")]),e._v(" "),t("strong",[e._v("为什么使用多态")])]),e._v(" "),t("p",[e._v("为了复用。\n一方面，因为要使用继承，提升了代码的复用能力。\n另一方面，可以把不同类型的数据放在一起处理。比如我们熟悉的数组。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const Ann = [‘Ann’, ‘Kim’, 4, false];\n")])])]),t("p",[e._v("程序中使用多态，最主要的还是让程序扩展性和维护性更好。")])])}),[],!1,null,null,null);n.default=s.exports}}]);