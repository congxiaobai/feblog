<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/20.4f05958f.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" aria-current="page" class="active sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>影子DOM即Shadow DOM</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b7ccea94174f55a19f1f2df90a3ca5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>网络组件是一种不同的技术，可以让你创建可复用的自定义元素。这些元素是被封装的，跟其他的代码没有关系，可以在网络应用中使用它们。
我们有4个网络组件的标准：</p> <ul><li><p>Shadow DOM</p></li> <li><p>HTML Templates</p></li> <li><p>Custom elements</p></li> <li><p>HTML Imports
这一章我们讨论Shadow DOM，也即影子DOM。<br>
影子DOM是构建基于组件的应用的工具。它给这些问题提供了一个解决方案：</p></li> <li><p><strong>隔离 DOM</strong>: 组件的DOM是独立的（比如document.querySelector()就不会返回组件影子DOM里的节点）。这样就可以使用最简单的CSS选择器，而不用担心命名冲突。</p></li> <li><p><strong>局部CSS</strong>:影子DOM内部的CSS，作用范围是在DOM内部。局部的样式不会泄漏，也不会被外部影响。</p></li> <li><p><strong>组合</strong>: 为你的组件设计一个声明式的，基于标签的API。</p></li></ul> <h1 id="影子dom"><a href="#影子dom" class="header-anchor">#</a> 影子DOM</h1> <p>如果还不熟悉影子DOM的概念和API，可以看看这里<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.<br>
和普通DOM相比，影子DOM有两点不同：</p> <ul><li>个其他页面建立和使用关联的形式</li> <li>跟其他页面关联的变现形式</li></ul> <p>一般情况下，你可以创建一个DOM节点，然后添加到其他元素上的子节点上。至于影子DOM，则创建一个局部的DOM树，添加到元素的子节点，这个树是和元素的实际子节点分离的。这个局部的子树，叫做<strong>shadow tree</strong>。宿主元素则叫<strong>shadow host</strong>。包括 <code>&lt;style&gt;</code> 在内的所有在 shadow 树下创建的任何标签都只作用于宿主元素内部。此即 shadow DOM 如何实现 CSS 局部样式化的原理。</p> <h1 id="创建影子树"><a href="#创建影子树" class="header-anchor">#</a> 创建影子树</h1> <p><strong>shadow root</strong> 是附加到宿主元素的文档片段。宿主元素得到它的影子DOM时，就添加了一个shadow root。调用element.attachShadow()，可以为元素创建一个影子DOM。</p> <div class="language- extra-class"><pre class="language-text"><code>var header = document.createElement('header');
var shadowRoot = header.attachShadow({mode: 'open'});
var paragraphElement = document.createElement('p');

paragraphElement.innerText = 'Shadow DOM';
shadowRoot.appendChild(paragraphElement);
</code></pre></div><p>这个 <a href="http://w3c.github.io/webcomponents/spec/shadow/#h-methods" target="_blank" rel="noopener noreferrer">声明<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>定义了一些不能挂载shadow tree的元素。</p> <h1 id="影子dom的组合"><a href="#影子dom的组合" class="header-anchor">#</a> 影子DOM的组合</h1> <p>组合是影子DOM最重要的特性之一。
写HTML时，需要组合来构建网络应用。构建应用，需要合并和嵌套不同的构建块（元素）比如<code>&lt;div&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;form&gt;</code>等等。<br>
元素组合定义了诸如为何 <code>&lt;select&gt;</code>，<code>&lt;form&gt;</code>，<code>&lt;video&gt;</code> 及其它元素是可扩展的且接受特定的 HTML 元素作为子元素以便用来对这些元素进行特殊处理。</p> <p>比如，<code>&lt;select&gt;</code> 元素知道如何把 <code>&lt;option&gt;</code> 元素渲染成为带有预定义选项的下拉框组件。</p> <p>Shadow DOM 引入如下功能，可以用来组合元素。</p> <h1 id="light-dom"><a href="#light-dom" class="header-anchor">#</a> Light DOM</h1> <p>这是组件书写的用户标记。这个DOM在组件影子DOM之外。它是元素的真实子节点。
假如你创建了一个自定义组件<better-button>，它继承了原生的HTML button，并在内部添加了图像和文本。</better-button></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;extended-button&gt;
  &lt;!-- the image and span are extended-button's light DOM --&gt;
  &lt;img src=&quot;boot.png&quot; slot=&quot;image&quot;&gt;
  &lt;span&gt;Launch&lt;/span&gt;
&lt;/extended-button&gt;
</code></pre></div><p>“extended-button”中的HTML就是Light DOM，这是被用户添加的。
&quot;extended-button&quot;组件就是影子DOM。影子DOM定义了内部结构，局部CSS，封装可很多实现细节。</p> <h1 id="扁平dom树"><a href="#扁平dom树" class="header-anchor">#</a> 扁平DOM树</h1> <p>浏览器分发 light DOM 的结果即，由用户在 Shadow DOM 内部创建的 HTML 内容，这些 HTML 内容构成了自定义组件的结构，渲染出最后的产品界面。扁平树即开发者在开发者工具中看到的内容和页面的渲染结果。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;extended-button&gt;
  #shadow-root
  &lt;style&gt;…&lt;/style&gt;
  &lt;slot name=&quot;image&quot;&gt;
    &lt;img src=&quot;boot.png&quot; slot=&quot;image&quot;&gt;
  &lt;/slot&gt;
  &lt;span id=&quot;container&quot;&gt;
    &lt;slot&gt;
      &lt;span&gt;Launch&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/span&gt;
&lt;/extended-button&gt;
</code></pre></div><h1 id="templates"><a href="#templates" class="header-anchor">#</a> Templates</h1> <p>如果你需要在页面中重复使用相同的标记结构，那么最好使用一些template。以前就能这么做，但是现在使用<code>&lt;template&gt;</code>更加的方便。<code>&lt;template&gt;</code>不会被渲染，但是可以在JS中引用。
比如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template id=&quot;my-paragraph&quot;&gt;
  &lt;p&gt; Paragraph content. &lt;/p&gt;
&lt;/template&gt;
</code></pre></div><p>这段代码不会被渲染。你需要在JS中引用，然后把它添加一个dom上</p> <div class="language- extra-class"><pre class="language-text"><code>var template = document.getElementById('my-paragraph');
var templateContent = template.content;
document.body.appendChild(templateContent);
</code></pre></div><p>也有一些其他的手段实现类似的效果，但是相对来讲，<code>&lt;template&gt;</code>的支持性更好。
看看它的支持情况：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c991a2c009b945d9ae36435c97d7c360~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
Templates 可以自己工作，也可以在定制元素时使用效果更佳。
这一章我们讨论浏览器提供的customElement 接口允许开发者自定义标签内容的渲染。</p> <p>现在定义一个内容是影子DOM是template的组件，<code>&lt;my-paragraph&gt;</code></p> <div class="language- extra-class"><pre class="language-text"><code>customElements.define('my-paragraph',
 class extends HTMLElement {
   constructor() {
     super();

     let template = document.getElementById('my-paragraph');
     let templateContent = template.content;
     const shadowRoot = this.attachShadow({mode: 'open'}).appendChild(templateContent.cloneNode(true));
  }
});
</code></pre></div><p>我们使用了<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode" target="_blank" rel="noopener noreferrer">Node.cloneNode()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>方法来创建一个template的副本，然后添加到shadow root上。
在template中，我们可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style" target="_blank" rel="noopener noreferrer"><code>&lt;style&gt;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来包含一些样式，这些样式会被组件封装起来。当然，在将其附加到一个标准DOM之前，它是不生效的。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template id=&quot;my-paragraph&quot;&gt;
  &lt;style&gt;
    p {
      color: white;
      background-color: #666;
      padding: 5px;
    }
  &lt;/style&gt;
  &lt;p&gt;Paragraph content. &lt;/p&gt;
&lt;/template&gt;
</code></pre></div><p>这样，我们就可以在页面中这么使用它了：
<my-paragraph></my-paragraph></p> <h1 id="slots"><a href="#slots" class="header-anchor">#</a> Slots</h1> <p>template 有一些弊端，最大的问题是它的内容是静态的，我们无法渲染变量/数据，无法像标准的HTML模板那样使用。
 可以解决这个问题。
可以将理解为占位符，可以让你放置你自己的HTML元素。这样，你可以创建通用性的HTML模板，并且添加来进行定制。
看看使用slot是怎么工作的：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template id=&quot;my-paragraph&quot;&gt;
  &lt;p&gt; 
    &lt;slot name=&quot;my-text&quot;&gt;Default text&lt;/slot&gt; 
  &lt;/p&gt;
&lt;/template&gt;
</code></pre></div><p>如果在标记中引用该元素的时候没有定义slot内容，或者浏览器不支持插槽，则 <code>&lt;my-paragraph&gt;</code> 只会包含默认的 &quot;Default text&quot; 内容。
为了定义slot内容，我们需要在<my-paragraph>中包含HTML结构。我们使用一个slot属性，它的值就是你想插入的slot的名字。
看下代码：</my-paragraph></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-paragraph&gt;
 &lt;span slot=&quot;my-text&quot;&gt;Let's have some different text!&lt;/span&gt;
&lt;/my-paragraph&gt;
</code></pre></div><p>可以插入slot的元素叫<a href="https://developer.mozilla.org/en-US/docs/Web/API/Slotable" target="_blank" rel="noopener noreferrer">Slotable<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
已经插入进去的元素，叫做<em>slotted</em></p> <p>上面的例子中<code>&lt;span&gt;</code>就是slotted元素。它具有一个slot属性，值为'my-text'，和模板中插槽定义的 name 属性值相等。
浏览器渲染之后，我们能看到这样的扁平树结构：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-paragraph&gt;
  #shadow-root
  &lt;p&gt;
    &lt;slot name=&quot;my-text&quot;&gt;
      &lt;span slot=&quot;my-text&quot;&gt;Let's have some different text!&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/p&gt;
&lt;/my-paragraph&gt;
</code></pre></div><p>注意#shadow-root只是表示，有一个影子DOM。</p> <h1 id="样式"><a href="#样式" class="header-anchor">#</a> 样式</h1> <p>使用影子DOM的组件，可以被主页面定义样式，也可以自己定义，还可以提供一些钩子让用户重写。</p> <h2 id="组件定义样式"><a href="#组件定义样式" class="header-anchor">#</a> 组件定义样式</h2> <p>影子DOM的重要特性之一是局部CSS</p> <ul><li>外部页面的CSS选择器不会影响到你的组件内部</li> <li>组件内部定义的样式，也不会影响页面的其他部分。他们只作用于宿主元素的范围。
在影子DOM中使用CSS选择器，只会影响组件内部。这样，你就可以使用一些重名的id/类名，不用担心在页面其他部分产生命名冲突。要知道，简单的CSS选择器会有更好的性能。
看看下面的#shadow-root如何定义样式：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>#shadow-root
&lt;style&gt;
  #container {
    background: white;
  }
  #container-items {
    display: inline-flex;
  }
&lt;/style&gt;

&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;container-items&quot;&gt;&lt;/div&gt;
</code></pre></div><p>例子中的样式，都只局限于#shadow-root内部。你还可以使用<link>标签加载样式脚本，同样只是局部生效。</p> <h2 id="host-伪类"><a href="#host-伪类" class="header-anchor">#</a> :host 伪类</h2> <p>:host允许你选择并且样式化寄宿了shadow tree的元素。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
  :host {
    display: block; /* by default, custom elements are display: inline */
  }
&lt;/style&gt;
</code></pre></div><p>使用:host需要注意一个事情，父页面的样式规则具有更高的权重，:host定义的规则权重要低一些。这样，就允许用户从外部来重写顶层样式。同样，:host只会在shadow root的上下文中生效。<br>
:host(<selector>)功能模式允许你关联匹配<selector>的宿主元素。这样你可以封装用户的交互和状态的行为，并且基于宿主节点样式化内部节点。</selector></selector></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;style&gt;
  :host {
    opacity: 0.4;
  }
  
  :host(:hover) {
    opacity: 1;
  }
  
  :host([disabled]) { /* 宿主元素拥有 disabled 属性的样式. */
    background: grey;
    pointer-events: none;
    opacity: 0.4;
  }
  
  :host(.pink) &gt; #tabs {
    color: pink; /* 当宿主元素含有 pink 类时的选项卡样式. */
  }
&lt;/style&gt;
</code></pre></div><h2 id="使用-host-context-伪类的主题和元素"><a href="#使用-host-context-伪类的主题和元素" class="header-anchor">#</a> 使用:host-context(<selector>)伪类的主题和元素</selector></h2> <p>:host-context(<selector>)伪类找出宿主元素或者宿主元素任意的祖先元素匹配 <code>&lt;selector&gt;</code>。
常见的使用场景是定制主题。很多人会给<code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code>上应用样式，来实现定制主题。</selector></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;body class=&quot;lightheme&quot;&gt;
  &lt;custom-container&gt;
  …
  &lt;/custom-container&gt;
&lt;/body&gt;
</code></pre></div><p>当<fancy-tabs>是.lightheme子节点的时候，:host-context(.lightheme)将会样式化它。</fancy-tabs></p> <div class="language- extra-class"><pre class="language-text"><code>:host-context(.lightheme) {
  color: black;
  background: white;
}
</code></pre></div><h2 id="从外部样式化组件的宿主元素"><a href="#从外部样式化组件的宿主元素" class="header-anchor">#</a> 从外部样式化组件的宿主元素</h2> <p>开发者可以从外部通过把标签名作为选择器来样式化组件宿主元素，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>custom-container {
  color: red;
}
</code></pre></div><p>相比影子DOM内部的样式，外部样式的邮件及更高。
例如，如果用户这么写选择器：</p> <div class="language- extra-class"><pre class="language-text"><code>custom-container {
  width: 500px;
}
</code></pre></div><p>就会覆盖掉组件的样式规则：</p> <div class="language- extra-class"><pre class="language-text"><code>:host {
  width: 300px;
}
</code></pre></div><p>样式化组件只能做到这一步了。但是如果我们想样式化组件内部怎么办？我们需要CSS自定义属性</p> <h2 id="使用css自定义属性创建样式钩子"><a href="#使用css自定义属性创建样式钩子" class="header-anchor">#</a> 使用CSS自定义属性创建样式钩子</h2> <p>如果组件开发者使用CSS自定义属性提供了样式钩子，我们就可以改变它的内部样式。这概念有点像。
看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- main page --&gt;
&lt;style&gt;
  custom-container {
    margin-bottom: 60px;
     - custom-container-bg: black;
  }
&lt;/style&gt;

&lt;custom-container background&gt;…&lt;/custom-container&gt;
</code></pre></div><p>影子DOM内部：</p> <div class="language- extra-class"><pre class="language-text"><code>:host([background]) {
  background: var( - custom-container-bg, #CECECE);
  border-radius: 10px;
  padding: 10px;
}
</code></pre></div><p>由于用户提供了背景颜色，所有组件会使用相同的颜色，也就是#CECECE。
作为组件的作者，你有责任让后面开发之道哪些CSS自定义属性可以使用。将它们作为组件公共接口的一部分。</p> <h2 id="插槽js-api"><a href="#插槽js-api" class="header-anchor">#</a> 插槽JS API</h2> <p>影子 DOM API 可能用来操作插槽</p> <h2 id="slotchange事件"><a href="#slotchange事件" class="header-anchor">#</a> slotchange事件</h2> <p>当slot 分发的节点改变了，就会触发这个事件。比如，我们添加/删除了light dom的子节点</p> <div class="language- extra-class"><pre class="language-text"><code>var slot = this.shadowRoot.querySelector('#some_slot');
slot.addEventListener('slotchange', function(e) {
  console.log('Light DOM change');
});
</code></pre></div><p>为了维护light DOM其他类型的变化，你可以使用MutationObserver。我们之前章节中已经讨论过。</p> <h2 id="assignednodes-方法"><a href="#assignednodes-方法" class="header-anchor">#</a> assignedNodes()方法</h2> <p>知道slot关联了什么元素有时候很有用。slot.assignedNodes()方法可以告诉你slot渲染了什么元素。
<code>flatten: true}</code> 选项会返回插槽的默认内容(若没有分发任何节点)。
看一个例子：
<p>Default content</p>
我们假设它在<my-container>组件之中。
看一下使用这个组件有什么不同，以及调用assignedNodes()返回什么：
首先，我们添加自己的内容到slot</my-container></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-container&gt;
  &lt;span slot=&quot;slot1&quot;&gt; container text &lt;/span&gt;
&lt;/my-container&gt;
</code></pre></div><p>调用assignedNodes()将会返回[<span slot="”slot1”"> container text </span>]，注意这个结果是一个节点数组。</p> <p>在第二个案例中，我们放一个空内容
<my-container></my-container> <code>assignedNodes()</code>将会返回一个空数组[]
但是此时如果你传入了{flatten: true}参数，你将会得到一个默认结果：<code>[&lt;p&gt;Default content&lt;/p&gt;]</code>
为了方位slot内部的元素，你可以调用assignedNodes()去看看你的元素被分配给了哪个组件slot。</p> <h1 id="事件模型"><a href="#事件模型" class="header-anchor">#</a> 事件模型</h1> <p>当影子DOM事件冒泡时发生了什么？
目标事件被调整为维护影子DOM的封闭性。当一个事件被重定位，就好像来自于组件本身，而不是组件中的影子DOM中的元素。
这里有传播出 Shadow DOM 的事件列表(还有一些只能在 Shadow DOM 内传播)：</p> <ul><li><p><strong><br>
Focus Events</strong>: blur, focus, focusin, focusout</p></li> <li><p><strong>Mouse Events</strong>: click, dblclick, mousedown, mouseenter, mousemove, etc.</p></li> <li><p><strong>Wheel Events</strong>: wheel</p></li> <li><p><strong>Input Events</strong>: beforeinput, input</p></li> <li><p><strong>Keyboard Events</strong>: keydown, keyup</p></li> <li><p><strong>Composition Events</strong>: compositionstart, compositionupdate, compositionend</p></li> <li><p><strong>DragEvent</strong>: dragstart, drag, dragend, drop, etc.</p></li></ul> <h1 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h1> <p>自定义事件默认不会被影子DOM传递出去。如果你想分发一个自定义事件，并且想传播它，你需要增加bubbles: true和composed: true作为选项。
看看如何分发这样一个事件:</p> <div class="language- extra-class"><pre class="language-text"><code>var container = this.shadowRoot.querySelector('#container');
container.dispatchEvent(new Event('containerchanged', {bubbles: true, composed: true}));
</code></pre></div><h1 id="浏览器支持"><a href="#浏览器支持" class="header-anchor">#</a> 浏览器支持</h1> <p>通过检查attachShadow属性是否存在，可以判断当前浏览器是否支持影子DOM：</p> <div class="language- extra-class"><pre class="language-text"><code>const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91a51a5f2f24422a90ee063f51f07b8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/16.html" class="prev">
        16.存储引擎以及使用场景
      </a></span> <span class="next"><a href="/feblog/howjswork/18.html">
        18.WebRTC 及点对点网络通信机制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/20.4f05958f.js" defer></script>
  </body>
</html>
