<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/30.921b4f31.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" aria-current="page" class="active sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>本文阅读指数:3<br>
多态的概念其实比较成熟了，但是本文作者理解的多态似乎跟静态语言里的多态不尽相同。</p></blockquote> <p>在现实世界中，一个女性可以具有不同的角色。她可以是同时是妈妈，职工，妻子。根据不同的角色，她需要做不同的行为。这就是多态的概念，只是用另一种形式表现。</p> <p>在JS中，多态这个概念并不广为人知，但是在面向对象编程中，它是非常核心的一个概念。</p> <p>面向数据的编程语言，比如Rust。也会用Entity Component System (ECS)实现多态。JS中的编程写法具有不同的模式。在这个主题里，我们将会揭示多态是什么，在JS中怎么使用，多态的不同类型。</p> <h1 id="什么是多态"><a href="#什么是多态" class="header-anchor">#</a> <strong>什么是多态</strong></h1> <p>假如我们要计算一个区域的面积和周长，我们可能会定义两个方法<code>area()</code> 和 <code>perimeter()</code>。但是我们不可能用一套算法，来计算不同的形状。比如圆形和三角形的周长公式是不一样的。
那我们要先定义出基类 <strong>shapes</strong>，然后把不同的形状当做它的子类或派生类，他们具有各自的周长计算公式。这就叫多态。
在编程中，多态的定义是一个对象的能力具有多种模式。下一小节，我们会更加深入的理解JS是如何处理多态的。</p> <h1 id="js如何处理多态"><a href="#js如何处理多态" class="header-anchor">#</a> <strong>JS如何处理多态</strong></h1> <p>不同语言实现多态的方式有所不同。比如JS和JAVA都是面向对象的编程语言，但是实现多态的方式也不同。我们也会看到在封装和继承中多态是如何工作的。</p> <h2 id="多态和面向对象编程"><a href="#多态和面向对象编程" class="header-anchor">#</a> <strong>多态和面向对象编程</strong></h2> <p>面向对象模型依赖的概念是对象和类。通过<code>this</code> 或 <code>self</code>来改变它的数据字段</p> <p>我们会对比一下，用JS实现多态和其他面向数据编程实现多态有什么区别（使用ECS）。
使用面向对象编程，我们可以创建一个类来计算不同形状的面积和周长：</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8213aa6523b4ca4ab77cf268d1a6a6b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <div class="language- extra-class"><pre class="language-text"><code>class Shape {
  area() {
    return 0;
  }
  perimeter() {
    return 0;
  }
  toString() {
    return Object.getPrototypeOf(this).constructor.name;
  }
}

class Circle extends Shape {
  constructor(r) {
    super();
    this.radius = r;
  }

  area() {
    return Math.PI * this.radius ** 2;
  }

  perimeter() {
    return Math.PI * this.radius * 2;
  }
}

class Rectangle extends Shape {
  constructor(w, h) {
    super();
    this.width = w;
    this.height = h;
  }

  area() {
    return this.width * this.height;
  }
  perimeter() {
    return 2 * (this.width + this.height);
  }
}

function cumulateShapes(shapes) {
  return shapes.reduce((sum, shape) =&gt; {
    if (shape instanceof Shape) {
      console.log(`Shape: ${shape.toString()} - area: ${shape.area()}`);
      console.log(
        `Shape: ${shape.toString()} - perimeter: ${shape.perimeter()}`
      );
      return sum + shape.area();
    }
    throw Error(&quot;Bad argument shape.&quot;);
  }, 0);
}

const shapes = [new Circle(3), new Rectangle(2, 3)];

console.log(cumulateShapes(shapes));
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c65a0cd702646db8b196ce8eb1594b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>如果使用ECS，那么会变成这样</p> <div class="language- extra-class"><pre class="language-text"><code>var Position;
var Circle;
var Rectangle;

class CirlceSystem extends Position {
  OnUpdate() {
    ComponentQuery.SelectReadOnly(typeof Position, typeof Circle).ForEachEntity(
      (Entity, Position, Circle) =&gt; {
        /* find area and perimeter */
      }
    );
  }
}

class RectangleSystem extends Position {
  OnUpdate() {
    ComponentQuery.SelectReadOnly(
      typeof Position,
      typeof Rectangle
    ).ForEachEntity((entity, Position, Rectangle) =&gt; {
      /* find area and perimeter */
    });
  }
}
</code></pre></div><p>在JS代码中，我们使用了继承。在ECS代码中，我们使用了ECS模型来实体分发到组件中，解耦数据。</p> <p>我们深入理解一下，JS中的继承，以及它如何跟多态相关</p> <h2 id="多态和继承"><a href="#多态和继承" class="header-anchor">#</a> <strong>多态和继承</strong></h2> <p>在面向对象的多态中，继承是非常重要的一个特性。
看一个<code>car</code>的例子</p> <div class="language- extra-class"><pre class="language-text"><code>class Car {
  constructor(color, speed) {
    this._speed = speed;
    this._color = color;
  }
}
</code></pre></div><p>现在我们有不同的子类了，比如宝马，丰田，本田等等，他们的属性比如颜色和速度有所不同</p> <div class="language- extra-class"><pre class="language-text"><code>class BMW extends Car {
  constructor(color, speed, make) {
    super(color, speed);
    this._make = make;
  }

  showInfo() {
    console.log(
      &quot;I’m &quot; +
        this._make +
        &quot;, my color is &quot; +
        this._color +
        &quot;, and my speed is &quot; +
        this._speed
    );
  }
}

class Toyota extends Car {
  constructor(color, speed, make) {
    super(color, speed);
    this._make = make;
  }

  showInfo() {
    console.log(
      &quot;I’m &quot; +
        this._make +
        &quot;, my color is &quot; +
        this._color +
        &quot;, and my speed is &quot; +
        this._speed
    );
  }
}

class Bentely extends Car {
  constructor(color, speed, make) {
    super(color, speed);
    this._make = make;
  }

  showInfo() {
    console.log(
      &quot;I’m &quot; +
        this._make +
        &quot;, my color is &quot; +
        this._color +
        &quot;, and my speed is &quot; +
        this._speed
    );
  }
}
</code></pre></div><p>现在，我们给我们的车添加不同的颜色，速度。</p> <div class="language- extra-class"><pre class="language-text"><code>var myBentely = new Bentely('Red', '20mph', 'Bentely');
var myBMW = new BMW('Green', '40mph', 'BMW');
var myToyota = new Toyota('White', '60mph', 'Toyota');
console.log(myBentely.showInfo()); 
console.log(myBMW.showInfo());  
console.log(myToyota.showInfo());
</code></pre></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5088b547ac4a4b87cb1bd9cf36625f~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
在例子中，子类获取了父类的属性，并定义它。继承可以由当前的从父类甚至祖父类中派生。</p> <h2 id="js种继承的类型"><a href="#js种继承的类型" class="header-anchor">#</a> <strong>JS种继承的类型</strong></h2> <p>JS 继承时一个很大的话题，有很多不同的实现方式，比如基于原型的，类的（虚假的类），函数的。我们简单看一下区别，以及他们如何实现多态：</p> <p><strong>1.</strong> <strong>原型继承</strong>
原型的比较简单，就在原型上加方法就可以了</p> <div class="language- extra-class"><pre class="language-text"><code>let Car = {
  color: &quot;Red&quot;,
};
let BMW = {
  make: &quot;BMW&quot;,
};

BMW.__proto__ = Car;

// we can find both properties in BMW now:
console.log(&quot;This is a &quot; + BMW.color + &quot; &quot; + BMW.make);
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c862295b18104faba9fc423142c2da38~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> <strong>2.</strong> <strong>类继承</strong></p> <p>前面说过，JS种的类时为伪概念，语法糖，所以我们称之为伪类。
class的实现是基于new关键字，但是调用的是一个函数。比如，我们有一个car对象。</p> <div class="language- extra-class"><pre class="language-text"><code>function Car(make, color, speed) {
  this.make = make;
  this.color = color;
  this.speed = speed;
}
</code></pre></div><p>我们可以使用new 关键字，来给他创建不同的子类。</p> <div class="language- extra-class"><pre class="language-text"><code>var Toyota = new Car (&quot;Toyota&quot;, &quot;Red&quot;, &quot;100mph&quot;);
var Bentley = new Car (&quot;Bentley&quot;, &quot;White&quot;, &quot;120mph&quot;);
var BMW = new Car (&quot;BMW&quot;, &quot;Green&quot;, &quot;90mph&quot;);
</code></pre></div><p>使用原型，我们创建了不同的car对象。下一步，我们会看一下如何像继承意向传递原型，以及这样做对多态有什么样的影响
首先，我们创建一个<code>dialogue</code>函数，让我们的card继承它。</p> <div class="language- extra-class"><pre class="language-text"><code>function dialogue() {
  console.log('I am ' + this.make);
}
</code></pre></div><p>利用原型，让我们的cars来继承它</p> <div class="language- extra-class"><pre class="language-text"><code>Car.prototype.dialogue = function () {
  console.log(
    &quot;I am a &quot; +
      this.color +
      &quot;  &quot; +
      this.make +
      &quot; with  &quot; +
      this.speed +
      &quot;  speed &quot;
  );
};
console.log(Toyota.dialogue());
console.log(BMW.dialogue());
console.log(Bentley.dialogue());
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cff6e3d1e374f98bd9c2af9a5a23225~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p><strong>3.</strong> <strong>基于函数的继承</strong></p> <p>基于函数的继承，是给对象加上增强函数</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(data) {
  var that = {};
  that.name = data.name;
  return that;
}

// Create a child object, to inherit from the base Person
function Employee(data) {
  var that = Person(data);
  that.sayHello = function () {
    return &quot;Hello, I'm &quot; + that.name;
  };
  return that;
}

var myEmployee = Employee({ name: &quot;Rufi&quot; });
console.log(myEmployee.sayHello());
</code></pre></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1008009e5f4d168b6bd415f11ba443~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="多态和封装"><a href="#多态和封装" class="header-anchor">#</a> <strong>多态和封装</strong></h2> <p>理解了继承，再理解封装就很容易了。在写代码的时候，我们经常需要把一些代码封装起来，这样用户从外面就无法访问里面的值。</p> <p>例如，我们把验证学生特征的数据组合在一起，然后使用基于原型多态的方式来继承。</p> <div class="language- extra-class"><pre class="language-text"><code>function Student(name, marks) {
  var student_name = name;
  var student_marks = marks;
  Object.defineProperty(this, &quot;name&quot;, {
    get: function () {
      return student_name;
    },
    set: function (student_name) {
      this.student_name = student_name;
    },
  });

  Object.defineProperty(this, &quot;marks&quot;, {
    get: function () {
      return student_marks;
    },
    set: function (student_marks) {
      this.student_marks = student_marks;
    },
  });
}
var stud = new Student(&quot;Mercy's score is: &quot;, 60);
console.log(stud.name + &quot; &quot; + stud.marks);
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5727f21ee2ac4611872e15e6ca838a10~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>这个例子很好的帮助我们理解JS中的封装和多态。
很多人不理解抽象和封装的区别。抽象，只能看到一部分信息，其他的部分被隐藏了。而封装，是把数据包带一个单独的实体中，外界无法访问。使用封装最主要的原因是控制和校验数据--就像上面的例子一样。</p> <h1 id="多态的类型"><a href="#多态的类型" class="header-anchor">#</a> <strong>多态的类型</strong></h1> <p>JS中实现多态有多种方式，我们讨论以下几种</p> <h2 id="ad-hoc-polymorphism-特设多态"><a href="#ad-hoc-polymorphism-特设多态" class="header-anchor">#</a> <strong>Ad-hoc Polymorphism（特设多态）</strong></h2> <p>特设多态是指'视觉上'不同的类型，表现的行为也是不同的。特设多态可以包含同名的，但是参数或返回值不同的函数。</p> <p>这种类型也被叫做重载，我们看一个操作符的重载。</p> <p><strong>Operator Overloading</strong></p> <div class="language- extra-class"><pre class="language-text"><code>5 + 5; // will print 10
 'I am' + ' ' + '5 years old' // will print I am 5 years old
</code></pre></div><p>在上面的例子中，<code>+</code> 表示了数字相加以及字符串拼接两种范式。</p> <h2 id="参数化多态"><a href="#参数化多态" class="header-anchor">#</a> <strong>参数化多态</strong></h2> <p>参数化多态处理普通的函数和数据类型，同时维持静态类型安全。普通函数和数据类型，可以被重写，所以不会基于他们的类型进行区分对待。
例如，对象保存了不同的数据类型。它不会基于他们的类型来区分他们的值。</p> <div class="language- extra-class"><pre class="language-text"><code>const Ann = {
firstName: 'Ann',
lastName: 'Kim',
Age: 4,
Adult: false
}
</code></pre></div><p>上面的<strong>Ann</strong>对象，包含了Ann的名字-字符串类型，年龄--数字类型，是否成年--布尔类型。尽管他们的类型不同，但是对于对象说，处理的方式是差不多的。
类似的例子还有数组。在JS中，数组可以承载不同的元素。
<code>const Ann = [‘Ann’, ‘Kim’, 4, false];</code></p> <p>数组对它包含的元素处理也是类似的，如果你在控制台运行<code>console.log(Ann)</code>，能发现所有的元素都被打印出来。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee79af01ae34dd38800ee6bc9a64cae~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04ceee391ad34431a3b84794a510237d~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
看另外一个例子</p> <div class="language- extra-class"><pre class="language-text"><code>const id = (x) =&gt; x;
id(1); // 1
id(&quot;foo&quot;); // &quot;foo&quot;
</code></pre></div><p><code>id</code>不会因为参数<code>1</code> and <code>foo</code>的类型来判断他们的值。所以你可以给 <code>id</code> 传入不同类型的参数。</p> <h2 id="子类型多态"><a href="#子类型多态" class="header-anchor">#</a> <strong>子类型多态</strong></h2> <p>子类型多态包含子类型和子类型数据类型。它不会包含新对象的创建，主要基于接口的实现，以及不同的实现方式。</p> <p>假如你获得了亲人的遗产---一个书店。那么你可以查阅里面的书，查阅遗产账户，书店客户等等，这叫做继承，你获得了遗产里所有的东西。</p> <p>假如亲人这份遗产没有给你，你可以选择自己重新开一个，然后承担起你亲戚原来的角色，但是根据自己的喜欢做一些改变---这叫子类型。</p> <p>看个例子</p> <div class="language- extra-class"><pre class="language-text"><code>function Animal () {

}

Animal cat = new Cat (&quot;Kitty&quot;);
Animal Dog = new Cat (&quot;puppy&quot;);
Animal cat = new Cat (&quot;Kiddy&quot;);

//you can go ahead to create different properties for different animals
</code></pre></div><p>cat ,dog,goat都是animals的子类型。一个animal可以是任何一个。你可以不同的animal做不同的实现。</p> <h1 id="常见的js多态陷阱"><a href="#常见的js多态陷阱" class="header-anchor">#</a> <strong>常见的JS多态陷阱</strong></h1> <p>我们大概的讲了一下多态，但是也要谨记一些陷阱：</p> <ol><li>多态会影响你代码的性能。一个单一的函数要比多态函数运行的快。</li> <li>多态会降低代码的可阅读性。为了解决这个问题，所以在使用多态时写好注释。</li> <li>JS中实现多态很容易，但是要理解继承。因为JS中多态时围绕继承实现的。</li></ol> <h1 id="为什么使用多态"><a href="#为什么使用多态" class="header-anchor">#</a> <strong>为什么使用多态</strong></h1> <p>为了复用。
一方面，因为要使用继承，提升了代码的复用能力。
另一方面，可以把不同类型的数据放在一起处理。比如我们熟悉的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>const Ann = [‘Ann’, ‘Kim’, 4, false];
</code></pre></div><p>程序中使用多态，最主要的还是让程序扩展性和维护性更好。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/25.html" class="prev">
        25.函数式编程和基本概念
      </a></span> <span class="next"><a href="/feblog/howjswork/28.html">
        28.Deno 一瞥
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/30.921b4f31.js" defer></script>
  </body>
</html>
