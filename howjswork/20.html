<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概述 | 葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/24.8d4a2693.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" aria-current="page" class="active sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>异常检测是保证程序能够可靠运行的一个技术手段。</p> <p>异常检测的一个途径是异常检查。异常检查维持正常的程序流程，同时进行异常的检查，它使用特殊的返回值，辅助的全局变量或者浮点状态值来上报异常。</p> <p>异常在程序执行的过程中发生，并且会中断正常的流程。这样的中断会触发预定义的异常处理函数。</p> <p>注意，硬件和软件都可能发生异常。</p> <h1 id="js中的异常"><a href="#js中的异常" class="header-anchor">#</a> JS中的异常</h1> <p>一个JS应用可以运行在各种操作系统，浏览器或者硬件设备中。无论你写多少测试，面对这么复杂的环境，总是会有异常的。
从终端用户的角度看，JS都是默默处理异常的。但是其背后的机制却有点复杂。
只要一部分代码出错，JS就会抛出一个异常。JS引擎就不会继续执行代码了，而是要检查一下是否有异常处理的句柄函数。</p> <p>如果没有异常句柄，引擎就会return，然后抛出一个异常。然后调用栈中的每一个函数都会重复这个步骤，直到找到处理异常的句柄。如果到最后都没有找到句柄，栈中也没有函数了，那么event loop就会把回调队里中的下一个函数加入到栈中。</p> <p>异常发生时，会生成一个Error对象，并抛出异常。</p> <h1 id="error对象的类型"><a href="#error对象的类型" class="header-anchor">#</a> Error对象的类型</h1> <p>JS内置了9中异常对象，他们是异常处理的根本：</p> <ul><li><strong>Error</strong> - 表示一般通用的异常，经常用来实现用户自定义的异常。</li> <li><strong>EvalError</strong>- 没有正确使用<code>eval()</code>函数时发生的</li> <li><strong>RangeError</strong> - 访问数字变量或者参数时，超出了它的可能范围时发生</li> <li><strong>ReferenceError</strong> - 访问一个不存在的变量时发生</li> <li><strong>SyntaxError</strong> - 没有遵循JS语法规则时发生。对于静态语言，这个错误是在编译时触发。对于JS则是在执行时触发。</li> <li><strong>TypeError</strong> — 当一个值跟预期类型不匹配时发生。调用一个不存在的对象方法，也会引起这个异常</li> <li><strong>URIError</strong> —  调用<code>encodeURI()</code> 和 <code>decodeURI()</code> 时遇到了不合法的URL</li> <li><strong>AggregateError</strong> — 多个异常需要被合并到一次上报中时发生，比如<code>Promise.any()</code></li> <li><strong>InternalError</strong> — JS引擎内部抛出的异常。比如“递归太多”，这个API目前还不是标准化的。</li></ul> <p>通过继承内置异常，你还可以自定义异常类型。</p> <h1 id="抛出异常"><a href="#抛出异常" class="header-anchor">#</a> 抛出异常</h1> <p>JS允许开发者调用<code>throw</code>来触发异常。</p> <div class="language- extra-class"><pre class="language-text"><code>if (denominator === 0) {
    throw new RangeError(&quot;Attempted division by zero&quot;);
}
</code></pre></div><p>每一个内置的异常对象，具有一个可选的'message'参数，这样可以异常描述可读性更好。</p> <p>你可以抛出任何类型的异常，比如数字，字符串，数组等等</p> <div class="language- extra-class"><pre class="language-text"><code>throw true;
throw 113;
throw ‘error message’;
throw null;
throw undefined;
throw {x: 1};
throw new SyntaxError(‘hard to debug’);
</code></pre></div><p>这些都是有效的JS 声明。</p> <p>使用内置的异常类型比其他对象摇号，因为浏览器会特殊照顾他们，比如引起异常的文件名，行数，调用栈跟踪等。一些浏览器，比如firefox,会为所有类型的异常对象收集这些属性</p> <h1 id="处理异常"><a href="#处理异常" class="header-anchor">#</a> 处理异常</h1> <p>现在看看如何保证异常不会摧毁我们的应用吧。</p> <h2 id="try-语句"><a href="#try-语句" class="header-anchor">#</a> “try” 语句</h2> <p>跟其他编程语言类似，JS 具有<code>try</code>, <code>catch</code>, <code>finally</code>声明，让我们得以控制异常流。</p> <p>比如:</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    // a function that potentially throws an error
    someFunction();
} catch (err) {
    // this code handles exceptions
    console.log(e.message);
} finally {
    // this code will always be executed
    console.log(finally’);
}
</code></pre></div><p><code>try</code>语句强制性的包裹住可能抛出异常的代码块。</p> <h2 id="catch-语句"><a href="#catch-语句" class="header-anchor">#</a> “catch” 语句</h2> <p>“catch” 语句紧随其后，它包住了异常处理的代码块。“catch” 语句让异常不在扩散，允许程序继续执行。
异常本身作为一个参数被传递到catch语句。</p> <p>一些代码块可以抛出不同类型的异常，你的应用可以支持多种异常。
<code>instanceof</code>操作可以用来区分不同类型的异常</p> <div class="language- extra-class"><pre class="language-text"><code>try {
  If (typeof x !== ‘number’) {
       throw new TypeError(‘x is not a number’);
  } else if (x &lt;= 0) {
       throw new RangeError(‘x should be greater than 0’);
  } else {
       // Do something useful
  }
} catch (err) {
    if (err instanceof TypeError) {
      // Handle TypeError exceptions
    } else if (err instanceof RangeError) {
      // Handle RangeError exceptions
  } else {
      // Handle all other types of exceptions
  }
}
</code></pre></div><p>这个例子可以重抛一个捕获的异常。比如你虽然捕获了异常，但是它跟你的上下文没有关系，那就可以再次抛出去。、</p> <h2 id="finally-语句"><a href="#finally-语句" class="header-anchor">#</a> “finally” 语句</h2> <p><code>finally</code>代码块在<code>try</code> 和 <code>catch</code>之后执行，无视任何异常（话句话说，只要发生了异常，那么finally就一定会执行）。<code>finally</code>语句可以用来执行一些清理工作，比如关闭WebSocket连接等。</p> <p>即使异常没有被捕获，<code>finally</code>块也会执行。在这种场景下，finally块执行之后，引擎会继续按顺序检查调用栈中的函数，直到找到正确的异常句柄或者直到应用被关闭。</p> <p>同样，即使<code>try</code> 或者<code>catch</code>已经执行了了<code>return</code> ，finally也还是会执行。</p> <p>看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo1() {
    try {
        return true;      
    } finally {
        return false;
    }
} 
</code></pre></div><p>执行 <code>foo1()</code>函数，得到返回值<code>false</code> ，即使<code>try</code>已经有一个<code>return</code> 声明了。</p> <p>下面的例子是同样的结果：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo2() {
    try {
        throw new Error();      
    } catch {
        return true;
    } finally {
        return false;
    }
} 
</code></pre></div><p>执行 <code>foo1()</code>函数，得到返回值<code>false</code></p> <h1 id="处理异步代码中的异常"><a href="#处理异步代码中的异常" class="header-anchor">#</a> 处理异步代码中的异常</h1> <p>之前讨论过JS中异步编程的机制，这里我们看看如果处理“callback functions”, “promises”, 和 “async/await”中的异常。</p> <h2 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h2> <p>定义一个标准的函数，抛出一个异常</p> <div class="language- extra-class"><pre class="language-text"><code> async function foo() {
     throw new Error();
 }
</code></pre></div><p>当异常在<code>async</code> 函数中抛出时，返回的是一个‘rejected’的promise，并伴随了抛出的异常</p> <div class="language- extra-class"><pre class="language-text"><code>return Promise.Reject(new Error())
</code></pre></div><p>看看当调用<code>foo()</code>时发生了什么</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    foo();
} catch(err) {
    // This block won’t be reached.
} finally {
    // This block will be reached before the Promise is rejected.
}
</code></pre></div><p>由于<code>foo()</code>是异步，它分发了一个 <code>Promise</code>。代码不会等待<code>async</code> 函数结束，所以此时其实没有真正的捕捉到异常。<code>finally</code>块会执行，然后返回一个<code>Promise</code> 并且rejected。
我们没有任何代码来处理这个被rejected的<code>Promise</code>。
在调用<code>foo()</code>时可以添加一个<code>await</code>关键字，并且用<code>async</code>函数包含这段代码，就可以处理这个promise了。</p> <div class="language- extra-class"><pre class="language-text"><code>async function run() {
    try {
        await foo();
    } catch(err) {
        // This block will be reached now.
    } finally {
        // This block will be reached at the end.
    }
}
 run();
</code></pre></div><h2 id="promises"><a href="#promises" class="header-anchor">#</a> Promises</h2> <p>顶一个函数，在<code>Promise</code>外面扔出一个异常</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(x) {
    if (typeof x !== 'number') {
        throw new TypeError('x is not a number');
    }

    return new Promise((resolve, reject) =&gt; {
        resolve(x);
    });
}
</code></pre></div><p>现在给 <code>foo</code> 传递一个 <code>string</code>而不是<code>number</code></p> <div class="language- extra-class"><pre class="language-text"><code>foo(‘test’)
    .then(x =&gt; console.log(x))
    .catch(err =&gt; console.log(err));
</code></pre></div><p>这会引起<code>Uncaught TypeError: x is not a number</code> ，因为promise的<code>catch</code>还不能处理异常--它是在<code>Promise</code>之外抛出的</p> <p>使用标准的<code>try</code> 和 <code>catch</code> 语句可以捕获这个异常</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    foo(‘test’)
    .then(x =&gt; console.log(x))
    .catch(err =&gt; console.log(err));
} catch(err) {
    // Now the error is handed
}
</code></pre></div><p>如果修改<code>foo</code> ，在<code>Promise</code>内部抛出异常</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(x) {
    return new Promise((resolve, reject) =&gt; {
       if (typeof x !== 'number') {
            throw new TypeError('x is not a number');
       }
        resolve(x);
    });
}
</code></pre></div><p>现在<code>catch</code>声明就会处理这个异常</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    foo(‘test’)
    .then(x =&gt; console.log(x))
    .catch(err =&gt; console.log(err)); // The error is handled here.
} catch(err) {
    // This block is not reached since the thrown error is inside of a Promise.
}
</code></pre></div><p>注意，在<code>Promise</code> 中抛出异常和使用<code>reject</code>回调是一样的。所以可以这样定义<code>foo</code></p> <div class="language- extra-class"><pre class="language-text"><code>function foo(x) {
    return new Promise((resolve, reject) =&gt; {
       if (typeof x !== 'number') {
            reject('x is not a number');
       }
        resolve(x);
    });
}
</code></pre></div><p>如果没有<code>catch</code>方法来处理<code>promise</code>内部的异常，回调队列中的下一个函数就会被添加到调用栈上。</p> <h2 id="callback-functions"><a href="#callback-functions" class="header-anchor">#</a> Callback Functions</h2> <p>使用异常优先的回调策略有两个主要原则：</p> <ol><li>回调的第一个参数是error对象，如果发生了异常，它的第一个参数会被设置为<code>err</code>然后返回。如果没有异常，<code>err</code>为null</li> <li>回调的第二个参数是响应过来的数据</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function asyncFoo(x, callback) {
    // Some async code...
}

asyncFoo(‘testParam’, (err, result) =&gt; {
    If (err) {
        // Handle error.
    }
    // Do some other work.
});
</code></pre></div><p>如果有一个 <code>err</code>对象，最好不要触碰或者依赖<code>result</code> 参数。</p> <h1 id="未处理的异常怎么办"><a href="#未处理的异常怎么办" class="header-anchor">#</a> 未处理的异常怎么办</h1> <p>如果使用了第三方的库，你就没有权限去处理异常了。当你想处理一些没有句柄的异常时，可以看看下面的例子</p> <h2 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h2> <p>浏览器中的<code>window.onerror</code>事件可以处理这种情况：
例子：</p> <div class="language- extra-class"><pre class="language-text"><code>window.onerror = (msg, url, line, column, err) =&gt; {
     // ... handle error …
     return false;
};
</code></pre></div><p>它的参数是这样的：</p> <ul><li><strong>msg</strong> — 异常关联的信息，比如<code>Uncaught ReferenceError: foo is not defined</code></li> <li><strong>url</strong> — 跟这个异常有关的脚本或者文档的URL</li> <li><strong>lineNo</strong> — 代码行数(如果有)</li> <li><strong>columnNo</strong> — 代码列数(如果有)</li> <li><strong>err</strong> — 异常对象(如果有).</li></ul> <p>如果一个函数返回true，会阻止默认事件句柄的触发。</p> <p>每次只能给<code>window.onerror</code> 赋值一个事件句柄。
这意味如果你想赋值，那么就要覆盖之前的被第三方库已经写好的句柄。这可能会引起大问题，尤其是像一些异常跟踪的工具，它们可能完全停摆。
使用下面的小技巧，可以解决这个问题</p> <div class="language- extra-class"><pre class="language-text"><code>var oldOnErrorHandler = window.onerror;
window.onerror = (msg, url, line, column, err) =&gt; {
    If (oldOnErrorHandler) {
        // Call any previously assigned handler.   
	oldOnErrorHandler.apply(this, arguments);
    }

    // The rest of your code
}
</code></pre></div><p>这个代码首先检查了是否之前已经定义好了<code>window.onerror</code>，然后在处理前简单的调用一下。使用这种办法，就可以随心所欲的在<code>window.onerror</code>上加句柄了</p> <p>这种方式在各个浏览器中都能实现。</p> <p>另外一个不需要替代句柄的方式，是给<code>window</code>对象加事件监听</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('error', e =&gt; { 
    // Get the error properties from the error event object 
    const { message, filename, lineno, colno, error } = e; 
});
</code></pre></div><p>这种方式更好，支持更广泛</p> <h2 id="node-js"><a href="#node-js" class="header-anchor">#</a> Node.js</h2> <p><code>EventEmmiter</code>模块中的<code>process</code>对象，提供两个事件来处理异常：</p> <ol><li><code>uncaughtException</code> -- 当一个未捕获的异常冒泡到了[event loop]时会发生。Node.js默认会把这异常的栈跟踪打印到stderr，然后退出并返回<code>code 1</code>。可以为这这个事件添加一个句柄。使用这个事件的恰当的方式是在线程关闭之前，执行异步的资源清理（比如文件描述符，句柄等等）。这之后再执行正常操作是不安全的。</li> <li><code>unhandledRejection</code> —当<code>Promise</code>被rejected，并且没有异常处理时触发。在探查和跟踪被rejected并且没有异常句柄的promise时，<code>unhandledRejection</code>很有用。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>process
    .on('unhandledRejection', (reason, promise) =&gt; {
         // Handle failed Promise
    })
    .on('uncaughtException', err =&gt; {
        // Handle failed Error   
        process.exit(1);
     });
</code></pre></div><p>在代码中正确的处理异常是非常重要的，只有理解未处理异常，你才能够正确的处理它们。</p> <p>你可以自己做，但是可能会有点麻烦，你需要考虑各种浏览器的不同场景。你也可以使用一些第三方的的工具来实现。不管怎么做，你都需要尽可能多的理解异常和异常触发的上下文，这样才能轻松的复现异常。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/19.html" class="prev">
        19.自定义元素机制
      </a></span> <span class="next"><a href="/feblog/howjswork/21.html">
        21.XSS的5种方式和防范策略
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/24.8d4a2693.js" defer></script>
  </body>
</html>
