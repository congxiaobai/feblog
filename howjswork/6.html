<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/36.faf60c12.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" aria-current="page" class="active sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>这一次我们将来研究一下WebAssembly的工作原理，分析一下在为啥在这些指标上比JS表现更好：加载事件，执行速度，垃圾回收，内容使用，平台API，调试以及多线程和可移植性。
构建Web应用的方式正在革命的边缘---虽然这只是早期，但是确实要思考一下构建方式将要改变了！</p> <h2 id="webassembly-是啥"><a href="#webassembly-是啥" class="header-anchor">#</a> WebAssembly 是啥</h2> <p>WebAssembly (以下简称 <strong>wasm</strong>) 是一个高性能的, 给Web使用的底层字节码。</p> <p>WASM 让你使用更多的编程语言来写程序(比如 C, C++, Rust 及其他), 然后编译成WebAssembly。
这样web应用可以快速加载和执行。</p> <h2 id="加载时间"><a href="#加载时间" class="header-anchor">#</a> 加载时间</h2> <p>浏览器需要加载所有的<code>.js</code>文本文件，这样才能记载JavaScript。</p> <p>浏览器加载WebAssembly更快，因为只要传递已经表编译好的wasm文件。wasm是底层的 assembly类语言，只是一个非常紧凑的二进制格式。</p> <h2 id="执行"><a href="#执行" class="header-anchor">#</a> 执行</h2> <p>运行Wasm只比本地码执行慢20%，这个是amazing的结果。这种格式，是在一个沙箱环境中编译的，运行时也加了很多的限制来确保没有安全漏洞，或者强化它们。最小化的本地代码相比，它是慢了一点，但是在未来肯定会更快的。</p> <p>更棒的是，它是浏览器无关的---也就是大多数的浏览器引擎已经支持了WebAssembly，并且提供了非常相近的执行时间。</p> <p>看一下V8中发生了什么：</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ab10f551514dc8a4ebfa60666d3d83~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>在左边，我们有一些JS资源，包含了JS函数。首先需要转换，把所有的字符串转换成AST。这个AST是你的JS程序的逻辑的内存描述。一旦AST生成了，V8 直接转换成机器码。遍历树，然后生成机器码，在这里你获得了你编译好的函数。这里没有尝试去加速。</p> <p>下一步，V8 的管道将会发生什么呢？</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9533956728854995b7091ddc60f0204f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>这次我们有[TurboFan]，这是V8中的一个优化过的编译器。当你的JS 应用在运行，代码运行在V8中。TurboFan监听是否有东西运行慢了，是否是瓶颈了，就将其标记为热点，以便于优化他们。它在后台推送他们，这个后台是优化过的JIT，JIT为这些函数创建了更快的代码，但是要吃掉大部分的CPU。</p> <p>它解决了问题，但是这些分析和优化的流程耗费CPU资源。在移动设备上，就意味着更高的电池消耗。
但是，wasm 不需要这些了--它像这样插入工作流程：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53827888223c48d0b9ab08f014b66f18~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>wasm已经在编译阶段优化了。因此，转化也不需要了。你直接得道了一个优化过的二进制代码，直接注入到后端，生成机器码。所有的额优化已经被前面的编译器做完了。</p> <p>这样让wasm的执行更加的高效，因为只有少数的步骤要处理，可以略过。</p> <h2 id="内存模型"><a href="#内存模型" class="header-anchor">#</a> 内存模型</h2> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200f3516044a4eb1a52cbf418e3802f5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>假如C++程序编译成了WebAssembly，这个程序的内存模型是连续的内存块，没有'洞'。wasm的一个有助于安全启动的特性是，执行栈的概念从线性内存中独立了。在C++程序中，你有堆，可以从堆得顶部分配内存，然后添加到栈空间。获取一个指针，然后在栈内存中查找去操作本不应被你接触的变量值。</p> <p>这给恶意软件提供了一个漏洞。</p> <p>使用了完全不同的方式。 执行栈从WebAssembly程序中剥离出来了，所以没有办法改变内部的东西比如像变量。 同样，函数在内存中使用整数偏移量而不是指针。函数指针存放在一个中间的函数表中。他们直接计算了模块方法中的跳转量。这种构建方式，你可以并行加载多个wasm模块，偏移所有的索引并且可以正常工作。</p> <p>如果想知道更多关于内存模型和管理的细节，请查看我们的第四章内容。</p> <h2 id="gc"><a href="#gc" class="header-anchor">#</a> GC</h2> <p>已知JS的内存管理是由GC处理的。
WebAssembly有点不同。它支持的语言是手动管理内存，在你的wasm谋爱中你可以主宰自己的GC，但是这是一个复杂的工作
如今，WebAssembly是被设计围绕C++ 和 RUST的。因为wasm是很底层的，使用仅在它之上一层的编程语言来编译更加容易。C语言可以使用malloc，C++ 可以使用智能指针，rust使用一个完全不同的方式（既控制权转移等）。这些语言不需要GC,所以他们不需要任何复杂的运行时去跟踪栈内存。WebAssembly天然适配这些语言。</p> <p>这些语言不是100% 的设计出来去处理复杂的JS事务，像DOM操作。用C++写一整个HTML应用是不合理的，因为不是设计给它的。在大多数情况下，工程师写C++，rust 目标是WebGL或者高度优化的库（比如一些重数学计算的）
未来，WebAssembly将会支持更多不带GC的语言</p> <h2 id="平台-api"><a href="#平台-api" class="header-anchor">#</a> 平台 API</h2> <p>依赖于执行JS的运行时，可以通过 JavaScript 程序来直接访问这些平台所暴露出的指定接口。例如，你在浏览器中运行JS，你需要一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="noopener noreferrer">Web APIs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的集合。这样你的应用可以控制浏览器/设备的功能以及
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener noreferrer">DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener noreferrer">CSSOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" target="_blank" rel="noopener noreferrer">WebGL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener noreferrer">IndexedDB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener noreferrer">Web Audio API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,等</p> <p>WebAssembly模块没有权限访问任何平台的API，一切都要靠JS来中介。如果你想访问一些平台特有的API，你需要通过JS来调用。</p> <p>例如，如果你想调用<code>console.log</code>，你需要通过JS而不是C++，这样的话自然会有一些性能损耗。<br>
但这不会是常态，规范将会提供更多的平台api，这样你就不用写JS了</p> <h2 id="source-maps"><a href="#source-maps" class="header-anchor">#</a> Source maps</h2> <p>当你的JS代码已经最小化了，你需要一个办法去正确的调试代码。这就是SourceMap出现的地方。</p> <p>SourceMap是映射合并/最小化的文件到未构建状态的一种方式。只要构建产品，就要生成一个SourceMap，它包含了原始文件的所有信息。当你在生成的JS中查询一个确定的行或者列的数字，你可以查找SourceMap，它会返回一个原始的位置。</p> <p>WebAssembly 当前不支持SourceMap,因为规范没写，但是它将来会支持的（或许很快）</p> <p>当你在C++代码中打一个断点在，你将会看到C++代码而不是WebAssembly。这是我们的目标。</p> <h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <p>JS是单线程的。虽然JS使用 Web Workers，但是他们有一些指定的场景----基本上，任何CPU密集型计算都会阻塞你的主UI线程，这时候使用 Web Workers是有好处的。但是， Web Workers不能访问DOM
WebAssembly当前也不支持多线程。但是，它即将到来了。Wasm将很接近本地线程（像C++ 风格的线程）。具有真线程将会创建很多新的机会。当然，也会打开滥用之门。</p> <h2 id="可移植性"><a href="#可移植性" class="header-anchor">#</a> 可移植性</h2> <p>如今JS可以在任何地方运行，从浏览器到服务端，甚至在嵌入式系统。</p> <p>WebAssembly设计来安全和便携的。就像JS。它会运行在任何支持wasm的环境中。（比如每一个浏览器）</p> <p>WebAssembly 具有同样的可移植性目标，就像JAVA早期使用Applets所尝试的那样。</p> <h2 id="哪些场景下使用webassembly比js好"><a href="#哪些场景下使用webassembly比js好" class="header-anchor">#</a> 哪些场景下使用WebAssembly比JS好？</h2> <p>在WebAssembly的第一个版本中，主要聚集于重CPU运算的场景。最主流的是游戏---他们有海量的纹理计算。你可用C++/rust写程序，绑定到你熟悉的OpenGL 上，然后编译成wasm。然后在浏览器中运行。</p> <p>另一个使用WebAssembly（高性能）场景是实现一些库，这些库承担了很重的CPU密集型工作。例如，图像操作</p> <p>前面提到，wasm可以减少一些移动设备的电池损耗，因为大多数处理步骤在编译前就已经被提前做好了。</p> <p>未来，你可以直接使用 WASM 二进制库即使你没有编写编译成它的代码。你可以在 NPM 上面找到一些开始使用这项技术的项目。</p> <p>针对操作 DOM 和频繁使用平台接口的情况 ，使用 JavaScript 会更加合理，因为它不会产生额外的性能开销且它原生支持各种接口。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/5.html" class="prev">
        5.WebSockets 和HTTP2的正确姿势
      </a></span> <span class="next"><a href="/feblog/howjswork/7.html">
        7.WebWorker和5个使用场景
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/36.faf60c12.js" defer></script>
  </body>
</html>
