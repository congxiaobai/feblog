<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/14.0d1b8841.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" aria-current="page" class="active sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>迄今为止，我们主要讨论的是JS语言的特性。</p> <p>但是当构建App时，代码是需要跟它所处的环境进行交互的。理解环境的原理和构成，能让你构建更好的app，也能为发布之后潜在的问题做好准备</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db465521c45f43fcb491f3f5f1b178a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>来看看浏览器环境的主要组成吧：</p> <ul><li><p><strong>用户接口</strong>: 包含地址栏，前进/返回的按钮，书签等等。基本上是你能在浏览器上看到的每一个部分，除了网页本身所在是窗口</p></li> <li><p><strong>浏览器具引擎</strong>: 处理用户接口和原先引擎之间的交互</p></li> <li><p><strong>渲染引擎</strong>: 渲染网页显示.渲染引擎解析了HTML和CSS文件，并把解析的内容显示到屏幕</p></li> <li><p><strong>网络</strong>:这里是网络调用（比如XHR请求），这些网络调用是基于跨平台的接口实现的</p></li> <li><p><strong>后台UI</strong>:用来绘制核心部件，比如沙箱和视窗。后台暴露了无平台声明的接口，底层是使用了操作系统的UI方法。</p></li> <li><p><strong>JS引擎</strong>:代码执行的地方，之前第5章讨论过。</p></li> <li><p><strong>数据持久化</strong>: 你的App或许需要在本地存储数据，支持的存储机制包括 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener noreferrer">localStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener noreferrer">indexDB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="noopener noreferrer">WebSQL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystem" target="_blank" rel="noopener noreferrer">FileSystem<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p></li></ul> <p>这一章，我们会研究一下渲染引擎，因为它是处理了HTML和CSS的解析和可视化，这些是大多数的 JavaScript 应用需要持续进行交互的方面。</p> <h2 id="渲染引擎总览"><a href="#渲染引擎总览" class="header-anchor">#</a> 渲染引擎总览</h2> <p>渲染引擎的主要责任是，在浏览器中显示请求的页面。
渲染引擎可以显示HTML，XML，图像。如果你使用了额外的插件，浏览器也可以显示其他类型的文档比如PDF。</p> <h2 id="渲染引擎"><a href="#渲染引擎" class="header-anchor">#</a> 渲染引擎</h2> <p>跟JS引擎类似，不同的浏览器使用了不同的渲染引擎。这里是一些流行的：</p> <ul><li><strong>Gecko</strong> — Firefox</li> <li><strong>WebKit</strong> — Safari</li> <li><strong>Blink</strong> — Chrome, Opera (from version 15 onwards)</li></ul> <h2 id="渲染流程"><a href="#渲染流程" class="header-anchor">#</a> 渲染流程</h2> <p>渲染引擎接受网络层传递请求文档的内容。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7ceb82f31964534a2ddb5ca164f641b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="构建dom树"><a href="#构建dom树" class="header-anchor">#</a> 构建DOM树</h2> <p>渲染引擎是第一步是解析HTML文档，然后转换被解析的元素到<strong>DOM 树</strong>真实的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 节点</p> <p>假如有文本要输入：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;theme.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt; Hello, &lt;span&gt; friend! &lt;/span&gt; &lt;/p&gt;
    &lt;div&gt; 
      &lt;img src=&quot;smiley.gif&quot; alt=&quot;Smiley face&quot; height=&quot;42&quot; width=&quot;42&quot;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>这个HTML的DOM树长这样：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de05791f8ad4bb780b2fec629777ffc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>每一个元素都是直接包含的所有元素的父节点。</p> <h2 id="构建cssom树"><a href="#构建cssom树" class="header-anchor">#</a> 构建CSSOM树</h2> <p>CSSOM 是<strong>CSS Object Model</strong>的简称。当浏览器构建页面DOM时，它在<code>head</code>区域遇到了一个<code>link</code> 标记指向外部<code>theme.css</code> 脚本。引擎猜测需要渲染页面的资源，它立刻发送一个请求。 假如<code>theme.css</code>文件长这样</p> <div class="language- extra-class"><pre class="language-text"><code>body { 
  font-size: 16px;
}

p { 
  font-weight: bold; 
}

span { 
  color: red; 
}

p span { 
  display: none; 
}

img { 
  float: right; 
}
</code></pre></div><p>和HTML一起，引擎需要转换CSS到CSSOM--这样可以和浏览器一起工作。CSSOM长这样：
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12efc924ec5d42dea00bbf3dfd8b1fa3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>为什么CSSOM是一个树结构？当计算一个节点在页面上的最终样式时，浏览器先按照节点的一般规则（例如，如果节点是body元素的子节点，那么会应用所有的body样式），然后通过页数的会泽来递归优化计算过的样式。</p> <p>看看我们给出的案例。<code>body</code>元素中<code>span</code>中包含的任意文本，尺寸都是16px，都是红色。这些样式是继承<code>body</code>元素的。如果<code>span</code>元素是<code>p</code>元素的子节点，那么它的内容是不会显示的，因为给他制定了更加明确的样式。（display:none）</p> <p>注意上面的树不是一个完全的CSSOM树，只是显示了我们在样式脚本中重写的。每一个浏览器都提供了一个默认的样式集，也就是<strong>用户代理样式</strong>---当我们什么都不写时，看到的样式就是它提供的。案例中的样式只是简单的重写了他们的默认样式。</p> <h2 id="构建渲染树"><a href="#构建渲染树" class="header-anchor">#</a> 构建渲染树</h2> <p>HTML 中的可视化指令和 CSSOM 树的样式数据结合起来创建渲染树。</p> <p>渲染树是一个可视化元素构建的树，按照它们将在平面上显示的顺序构建。它是HTML和对应的CSS的视觉表征。树的意义是让网页内容能在页面上按照正确的顺序绘制。
渲染树中每一个节点，在Webkit中都是一个渲染器或者渲染对象。</p> <p>上面提到的DOM和CSSOM树的渲染树是这样子的：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7802b6cf3d824a10939e85acab6ebf2a~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
为了构建渲染树，浏览器大概做了以下动作</p> <ul><li>从DOM树的根部开始，遍历每一个可视节点。一些节点是不可视的（比如，脚本标记，meta标记等等），因为他们无法在渲染树中映射，所以被忽略了。这些节点通过样式隐藏然后也会被忽略。比如以上例子中的 span 节点，因为为其显式设置了 <code>display: none</code> 的样式。</li> <li>对每一个可视的节点，浏览器找到合适的CSSOM规则，然后应用它们。</li> <li>释放出包含内容及其经过计算的样式的可见节点</li></ul> <p>你可以看一下RenderObject的源码: <a href="https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h" target="_blank" rel="noopener noreferrer">https://github.com/WebKit/webkit/blob/fde57e46b1f8d7dde4b2006aaf7ebe5a09a6984b/Source/WebCore/rendering/RenderObject.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>让我们看看这个类的核心元素</p> <div class="language- extra-class"><pre class="language-text"><code>class RenderObject : public CachedImageClient {
  // Repaint the entire object.  Called when, e.g., the color of a border changes, or when a border
  // style changes.
  
  Node* node() const { ... }
  
  RenderStyle* style;  // the computed style
  const RenderStyle&amp; style() const;
  
  ...
}
</code></pre></div><p>每一个渲染器表示一个矩形区域，通常是一个节点的CSS盒。它包含了几何信息，包含宽，高和位置。</p> <h2 id="渲染树的布局"><a href="#渲染树的布局" class="header-anchor">#</a> 渲染树的布局</h2> <p>当一个渲染器创建，添加到树中，它没有位置和尺寸信息。计算这些值得过程就是布局。</p> <p>HTML使用一个流布局的模型，大多时间它可以一次性计算几何信息。坐标系统是相对于根渲染器的。这里使用 Top 和 left 坐标。</p> <p>布局是一个递归的过程，它从根节点开始--对应于HTML文档的<code>&lt;html&gt;</code>元素。布局持续递归整个或者整个渲染器层级结构，为每个需要计算几何信息的渲染器计算其信息。</p> <p>根渲染器的位置是<code>0,0</code>，它的标注的大小就是浏览器视窗可见部分（也就是视口）的尺寸。</p> <p>启动布局程序，意味着给出每一个节点在屏幕上应该显示的具体位置。</p> <h2 id="绘制渲染树"><a href="#绘制渲染树" class="header-anchor">#</a> 绘制渲染树</h2> <p>在这个阶段，遍历渲染树，调用渲染器的<code>paint()</code>把内容现实到屏幕上。</p> <p>绘制是全局或者渐进式的（类似布局）</p> <ul><li><strong>全局</strong> —整个树被渲染.</li> <li><strong>渐进式</strong> — 只有一些渲染器改变，而不会影响整个树。渲染器让它所处的矩形区域失效，这引起了操作系统认为整个区域需要重绘，并生成一个<code>paint</code>事件。操作系统会很机智的把多个区域合并成一个。</li></ul> <p>理解绘制是渐进流程是很重要的。为了获取更好的UX，渲染引擎将会尽快显示内容到屏幕上。它不会等待所有的HTML解析之后去构建和布局渲染树。会优先解析和显示部分内容，与此同时持续处理从网络接收的剩下的内容项。</p> <h2 id="脚本和样式的处理顺序"><a href="#脚本和样式的处理顺序" class="header-anchor">#</a> 脚本和样式的处理顺序</h2> <p>当转换到一个<code>&lt;script&gt;</code>标签，脚本立刻被解析和执行。文档转换被暂停，直到脚本执行完。这意味这过程是<strong>同步</strong> <em>如果脚本是外部的，首先需要从网络中fetch（同步），在获取完成之前所有的解析都会停止</em>
HTML5增加了一个选项去比较脚本为异步的，这样就可以在另一个线程中解析和执行。</p> <h2 id="优化渲染性能"><a href="#优化渲染性能" class="header-anchor">#</a> 优化渲染性能</h2> <p>如果要优化你的APP，这里有5个主要的区域你可以关注一下：</p> <ol><li><strong>JavaScript</strong>  -前面我们讨论过如何优化JS，同时不阻塞UI。渲染时，我们需要思考JS代码和DOM元素交互的方式。JS会创建很多UI的改变，尤其在SPA中。</li> <li><strong>样式计算</strong> —这个过程，决定了你的元素会使用什么样的CSS规则。一旦规则定义了，他们会被应用和计算。</li> <li><strong>布局</strong> —一旦浏览器知道元素要用什么规则，就开始计算元素需要占用多少空间，以及在浏览器屏幕中的位置。网页布局模型规定了，一个元素可以影响其他的。比如，<code>&lt;body&gt;</code>的宽度可以影响它所有子节点的宽度。这就导致，布局就算是计算密集型的。绘制会在多层中完成。</li> <li><strong>绘制</strong> —这里是纹理被填充的地方。绘制文本，颜色，图像，边框，阴影等等，元素的每一个可视的部分。</li> <li><strong>合成</strong> — 由于页面部分是在多层中绘制的，他们需要有序的在屏幕上绘制，才能正确的渲染页面。这个很重要，尤其是重叠元素。</li></ol> <h2 id="优化js"><a href="#优化js" class="header-anchor">#</a> 优化JS</h2> <p>浏览器中JS经常视觉变化，尤其在SPA中。</p> <p>为了提升渲染，你可以做以下一些优化：</p> <ul><li>避免用<code>setTimeout</code>或者<code>setInterval</code> 进行视觉更新。他们将会在帧的任意时间调用<code>callback</code>，很可能在帧末尾。我们期望的是在帧开始时去触发视觉改动，这样不会丢帧。</li> <li>将长时间的JS运算放到WebWorker中，我们第三章讨论过。</li> <li>使用微任务处理跨帧的DOM改变。 这是为了预防当任务需要访问 DOM，而网络工作线程无法办到的情况的。这意味你需要拆分一个大任务到几个晓得任务中，然后根据不同的任务性质在 <code>requestAnimationFrame</code> , <code>setTimeout</code>, <code>setInterval</code> 中运行。</li></ul> <h2 id="优化css"><a href="#优化css" class="header-anchor">#</a> 优化CSS</h2> <p>增加或者删除元素，改变属性等等都会让浏览器重新计算样式，重新布局整个或者部分页面。</p> <p>优化渲染，可以这么做：</p> <ul><li>降低选择器的复杂性。复杂的选择器会占用超过50%的时间开计算元素样式，剩下的时间才用来构建样式。</li> <li>减少必须产生样式计算的元素的个数。本质上，直接更改少数元素的样式而不是使整个页面的样式失效。</li></ul> <h2 id="优化布局"><a href="#优化布局" class="header-anchor">#</a> 优化布局</h2> <p>对浏览器来说，布局重计算是非常重的。可以这样优化：</p> <ul><li>尽可能减少布局数。当样式改变时，浏览器都会去插件是否需要布局重新计算。改变一些几何信息比如宽，高，位置等都会需要布局，所以尽可能减少改变这些属性。</li> <li>使用<code>flexbox</code> 替代老的布局方式，它的性能更好。</li> <li>拒绝强制同步布局。需要谨记，当JS运行时，前一帧的所有旧布局值都是已知且可查询的。此时使用<code>box.offsetHeight</code>不会有问题，但是如果你在访问前就改变了box的样式（比如给元素动态添加了CSS类）。浏览器将首先应用新的样式，然后调用布局。这个就非常耗时耗资源，尽力避免这样做。</li></ul> <p><strong>优化绘制过程</strong></p> <p>这经常是最长时间运行的认为，所以尽量避免这么做。我们可以这样优化：</p> <ul><li>改变除了透明度和transfroms的其他任意属性，都会引起绘制。所以谨慎使用。</li> <li>如果触发了布局，也会触发绘制，因为改变几何信息会引起元素的视觉改变</li> <li>通过提升层和动画编排来减少绘制区域。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/10.html" class="prev">
        10.使用MutationObserver 跟踪 DOM 变化
      </a></span> <span class="next"><a href="/feblog/howjswork/12.html">
        12.网络层内部，以及性能，安全性的优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/14.0d1b8841.js" defer></script>
  </body>
</html>
