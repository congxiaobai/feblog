<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/31.3494180c.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" aria-current="page" class="active sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>本文阅读指数:3<br>
Deno出来一段时间了，之前了解的并不多。本文算是科普性质，提供了一些点，都是日常做技术选择关注的点。可以一读</p></blockquote> <h1 id="总览"><a href="#总览" class="header-anchor">#</a> 总览</h1> <p>Deno是一个JS和TS的安全运行时。这一章简单介绍一下Deno，跟Node的区别，解析一些机制比如模块，包，异步，TS，安全和工具。</p> <h1 id="deno起源"><a href="#deno起源" class="header-anchor">#</a> Deno起源</h1> <p>Ryan Dahl’s在2018年的JSConfEU中“10 Things I Regret About Node.js”中宣布了Deno。开发者看到自己的项目受众越来越多，被使用在各个地方，并从项目的失误中学习。正常的开发者会去提高或者重构源项目。但是Ryan Dahl更激进，他害怕破坏掉兼容性。</p> <p>但是Deno还是很年轻的，2020年5越才发布正是第一个版本。
对比一下Deno 和 Node</p> <h1 id="deno-vs-node-js"><a href="#deno-vs-node-js" class="header-anchor">#</a> Deno vs. Node.js</h1> <p>下面是主要的区别。稍后我们会深入到机制。但是目前还是从功能性和开发者体验上说</p> <p>#内置包管理 vs npm</p> <p>node需要Npm来做包管理。Deno则从GO和RUST中学习，使用URL进行包引用。</p> <h1 id="es-modules-vs-commonjs-modules"><a href="#es-modules-vs-commonjs-modules" class="header-anchor">#</a> ES modules vs. CommonJS modules</h1> <p>Node 使用CommonJS 规范:</p> <blockquote><p>const module = require(‘module-name’)</p></blockquote> <p>Deno 使用标准的 EcmaScript modules:</p> <blockquote><p>import module from ‘https://some-repo/module-name.ts'</p></blockquote> <p>注意Deno需要模块的全部名词，包括扩展名。</p> <h1 id="基于权限的访问-vs-全文访问"><a href="#基于权限的访问-vs-全文访问" class="header-anchor">#</a> 基于权限的访问 vs. 全文访问</h1> <p>Node可以全文访问环境，文件系统和网络。这是严重的安全漏洞。恶意的npm模块可以轻易访问这些资源。
Deno需要明确的权限，这样就能限制一些不好的行为。</p> <h1 id="内置ts编译器-vs-外部支持"><a href="#内置ts编译器-vs-外部支持" class="header-anchor">#</a> 内置TS编译器 vs. 外部支持</h1> <p>Node不能直接使用YS。你需要使用一些很重的工具链近期编译</p> <p>Deno则天生支持TS，使用起来更加流畅</p> <h1 id="promises-vs-回调"><a href="#promises-vs-回调" class="header-anchor">#</a> Promises vs. 回调</h1> <p>Node使用不阻塞的I/O，然后当I/O操作完成时，需要用回调来处理通知</p> <p>Deno则使用async/await 模式，隐藏了回调链的复杂性，然代码更干净。</p> <h1 id="异常死亡-vs-未捕获异常"><a href="#异常死亡-vs-未捕获异常" class="header-anchor">#</a> 异常死亡 vs. 未捕获异常</h1> <p>在Node中你可以写一个全局的句柄来处理所有未捕获的异常</p> <blockquote><p>process.on(‘uncaughtException’, function (err) {</p> <p>console.log(‘ignoring…’);</p> <p>})</p></blockquote> <p>在Deno时，如果有未捕获异常，程序就会死掉。这个决策很重要。
深入的看一下Deno的一些特性：</p> <h1 id="模块和包管理"><a href="#模块和包管理" class="header-anchor">#</a> 模块和包管理</h1> <p>Deno通过URL引入模块，这就不需要 <strong>package.json</strong> 和 <strong>node_modules</strong>。这就意味着，没有缓存了，你只用下载一次包和模块。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>import { assertEquals } from &quot;https://deno.land/std@0.93.0/testing/asserts.ts&quot;;
assertEquals(2 + 2, 5);
console.log('success!')
</code></pre></div><p>可以看到，因为2+2等于4，这个程序会出错。Deno也是这么认为的</p> <blockquote><p>$ deno run ./assert.ts</p> <p>error: Uncaught AssertionError: Values are not equal:</p> <p>[Diff] Actual / Expected</p> <ul><li>4</li></ul> <ul><li>5</li></ul> <p>throw new AssertionError(message);</p> <p>^</p> <p>at assertEquals (https://deno.land/std@0.93.0/testing/asserts.ts:219:9)</p> <p>at file:///Users/gigi.sayfan/git/deno_test/assert.ts:3:1</p></blockquote> <p>改一下</p> <div class="language- extra-class"><pre class="language-text"><code>import { assertEquals } from &quot;https://deno.land/std@0.93.0/testing/asserts.ts&quot;;
assertEquals(2 + 2, 4);
console.log('success!')
</code></pre></div><p>ow, it succeeds:</p> <blockquote><p>$ deno run ./assert.ts</p> <p>Check file:///Users/gigi.sayfan/git/deno_test/assert.ts</p> <p>success!</p></blockquote> <p>OK了。
看一下包和导入</p> <blockquote><p>import { assertEquals } from “https://deno.land/std@0.93.0/testing/asserts.ts&quot;;</p></blockquote> <p>这里通过URL导入了一个<strong>assertEquals</strong> symbol，这是在Deno标准库中做的事情。
注意URL中包含了版本信息，所以自然支持同一个包的不同版本。</p> <p>Deno维护了一个规划中的包列表<a href="https://deno.land/" target="_blank" rel="noopener noreferrer">https://deno.land<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  但你可以从任何url中导入包</p> <p>可以尝试着从GitHub的URL上导入一个包</p> <blockquote><p>import { assertEquals } from “https://raw.githubusercontent.com/denoland/deno_std/main/testing/asserts.ts&quot;</p></blockquote> <h1 id="异步支持"><a href="#异步支持" class="header-anchor">#</a> 异步支持</h1> <p>Deno的异步API会返回promise.这样你可以运行你的异步操作，然后await结果，而不用去处理一团乱麻的回调函数</p> <p>比如:</p> <div class="language- extra-class"><pre class="language-text"><code>const promise = Deno.run({cmd: ['deno', 'eval', 'console.log(2+3)']})
await promise.status()

/*

Output:
5

*/
</code></pre></div><p>我们使用 <strong>Deno.run()</strong> 运行了一个子进程。子进程是另一个Deno的实例，然后我们传递了表达式<strong>console.log(2+3)</strong> ，它会在控制台输出5</p> <p>对于运行时间比较长的任务，为了不阻塞当前线程，我们可以使用await <strong>promise.status()</strong></p> <h1 id="deno-和-ts"><a href="#deno-和-ts" class="header-anchor">#</a> Deno 和 TS</h1> <p>Deno内置了对TS的支持，这样你就不需要工具链来进行编译了。Deno自带了一个TS的编译器，并把转换后的TS模块放在缓存中。当TS文件改动时，会被重新编译一下，保持更新。
查看缓存位置，和已有的模块信息：</p> <blockquote><p>$ deno info</p> <p>DENO_DIR location: “/Users/gigi.sayfan/Library/Caches/deno”</p> <p>Remote modules cache: “/Users/gigi.sayfan/Library/Caches/deno/deps”</p> <p>Emitted modules cache: “/Users/gigi.sayfan/Library/Caches/deno/gen”</p> <p>Language server registries cache: “/Users/gigi.sayfan/Library/Caches/deno/registries”</p></blockquote> <h1 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h1> <p>Deno自下而上的保证安全，控制用户可以访问的权限。
网络，环境，文件系统默认是不可访问的资源。比如，我们尝试写一个文件：</p> <p>假如代码放在 <strong>write_file.ts</strong>中.</p> <div class="language- extra-class"><pre class="language-text"><code>Deno.writeTextFileSync('data.txt', 'some data')
</code></pre></div><p>运行一下:</p> <blockquote><p>$ deno run write_file.ts</p> <p>Check file:///Users/gigi.sayfan/git/deno_test/write_file.ts</p> <p>error: Uncaught PermissionDenied: Requires write access to “1.txt”, run again with the — allow-write flag</p> <p>Deno.writeTextFileSync(‘data.txt’, ‘some data’)</p> <p>^</p> <p>at unwrapOpResult (deno:core/core.js💯13)</p> <p>at Object.opSync (deno:core/core.js:114:12)</p> <p>at openSync (deno:runtime/js/40_files.js:32:22)</p> <p>at writeFileSync (deno:runtime/js/40_write_file.js:24:18)</p> <p>at Object.writeTextFileSync (deno:runtime/js/40_write_file.js:82:12)</p> <p>at file:///Users/gigi.sayfan/git/deno_test/write_file.ts:1:6</p></blockquote> <p>抛出一个权限错误，告诉我们需要增加一个flag值。然后我们重新运行一下：</p> <blockquote><p>$ deno run — allow-write write_file.ts</p> <p>Check file:///Users/gigi.sayfan/git/deno_test/write_file.ts</p> <p>$ cat data.txt</p> <p>some data</p></blockquote> <p>现在可以了。因此，要小心运行你的Deno代码。</p> <h1 id="工具"><a href="#工具" class="header-anchor">#</a> 工具</h1> <p>Deno很注重开发者体验，所以提供了很多工具。看看有哪些：</p> <h1 id="格式化"><a href="#格式化" class="header-anchor">#</a> 格式化</h1> <p>假如有文件 <strong>fmt-test.ts</strong>:</p> <div class="language- extra-class"><pre class="language-text"><code>function foo()
{
    console.log('foo here')
  const x    = 3
         console.log('x + 2 =', x+2)
}

foo()
</code></pre></div><p>它是TS的，但是代码写的很乱</p> <p>我们执行一个命令 <strong>deno fmt</strong>:</p> <blockquote><p>$ cat fmt_test.ts | deno fmt -</p></blockquote> <p>我们会得到:</p> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  console.log(&quot;foo here&quot;);
  const x = 3;
  console.log(&quot;x + 2 =&quot;, x + 2);
}

foo();
</code></pre></div><p>效果不错</p> <h1 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h1> <p>测试的重要性无容置疑，Deno不需要借用第三方的框架，只要使用自己的断言模块就可以。</p> <p>我们再文件<strong>test-test.ts</strong>中定义了一个函数<strong>is_palindrome()</strong> ，用来检查字符串是否回文，然后加一些测试。前两哥测试应该通过，而第三个应该失败。</p> <div class="language- extra-class"><pre class="language-text"><code>import { assert } from &quot;https://deno.land/std@0.95.0/testing/asserts.ts&quot;;

function is_palindrome(s: string) {
  const ss = s.replaceAll(' ', '')
  const a = ss.split('')
  return a.reverse().join('') == ss
} 

await Deno.test(&quot;Palindrome 1 - success&quot;, () =&gt; {
  assert(is_palindrome(&quot;tattarrattat&quot;));
})

await Deno.test(&quot;Palindrome 2 - success&quot;, () =&gt; {
  assert(is_palindrome(&quot;never odd or even&quot;));
})

await Deno.test(&quot;Palindrome 3 - fail&quot;, () =&gt; {
  assert(is_palindrome(&quot;this is not a palindrom&quot;), &quot;fail!&quot;)
})
</code></pre></div><p>运行 <strong>deno test</strong> 命令:</p> <blockquote><p>$ deno test test_test.ts</p> <p>Check file:///Users/gigi.sayfan/git/deno_test/$deno$test.ts</p> <p>running 3 tests</p> <p>test Palindrome 1 — success … ok (1ms)</p> <p>test Palindrome 2 — success … ok (1ms)</p> <p>test Palindrome 3 — fail … FAILED (2ms)</p> <p>failures:</p> <p>Palindrome 3 — fail</p> <p>AssertionError: fail!</p> <p>at assert (https://deno.land/std@0.95.0/testing/asserts.ts:178:11)</p> <p>at file:///Users/gigi.sayfan/git/deno_test/test_test.ts:19:3</p> <p>at asyncOpSanitizer (deno:runtime/js/40_testing.js:37:15)</p> <p>at resourceSanitizer (deno:runtime/js/40_testing.js:73:13)</p> <p>at Object.exitSanitizer [as fn] (deno:runtime/js/40_testing.js💯15)</p> <p>at TestRunner.[Symbol.asyncIterator] (deno:runtime/js/40_testing.js:272:24)</p> <p>at AsyncGenerator.next (<anonymous>)
at Object.runTests (deno:runtime/js/40_testing.js:347:22)</anonymous></p> <p>at async file:///Users/gigi.sayfan/git/deno_test/$deno$test.ts:3:1</p> <p>failures:</p> <p>Palindrome 3 — fail</p> <p>test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out (4ms)</p></blockquote> <h1 id="构建"><a href="#构建" class="header-anchor">#</a> 构建</h1> <p>构建可以让所有的包集成在一个bundle中。Deno提供了<strong>bundle</strong>命令。
假如<strong>foobar.ts</strong> 模块从 <strong>foo.ts</strong>中引入了 **foo()<strong>函数，从</strong>bar.ts.<strong>中引入了</strong>bar()**函数</p> <p><strong>foo.ts</strong>:</p> <div class="language- extra-class"><pre class="language-text"><code>export function foo() {
    console.log('foo')
}
</code></pre></div><p><strong>bar.ts</strong>:</p> <div class="language- extra-class"><pre class="language-text"><code>export function bar() {

 console.log('bar') 
}
</code></pre></div><p><strong>foobar.ts</strong>:</p> <div class="language- extra-class"><pre class="language-text"><code>import { foo } from &quot;./foo.ts&quot;
import { bar } from &quot;./bar.ts&quot;

foo()
bar()
</code></pre></div><p>Let’s bundle them all up into a single file:</p> <blockquote><p>$ deno bundle foobar.ts</p> <p>Bundle file:///Users/gigi.sayfan/git/deno_test/foobar.ts</p> <p>Check file:///Users/gigi.sayfan/git/deno_test/foobar.ts</p></blockquote> <p>Here is the result:</p> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
    console.log('foo');
}
function bar() {
    console.log('bar');
}
foo();
bar();
</code></pre></div><p>可以看到，import声明已经不见了，<strong>foo()</strong>  和 <strong>bar()</strong> 被直接嵌入到一个bundle文件中了。</p> <h1 id="调试"><a href="#调试" class="header-anchor">#</a> 调试</h1> <p>运行时使用 <strong>— inspect</strong> 或者**— inspect-brk** 标记，就可以使用Chrome DevTool来进行调试。个人推荐使用 JetBrains IDEs 和一些deno插件。
如果使用VSCode，就需要手动配置一下<strong>launch.json</strong></p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;Deno&quot;,
      &quot;type&quot;: &quot;pwa-node&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
      &quot;runtimeExecutable&quot;: &quot;deno&quot;,
      &quot;runtimeArgs&quot;: [&quot;run&quot;, &quot;--inspect-brk&quot;, &quot;-A&quot;, &quot;${file}&quot;],
      &quot;attachSimplePort&quot;: 9229
    }
  ]
}
</code></pre></div><h1 id="脚本安装"><a href="#脚本安装" class="header-anchor">#</a> 脚本安装</h1> <p>使用命令行经常会要传递很多额外的参数，不太方便。你可以使用 <strong>deno install</strong>来做一些启动脚本，把这个脚本放在你想放的位置，或者**$HOME/.deno/bin**
我们安装一个foobar</p> <blockquote><p>$ deno install foobar.ts</p> <p>✅ Successfully installed foobar</p> <p>/Users/gigi.sayfan/.deno/bin/foobar</p> <p>ℹ️ Add /Users/gigi.sayfan/.deno/bin to PATH</p> <p>export PATH=”/Users/gigi.sayfan/.deno/bin:$PATH”</p></blockquote> <p>我在PATH环境变量中增加了**$HOME/.deno/bin**。这样我可以在任意位置执行<strong>foobar</strong>，运行脚本</p> <blockquote><p>$ cd /tmp</p> <p>$ foobar</p> <p>foo</p> <p>bar</p></blockquote> <h1 id="deno-机制"><a href="#deno-机制" class="header-anchor">#</a> Deno 机制</h1> <p>Deno是基于Rust和TypeScript来实现的。主要的组件有这些：</p> <ul><li>deno</li> <li>deno_core</li> <li>tsc</li> <li>swc</li> <li>rusty_v8
[deno]创建了可执行的deno，我们与之交互。
[deno_core]创建JS运行时。Deno使用了 <a href="https://lib.rs/crates/tokio" target="_blank" rel="noopener noreferrer">Tokio<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来实现异步事件循环。
<a href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html#tsc-the-typescript-compiler" target="_blank" rel="noopener noreferrer">tsc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是一个TS的标准编译器。也用来做类型检查。
<a href="https://swc.rs/" target="_blank" rel="noopener noreferrer">swc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>用来加速Web编译，现在主要编译你的JS和TS代码。
[rustry_v8]则使用Rust与V8的C++ API绑定。</li></ul> <h1 id="综述"><a href="#综述" class="header-anchor">#</a> 综述</h1> <p>Deno很年轻，但是不可小觑。它基于Node的经验和教训来设计的。它的技术提升远远超过了Node,并且使用了更加现代的技术栈。最大的问题是它会不会在成为JS和TS的后台运行时。现在说还为时尚早，但是如果真的这样，我还是很期待的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/26.html" class="prev">
        26.多态的3种类型
      </a></span> <span class="next"><a href="/feblog/howjswork/29.html">
        29.JS设计模式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/31.3494180c.js" defer></script>
  </body>
</html>
