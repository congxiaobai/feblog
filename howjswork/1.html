<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>OverView | 葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/12.0cb13daa.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" aria-current="page" class="active sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="overview"><a href="#overview" class="header-anchor">#</a> OverView</h1> <p>无意中搜到一个系列博客 --[How JS Works ](<a href="https://blog.sessionstack.com/how-javascript-works/home" target="_blank" rel="noopener noreferrer">How JavaScript Works – SessionStack Blog<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>),作者是一个叫SessionStack（这个产品没太看懂是做啥的，大概是一种非侵入式的框架，能够监控前端应用的数据，行为，异常等便于你优化应用）的产品的创始人和员工。<br>
博客内容很好，分了两部分。<br>
第一部分有19章，是2017~2018年更新的。这部分已经被翻译成了中文。[详见](<a href="https://github.com/Troland/how-javascript-works" target="_blank" rel="noopener noreferrer">GitHub - Troland/how-javascript-works: Knowledge about how javascript works, event loop,service worker,etc.<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)<br>
第二部分有15章，是今年更新的。国内还没有翻译。</p> <h2 id="为什么要做整个系列"><a href="#为什么要做整个系列" class="header-anchor">#</a> 为什么要做整个系列</h2> <p>由于在学习一些小众的框架或者插件的时候，要阅读英文文档，要靠连蒙带猜来应付。<br>
外文文档也是技术宅写的，文笔也很难说流畅，再加上一些计算机术语，读起来也不那么轻松。<br>
因此，我打算自己先译一些文章，提升一下文档阅读能力。<br>
前19章，我会自己翻译+参考大佬们的中文翻译，增加一些注解和删减。<br>
后15章，将会独立翻译。</p> <blockquote><p>如果读者对运行时，调用栈没有概念，可能要先做一些功课。<br>
本章推荐指数：4（满分5）</p></blockquote> <p><strong>这是 JavaScript 工作原理的第一章。本章会对语言引擎，运行时，调用栈做一个概述。</strong></p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>红宝书对JS的定义是，JS = ES+DOM+BOM。<br>
这个定义指出了JS机制的范围，会包含JS引擎，HTML结构，CSS原理，ES等。</p> <p>我们从V8开始,几乎所有人都已经听说过 V8 引擎的概念，并且很多人知道 JavaScript 是单线程的或者说是使用回调队列的。</p> <p>本章会详细解释JS的这些概念和工作原理，了解这些细节，帮你跃入黄金段位，写出更流畅的代码。</p> <h2 id="javascript-引擎"><a href="#javascript-引擎" class="header-anchor">#</a> JavaScript 引擎</h2> <p>Chrome 浏览器有一个内核，叫chromium。<br>
chromium中有一个大型的模块，叫渲染引擎。<br>
渲染引擎的责任就是解析HTML，计算CSS，以及执行JS。<br>
其中执行JS的那一部分，就是V8引擎。</p> <p>V8 引擎有两个常见的宿主环境，一个是Node,一个就是基于chromium的浏览器比如Chrome.</p> <p>引擎包括两个主要组件：</p> <ul><li>动态内存管理 － 在这里分配内存</li> <li>调用栈－这里代码执行即是你的堆栈结构</li></ul> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04244f7e8fcf4d7e85e1df836201f5f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="运行时"><a href="#运行时" class="header-anchor">#</a> 运行时</h2> <p>几乎每个 JavaScript 开发者都使用过一些浏览器 API(比如 setTimeout),要知道这个API并不是引擎所提供的。</p> <p>那么它们从何而来？我们看一下图，这个图是浏览器的部分架构</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb21a7e0beb3478f9c26a6766b2d64d6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>可以看到，除了引擎但是实际上还有更多其它方面的东西。<br>
有被称为 Web API 的东西，这些 Web API 是由浏览器提供的，比如 DOM,AJAX,setTimeout 以及其它。<br>
以及流行的事件循环和回调队列。</p> <h2 id="调用栈"><a href="#调用栈" class="header-anchor">#</a> 调用栈</h2> <p>JavaScript 只是一个单线程的编程语言，这意味着它只有一个调用栈（[什么是调用栈](<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack" target="_blank" rel="noopener noreferrer">Call stack（调用栈） - 术语表 | MDN (mozilla.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)）。这样它只能一次做一件事情。</p> <p>调用栈是一种栈结构，里面会记录我们在程序中的大概位置。</p> <p>当执行进入一个函数，调用栈把它置于栈的顶部。
如果函数调用结束，则从栈顶部移除该函数。
举个栗子。查看如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function multiply(x, y) {
  return x * y;
}

function printSquare(x) {
  var s = multiply(x, x);
  console.log(s);
}

printSquare(5);
</code></pre></div><p>当引擎开始执行这段代码的时候<br>
首先调用栈会被清空<br>
之后，产生如下步骤：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80078b87fa5043ec89e204ae419b2e25~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>调用栈中的每个入口被称为StackFrame。</p> <p>这正是当浏览器抛出异常的时候，栈追踪是如何被构建的－当发生异常的时候,栈追踪就是调用栈的状态。<br>
如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  throw new Error('SessionStack will help you resolve crashes:)');
}

function bar() {
  foo();
}

function start() {
  bar();
}

start();
</code></pre></div><p>如果在 Chrome 中执行（假设代码在 foo.js 的文件中），将会产生如下的堆栈追踪：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1951edacb45d47929700352666441958~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>&quot;栈溢出&quot;－当栈的空间用完了，还在往上面添加函数执行时会发生这个。这种情况一般发生在有问题的递归或者死循环的时候。查看下如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  foo();
}

foo();
</code></pre></div><p>当引擎开始执行这段代码的时候，它开始调用 foo 函数。<br>
但是这个函数会递归调用其自身，而没有任何结束条件。所以在每步执行过程中，调用堆栈会反复地添加同样的函数。执行过程如下所示：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb87092970464f7ebaa4857fbaefa113~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>终于，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，浏览器就报错了，如下所示：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc68767733eb4120a3b405400b9e6847~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>单线程的好处是不用处理死锁，并发这种头疼的问题，但是也带来了一些困扰，如果当前的代码运行很慢，浏览器卡顿怎么办？</p> <h2 id="并发和事件循环"><a href="#并发和事件循环" class="header-anchor">#</a> 并发和事件循环</h2> <p>假如你想要在浏览器用 JavaScript 来执行一些复杂的图像转化。</p> <p>转换的函数会被放在调用栈上执行，此时，浏览器实际上不能做其它任何事－它被阻塞了。浏览器在执行JS的时候，是不能进行渲染的，也就是不能对UI进行更新。如果转换的函数执行太久，那么浏览器的页面就卡住了。</p> <p>一旦浏览器开始在调用栈中执行这种任务，浏览器将会在相当一段时间内停止交互。大多数浏览器会抛出一个错误，询问你是否关闭网页。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa83de6e19041b28a9cec3fc456f2d8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>那么，如何不阻塞 UI 且不让浏览器停止响应来执行运行缓慢的代码呢？使用异步回调。</p> <p>这将会在 『JavaScript 工作原理』
第二章：『在V8 引擎中如何写最佳代码的 5 条小技巧』中进行详细阐述。</p> <h2 id="单词表"><a href="#单词表" class="header-anchor">#</a> 单词表</h2> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>embedded devices</td> <td>嵌入式设备</td></tr> <tr><td>utilize</td> <td>利用</td></tr> <tr><td>ecosystem</td> <td>生态系统</td></tr> <tr><td>internals</td> <td>内在，内部</td></tr> <tr><td>allocation</td> <td>分配（一般是内存分配）</td></tr> <tr><td>recursion</td> <td>递归</td></tr> <tr><td>scenarios</td> <td>场景</td></tr> <tr><td>concurrency</td> <td>并发</td></tr></tbody></table></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/feblog/howjswork/2.html">
        2.V8 引擎中书写最优代码的 5 条小技巧
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/12.0cb13daa.js" defer></script>
  </body>
</html>
