<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/29.3b89a9ef.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" aria-current="page" class="active sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>本文阅读指数:3<br>
函数式编程随有一定的市场，但是目前来看也是说得多做得少。本文帮助你理解一些函数式编程的基本概念。</p></blockquote> <h1 id="概述"><a href="#概述" class="header-anchor">#</a> <strong>概述</strong></h1> <p>函数式编程，简单来说就是一个函数，入参是数据，出参是函数。</p> <p>函数式编程最美妙的地方，是它不会改变我们的入参，也不会产生任何的副作用。状态值是通过函数来表达的。</p> <p>这一章我们会讨论函数式编程在JS中是如何工作的，以及相关的一些重要概念。</p> <h1 id="面向对象的js"><a href="#面向对象的js" class="header-anchor">#</a> <strong>面向对象的JS</strong></h1> <p>首先，我们知道JS是基于原型的语言，不是基于类的语言，这种模型经常让开发者困惑。基于类的语言，比如JAVA ,C#的等，主要有两个概念：类和实例。类定义了对象所有的属性，而实例就是将类实例化了。</p> <p>JS的面向对象风格，只是看起来像，但实际上并不是。表面上看你用的是类语法，但是实际上还是原型</p> <p>比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let Person = class {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  speak() {
    return `Hello, my name is  ${this.name} and I am ${this.age}`
  }
}
</code></pre></div><p>注意Person类构造函数有两个参数。关键字<strong>this</strong>指向我们的原型，Person。
我们的方法<strong>speak()</strong> 可以这么使用：</p> <div class="language- extra-class"><pre class="language-text"><code>let victor = new Person('Victor', 23);
console.log(victor.speak());
</code></pre></div><p><strong>new Person</strong>会调用构造函数，传入的参数就会被设置到<strong>victor</strong> 对象。
<strong>speak()</strong> 函数会被添加到构造函数的原型上。</p> <p>我们也可以在Person类之外创建一个新类，扩展它里面的属性和方法</p> <div class="language- extra-class"><pre class="language-text"><code>let Work = class extends Person {
  constructor(name, age, work) {
    super(name, age);
    this.work = work
  }
  
  getInfo() {
    return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.`
  }
}

let alex = new Work('Alex', 30, 'SessionStack');
console.log(alex.getInfo());
</code></pre></div><p>我们创建了一个类，继承自Person，并且定义了更多的属性。在基于类的语言中，它被称为子类。</p> <p>如果使用旧版本的JS该怎么做呢？记住，JS中的类语法实际依然是基于原型的。我们看看发生了什么：</p> <div class="language- extra-class"><pre class="language-text"><code>let Person = function(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.speak = function() {
  return `Hello, my name is  ${this.name} and I am ${this.age}`
}

let victor = new Person(`Victor`, 23)
console.log(victor.speak())
</code></pre></div><p>上面的代码，我们调用了<strong>Person()</strong> 函数，注意前面还有个关键字<strong>new</strong>。new 改变了函数的上下文，所以它被称为构造器。它生成了一个<strong>Person</strong> 对象的实例，并赋值给<strong>victor</strong>。
像上面那样实现对Person的继承，我们可以这么做：</p> <div class="language- extra-class"><pre class="language-text"><code>let Work = function(name, age, work) {
  Person.call(this, name, age);
  this.work = work;
}
</code></pre></div><p>注意我们没有使用 <strong>super()</strong> 关键字，因为JS中是不存在的。<strong>call()</strong> 接受了<strong>this</strong>和其他参数，然后把Person的属性再添加到Workshang 。.call()方法，连接了Person的构造器和Work类。换句话说，我们从<strong>Person</strong> 中借走了属性，并且添加到<strong>Work</strong>中。</p> <p>在原型中，也没有<strong>extend</strong>这样的语法。但是可以这么连接Work 和 Person</p> <div class="language- extra-class"><pre class="language-text"><code>Object.setPropertyOf(Work.prototype, Person.prototype);
</code></pre></div><p>这样Work就可以使用Person的属性了。给work添加方法的话可以这么做：</p> <div class="language- extra-class"><pre class="language-text"><code>Work.prototype.getInfo = function() {
       return `Hey! It's ${this.name}, I am age ${this.age} and work for ${this.work}.`
}

let alex = new Work(&quot;Alex&quot;, 40, 'SessionStack');
console.log(alex.getInfo());
</code></pre></div><p>我们需要知道JS是基于原型实现的对象型语言，我们在ES6中使用class 语法，只是一个语法糖。</p> <p>有了上面的基础，现在来看看JS中的函数式编程：</p> <h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="header-anchor">#</a> <strong>什么是函数式编程</strong></h1> <p>在JS中使用函数式编程会容易一点，但是不是对所有开发者都适用。因为JS本身是一个基于原型的语言，它里面的'运行继承’, ‘this’, ‘setPropertyOf’ 已经很让人迷惑了。</p> <p>不过，跟使用错误的‘this’  banding相比，  JS中的函数式方式会让事情变得简单一点，也更好维护一点。
使用函数式编程的社区成员还是很多的，在你遇到问题的时候，求助StackOverflow会得到很多帮助。</p> <p>看一个简单的函数式代码：</p> <div class="language- extra-class"><pre class="language-text"><code>const sayHello = function(name) {
  return `Hello ${name}`;
}

sayHello('Victor');

# =&gt; Hello Victor
</code></pre></div><p>我们声明一个函数，有一个参数 <strong>name</strong>。非常的简单明了。</p> <p>但是函数式编程会复杂一点，我们要先理解一些概念：纯函数，高阶函数，不可变性，头等函数等等，</p> <h1 id="js中函数式编程概念"><a href="#js中函数式编程概念" class="header-anchor">#</a> <strong>JS中函数式编程概念</strong></h1> <h2 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> <strong>纯函数</strong></h2> <p>函数式编程的一个主要目标使用纯函数，避免副作用。无副作用的意思就是你的函数逻辑只能跟传入参数有关。我们先看一个有副作用的非纯函数，</p> <div class="language- extra-class"><pre class="language-text"><code>let surname = 'Jonah';

const sayHi = function() {
  return `Hi ${surname}`;
}
</code></pre></div><p>上面的代码中，没有输入参数，但是却使用了一个函数之外的全局变量。这就可能引起副作用。</p> <p>将其改造为纯函数：</p> <div class="language- extra-class"><pre class="language-text"><code>const sayHi = function(surname) {
  return `Hi ${surname}`;
}
</code></pre></div><p>现在函数只关心输入参数，并处理了它。这就是纯函数。
这就是函数式编程最重要的概念。
除此之外还有一些小概念要知道</p> <h2 id="高阶函数"><a href="#高阶函数" class="header-anchor">#</a> <strong>高阶函数</strong></h2> <p>高阶函数也是函数，它的入参是函数，出参还是函数，要记住函数也是值，可以被传递来传递去的。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>const getSum = function(num) {
  return num + num;
}

getSum(9);
</code></pre></div><p>我们创建了一个函数，并赋值给<strong>getSum</strong>, 我们还可以把它传递给另一个变量，比如:</p> <div class="language- extra-class"><pre class="language-text"><code>const addNum = getSum;

addNum(9);
</code></pre></div><p>可以看到，函数可以被当做变量那样传递。因此，也可以被当成是参数传递给<strong>高阶函数</strong>。</p> <p>我们可以持续传递函数到另一个函数中，让我们把很多小函数组合成一个大函数。这被称为<strong>组合</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>function a(x) {
  return x * 2;
}

function b(x) {
  return x + 1;
}

function c(x) {
  return x * 3;
}

const d = c(b(a(2)));
console.log(d) // 15
</code></pre></div><p>我们可以传递每一个函数返回值到下一个函数中。
这也是我们使用高阶函数的原因，因为它使用组合，让我们的代码更干净</p> <p>一个比较常用的高阶函数例子是<strong>filter()</strong> 方法。filter()需要传进一个函数，然后返回一个新的数组。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>function isLarge(value) {
  return value &gt; 10;
}

const dataArray = [10, 11, 12, 3, 4];


const filteredArray = dataArray.filter(isLarge);
console.log(filteredArray); // [11, 12]
</code></pre></div><p>回调函数必须返回一个布尔值，如果返回值是true，当前遍历的值就会被加入到新数组中，
类似的例子还有 map() 和 reduce() 方法。在开始下一节之前，先看看map()的方法：</p> <div class="language- extra-class"><pre class="language-text"><code>function squareRoot(value) {
  return Math.sqrt(value)
}

const dataArray = [4, 9, 16];


const mappedArray = dataArray.map(squareRoot);
console.log(mappedArray); // [2, 3, 4]
</code></pre></div><h2 id="不可变性"><a href="#不可变性" class="header-anchor">#</a> <strong>不可变性</strong></h2> <p>函数式编程的另一个重要概述是拒绝异变。异变是指对状态和数据的改变。不可变是指原来的数据不能变，当发生变更时，需要设置一个新的对象。看一个具有异变性的代码：</p> <div class="language- extra-class"><pre class="language-text"><code>let data = [1, 2, 3, 4, 4];

data[4] = 5;

console.log(data); // [1, 2, 3, 4, 5]
</code></pre></div><p>注意我们把1, 2, 3, 4, 4 改变成了1, 2, 3, 4, 5。这段代码可能引起一些Bug。假设这个数组在某处被使用，但是它其实已经改变了。那么JS中怎么处理不可变性？</p> <div class="language- extra-class"><pre class="language-text"><code>const names = [&quot;Alex&quot;, &quot;Victor&quot;, &quot;John&quot;, &quot;Linda&quot;]

const newNamesArray = names.slice(1, 3) // [&quot;Victor&quot;, &quot;John&quot;]
</code></pre></div><p>源数组<strong>names</strong> 没有改变，然后生成了一段新数据。</p> <p>使用<strong>Object.freeze()</strong> 可以让对象也不可变。这个方法冻结了对象，不允许该对象属性的增加和删除。</p> <p>例如:</p> <div class="language- extra-class"><pre class="language-text"><code>const employee = {
  name: &quot;Victor&quot;,
  designation: &quot;Writer&quot;,
  address: {
    city: &quot;Lagos&quot;
  }
};

Object.freeze(employee);

employee.name = &quot;Max&quot;
//Outputs: Cannot assign to read-only property 'name'

//Checks if our object is immutable or not
Object.isFrozen(employee); // === true
</code></pre></div><p>这里，我们的对象就不可变了，并且不能与之交互。
这里也有一个问题，就是我们如果要改动数组就不得不一遍又一遍的弃用旧数组。如果数组中有成千上万的数据，那么带来的内存消耗和问题会很大。好在现在已经有一些库来帮我们处理这些问题，不如 <a href="https://immutable-js.github.io/immutable-js/" target="_blank" rel="noopener noreferrer">immutable.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://swannodette.github.io/mori/#immutability" target="_blank" rel="noopener noreferrer">Mori<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>有了这些概念，我们已经知道JS 函数式编程的概念和优点了。可以看到我们的代码更易读了，</p> <h2 id="声明式和命令式"><a href="#声明式和命令式" class="header-anchor">#</a> <strong>声明式和命令式</strong></h2> <p>实现函数式编程，有两种途径：声明式和命令式。命令式是声明你要做的每一步。比如，如果你想做包子，那么命令式会是这样</p> <ul><li>和面</li> <li>剁馅儿</li> <li>包包子</li> <li>蒸熟</li></ul> <p>而声明式只是说出来你想做的。例如，你想做包子，仅此而已，我们不需要去描述每一步。
不过这些只是简单的描述，告诉你两者的区别。</p> <h2 id="命令式"><a href="#命令式" class="header-anchor">#</a> <strong>命令式:</strong></h2> <p>这里我们会直接告诉计算机我们做什么事情</p> <div class="language- extra-class"><pre class="language-text"><code>// Function to filter an array; return greater than 5 numbers

const filterArray = (array) =&gt; {
  let filteredArray = [];
  for(let i = 0; i &lt; array.length; i++) {
    if(array[i] &gt; 5) {
      filteredArray.push(array[i]);
     }
  }
  return filteredArray;
}

const array = [1, 2, 3, 4, 5, 6, 7, 8]
filterArray(array)
</code></pre></div><p>我们没有告诉计算机我们想要什么，只是告诉了我们每一步要做的事情。
我们的步骤包括：</p> <ul><li>声明一个空数组</li> <li>迭代给定数组</li> <li>如果当前项大于5</li> <li>如果大于5，就把匹配的项加入到之前声明的空数组中</li> <li>显示我们的新数组</li></ul> <h2 id="声明式"><a href="#声明式" class="header-anchor">#</a> <strong>声明式:</strong></h2> <div class="language- extra-class"><pre class="language-text"><code>// Filter method to give us a new array

const filterArray = array =&gt; array.filter(x =&gt; x &gt; 5);

const array = [1, 2, 3, 4, 5, 6, 7, 8];

console.log(filterArray(array)); // [6, 7, 8]
</code></pre></div><p>声明式就很简单，我们声明了一个函数，然后让它去做我们想让它做的。</p> <h2 id="为什么大多数人推荐函数式编程"><a href="#为什么大多数人推荐函数式编程" class="header-anchor">#</a> <strong>为什么大多数人推荐函数式编程</strong></h2> <p>开发者选择使用函数式编程，有一些共同原因。同时刚学习函数式编程可能会踩坑，但是一旦你彻底理解了整个概念，就会变得很容易。
这里是一些主要原因：</p> <ul><li>让代码更加模块化；一个函数可以跟另一个完全不相干的函数合并。由于函数是可组合的，就像React组件那样，可以做到很好的复用。</li> <li>调试更容易了：更少的Bug，更好的维护性。高阶函数易于调试，且代码量少，我们的代码就会更安全。</li> <li>开发者更容易读懂你的代码。因为你是按照人类的思维来写的代码，而不是过程性的。</li> <li>在函数式编程中，开发者倾向于写更加干净快速的代码。而不是迭代代码，像for循环那样。</li></ul> <h1 id="结论"><a href="#结论" class="header-anchor">#</a> <strong>结论</strong></h1> <p>在这一章，我们总览了以下面向对象的JS工作方式，class语法和传统的基于原型的区别。</p> <p>介绍了一些函数式编程的概念，帮助你理解使用函数式编程的原因。</p> <p>没有更好或者更坏的编程模式。这个章节只是帮助你理解函数式编程的概念。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/24.html" class="prev">
        24.加密和中间人（MITM）攻击
      </a></span> <span class="next"><a href="/feblog/howjswork/26.html">
        26.多态的3种类型
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/29.3b89a9ef.js" defer></script>
  </body>
</html>
