<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/28.6a8a79bd.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" aria-current="page" class="active sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>密码学是IT界的重要领域。无数人在网络上互相交流，在信息传递的过程中就可能有人窃取或者劫持，可能有人利用网络弱点窃取个人信息。</p></blockquote> <p>人们如何安全发送信息，以及JS扮演了什么角色？如果你不知道答案，那么这一章就很适合你。
在这一章，我们将会知道什么是密码学，以及在JS中如何工作，以及如何处理中间人攻击。</p> <h1 id="什么是加密"><a href="#什么是加密" class="header-anchor">#</a> 什么是加密</h1> <p>加密是处理安全信息和交流的过程，这样只有发送者和目标接受者才能访问它们。加密有多种技术方式。这些即使包含加密和解密，使用不同的算法来哈希通信过程，签名和验证。</p> <p>由于很多人使用JS构建的应用来进行通信的，所以有必要理解JS是怎么加密的。下一节。我们会看看JSWEB的加密API以及如何加密的。</p> <h1 id="js-web-的加密api"><a href="#js-web-的加密api" class="header-anchor">#</a> JS Web 的加密API</h1> <p>由于确保网络通信是很重要的，一些web浏览器已经实现了<a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto" target="_blank" rel="noopener noreferrer">crypto<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>接口。
但是这个接口不能很好的定义或者加密声音信息。JS web 加密API提供了一个更好的接口
<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto" target="_blank" rel="noopener noreferrer">SubtleCrypto<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><code>SubtleCrypto</code>.</p> <p>JS web加密API允许开发者在应用中使用基本的加密方法而不需要第三方的库。你可以签名文档，执行认证，对整个通信进行校验。</p> <p>比如，你可以这样获得一个加密的数组：</p> <div class="language- extra-class"><pre class="language-text"><code>const secure = window.crypto.getRandomValues(new Uint8Array(10));
console.log(secure);
</code></pre></div><p>在控制台执行这段代码，能看到10个随机生成的数字</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c36942361504ee8b61471ede8bb0335~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
下面就看看加密API是如何工作的，以及我们的控制台是怎么做到的。</p> <p>合理使用加密API，服务器就无法看到数据，只有发送者和接受者可以访问到。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0ea2cdeeed847909e838204d5a1ba96~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>从上图中可以看到，发送者使用了API进行加密，接受者对数据进行解密。而服务器和数据库不能加密也不能和解密。
你可以执行很多加密操作，比哈希，签名，认证等等，我们后面会讨论</p> <h1 id="基础的加密方式"><a href="#基础的加密方式" class="header-anchor">#</a> 基础的加密方式</h1> <h2 id="encrypting"><a href="#encrypting" class="header-anchor">#</a> Encrypting</h2> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be34a9bda588484f93ac7c7230fbf703~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>JS的API <code>encrypt</code> 方法就是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>//Syntax for encrypt function
const result = crypto.subtle.encrypt(algorithm, key, data);
</code></pre></div><p>这个加密方法会返回一个<code>Promise</code>，内部是包含密电码的<code>ArrayBuffer</code> 。在加密时如果发生了异常，就会返回一个新的Promise rejected，内部是一个 序列化算法的结果。
举个例子，我们加密一个纯文本，使用<code>AES-GCM</code>密钥和算法。把代码复制到你的控制台，看一下输出的密电码。</p> <div class="language- extra-class"><pre class="language-text"><code>/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because 
encrypt method must return a Promise that fulfills with an ArrayBuffer containing the &quot;ciphertext&quot;*/
function strToArrayBuffer(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i = 0, strLen = str.length; i &lt; strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintext
function arrayBufferToString(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}
//This object below will generate our algorithm key
var algoKeyGen = {
  name: &quot;AES-GCM&quot;,
  length: 256,
};
//This will generate random values of 8-bit unsigned integer
var iv = window.crypto.getRandomValues(new Uint8Array(12));
//This object will generate our encryption algorithm
var algoEncrypt = {
  name: &quot;AES-GCM&quot;,
  iv: iv,
  tagLength: 128,
};
//states that key usage is for encryption
var keyUsages = [&quot;encrypt&quot;];
var plainText = &quot;This is a secure message from Mary&quot;;
var secretKey;
//This generates our secret Key with key generation algorithm
window.crypto.subtle
  .generateKey(algoKeyGen, false, keyUsages)
  .then(function (key) {
    secretKey = key;
  //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer
    return window.crypto.subtle.encrypt(
      algoEncrypt,
      key,
      strToArrayBuffer(plainText)
    );
  })
  .then(function (cipherText) {
  //print out Ciphertext in console
    console.log(&quot;Cipher Text: &quot; + arrayBufferToString(cipherText));
  })
  .catch(function (err) {
    console.log(&quot;Error: &quot; + err.message);
  });
</code></pre></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b6b484e4cc4642b48f8c63941aeffb~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
看代码</p> <div class="language- extra-class"><pre class="language-text"><code>var algoKeyGen = { name: ‘AES-GCM’, length: 256};
</code></pre></div><p>这里声明了密钥</p> <div class="language- extra-class"><pre class="language-text"><code>var algoEncrypt = { name: ‘AES-GCM’, iv: iv, tagLength: 128};
</code></pre></div><p>这里声明了加密算法</p> <h1 id="decrypting"><a href="#decrypting" class="header-anchor">#</a> Decrypting</h1> <p>Decrypting是跟加密相反，把密电码转换为纯文本。这时候就需要认证用户提供一个密钥。</p> <p><code>decrypt</code> 方法可以来解密，它的语法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const result = crypto.subtle.decrypt(algorithm, key, data);
</code></pre></div><p>上面例子的解密过程如下：</p> <div class="language- extra-class"><pre class="language-text"><code>//This states that the keyusage for decrypting
var keyUsages = [&quot;decrypt&quot;];
//This object below is for algorithm key generation
var algoKeyGen = {
  name: &quot;AES-GCM&quot;,
  length: 256,
};
var plainText = &quot;This is a secure message from Mary&quot;;
var secretKey;
//This will generate secrete key with algorithm key and keyusage
window.crypto.subtle
  .generateKey(algoKeyGen, false, keyUsages)
  .then(function (key) {
    secretKey = key;
    //This will decrypt Cipheretext to plaintext
    return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText);
  })
  //  Print plaintext in console.
  .then(function (plainText) {
    console.log(&quot;Plain Text: &quot; + arrayBufferToString(plainText));
  })
  .catch(function (err) {
    console.log(&quot;Error: &quot; + err.message);
  });
</code></pre></div><p>完整的加密解密代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// This code below will encrypt and decrypt plaintext

/*The function strToArrayBuffer converts string to fixed-length raw binary data buffer because 
encrypt method must return a Promise that fulfills with an ArrayBuffer containing the &quot;ciphertext&quot;*/
function strToArrayBuffer(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i = 0, strLen = str.length; i &lt; strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
//The function arrayBufferToString converts fixed-length raw binary data buffer to 16-bit unsigned String as our plaintext
function arrayBufferToString(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}
//This object below will generate our algorithm key
var algoKeyGen = {
  name: &quot;AES-GCM&quot;,
  length: 256,
};
//This will generate random values of 8-bit unsigned integer
var iv = window.crypto.getRandomValues(new Uint8Array(12));
//This object will generate our encryption algorithm
var algoEncrypt = {
  name: &quot;AES-GCM&quot;,
  iv: iv,
  tagLength: 128,
};
//states that key usage is for encrypting and decrypting
var keyUsages = [&quot;encrypt&quot;, &quot;decrypt&quot;];
var plainText = &quot;This is a secure message from Mary&quot;;
var secretKey;
//This generates our secret Key with key generation algorithm
window.crypto.subtle
  .generateKey(algoKeyGen, false, keyUsages)
  .then(function (key) {
    secretKey = key;
  //Encrypt plaintext with key and algorithm converting the plaintext to ArrayBuffer
    return window.crypto.subtle.encrypt(
      algoEncrypt,
      key,
      strToArrayBuffer(plainText)
    );
  })
  .then(function (cipherText) {
  //This prints out the ciphertext, converting it from ArrayBuffer to 16-bit unsigned String
    console.log(&quot;Cipher Text: &quot; + arrayBufferToString(cipherText));
  //This will decrypt ciphertext with secret key and algorithm
    return window.crypto.subtle.decrypt(algoEncrypt, secretKey, cipherText);
  })
//This prints out the plaintext, converting it from ArrayBuffer to 16-bit unsigned String
  .then(function (plainText) {
    console.log(&quot;Plain Text: &quot; + arrayBufferToString(plainText));
  })
  .catch(function (err) {
    console.log(&quot;Error: &quot; + err.message);
  });
</code></pre></div><p>运行这段代码，将会看到之前加密的纯文本
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/431f906c3a534767b4011edbb99693ec~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
看代码</p> <div class="language- extra-class"><pre class="language-text"><code>var secretKey;

 window.crypto.subtle.generateKey(algoKeyGen, false, keyUsages) 
.then(function (key) { secretKey = key;
</code></pre></div><p>这里生成可以密钥来加密信息</p> <p>加密过程可以宽泛的分为对称和非对称加密。这取决于加密使用的密钥类型。对称机密的话，加密和解密使用相同的密钥。非对称则相反，加密和解密采用不同的密钥。加密使用认证用户之间共享的公钥，接受者使用私钥来解密。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a40f27a4d84f3d932090e8432f4f5c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="hashing"><a href="#hashing" class="header-anchor">#</a> Hashing</h1> <p>哈希是一个加密方法，可以把任意长度的数据映射成固定尺寸的数组。加密哈希函数，把纯文本数据转换成一个由数组和字母组成的唯一的字符串。哈希不同于上面说的加密，但是单向的。也就是说，你就可以加密，但是基本不可能把哈希后的数据转换为源文本</p> <p>哈希只能加密不能解析，所以主要用来进行认证。比如，注册或登录。当用户注册是，密码在存进数据库之前先哈希。当用户登录时，登录密码被哈希，然后跟数据库中的数据再对比确保匹配。这样，即使黑客攻入了数据库，获得了用户的账户信息，它还是无法解码出源密码。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3388d60df2a04830ba70e27fe47c4740~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>JS可以调用<code>crypto.subtle.digest</code> 来进行哈希。你可以使用<code>SHA-1</code>, <code>SHA-384</code> 和<code>SHA-512</code>几种方式来哈希：</p> <div class="language- extra-class"><pre class="language-text"><code>const digest = crypto.subtle.digest(algorithm, data);
</code></pre></div><p>看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>const text = &quot;This is a secure message from Mary&quot;;
async function digestMessage(message) {
  const encode = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
  const hashBuffer = await crypto.subtle.digest(&quot;SHA-256&quot;, encode); // hash the message
  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
  const hashHex = hashArray
    .map((b) =&gt; b.toString(16).padStart(2, &quot;0&quot;))
    .join(&quot;&quot;); // convert bytes to hex string
  return hashHex;
}
const digestHex = await digestMessage(text);
console.log(digestHex);
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6afb8c5dc45e4c80b16588c44af2df80~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>在这个例子中，我们使用了<code>SHA-256</code> 算法来加密文本<strong>This is a secure message from Mary</strong> ，将其转换为十六进制的字符串。在生产环境中，不推荐使用<code>SHA-1</code>算法，因为它比较弱。</p> <h2 id="生成签名和验证"><a href="#生成签名和验证" class="header-anchor">#</a> 生成签名和验证</h2> <p>这是另一种加密方式。使用<code>sign</code> 和 <code>verify</code>函数，你可以用一个密钥给文档加密。接受者使用他们的密钥去验证文档。
签名和验证的语法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>//syntax to sign document
const signature = crypto.subtle.sign(algorithm, key, data);
//syntax to generate document
const result = crypto.subtle.verify(algorithm, key, signature, data);
</code></pre></div><h1 id="加密算法"><a href="#加密算法" class="header-anchor">#</a> 加密算法</h1> <p>加密有很多种不同的SHA算法，每一个都声明了哈希值的bit位长度 。这一节，我们会看看JS支持的加密函数。</p> <h2 id="ecdh-elliptic-curve-diffie-hellman"><a href="#ecdh-elliptic-curve-diffie-hellman" class="header-anchor">#</a> ECDH (Elliptic Curve Diffie-Hellman)</h2> <p>这个加密算法，用来生成和协商密钥。ECDH密钥协商协议，允许通信双方持有一个私有-公有的密钥对来保护通信。</p> <p>这个算法允许你做这些事情</p> <ul><li>生成密钥</li> <li>Bits Derivation</li> <li>导入密钥</li> <li>到处密钥</li></ul> <h2 id="sha-secure-hash-algorithm"><a href="#sha-secure-hash-algorithm" class="header-anchor">#</a> SHA (Secure Hash Algorithm)</h2> <p>这个算法大多是哈希的时候使用。它将任意数据压缩成定长的比特字符串。JS API允许你使用crypto.subtle.digest ，它支持 <code>SHA-1</code> 和 <code>SHA-2</code>，也支持&quot;SHA-256”, “SHA-384”, “SHA-512”</p> <h2 id="hmac-hash-based-message-authentication-code"><a href="#hmac-hash-based-message-authentication-code" class="header-anchor">#</a> HMAC (Hash-based Message Authentication Code)</h2> <p>使用哈希函数哈希之后，需要验证输入的信息是否跟这个哈希值相同。记住，我们无法把哈希值转换成源文本。为了对比值，<code>HMAC</code>算法可以用来签名和认证文档。你可以用这个算法做这个：</p> <ul><li>签名</li> <li>验证</li> <li>生成密钥</li> <li>导入密钥</li> <li>导出密钥</li> <li>获取密钥长度</li></ul> <h2 id="hkdf-hash-based-key-derivation-function"><a href="#hkdf-hash-based-key-derivation-function" class="header-anchor">#</a> HKDF (Hash-based Key Derivation Function)</h2> <p>HKDF是一个基于HMAC的加密派生方法。它使用了extraction-then-expansion（先提取后扩充） 方式来实现。使用这个算法，可以把公钥转换成密钥，用来加密，验证或者认证。你可以用这个算法做这些事情：</p> <ul><li>Bits Derivation</li> <li>导入密钥</li> <li>获取密钥长度</li></ul> <h2 id="ecdsa-elliptic-curve-digital-signature-algorithm"><a href="#ecdsa-elliptic-curve-digital-signature-algorithm" class="header-anchor">#</a> ECDSA (Elliptic Curve Digital Signature Algorithm)</h2> <p>ECDSA允许用户签名和认证文档，使用<a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener noreferrer"> elliptic curve cryptography<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。你可以用这个算法做这些事情：</p> <ul><li>签名</li> <li>验证</li> <li>生成密钥</li> <li>导入密钥</li> <li>导出密钥</li></ul> <h2 id="rsa-rivest-shamir-adleman-algorithm"><a href="#rsa-rivest-shamir-adleman-algorithm" class="header-anchor">#</a> RSA (Rivest–Shamir–Adleman) Algorithm</h2> <p>RSA用来加密网络信息，它是一个异步的算法。加密和解密使用了两个密钥。一个是公钥，在认证用户之间共享，另一个是私钥，必须私人保护。</p> <p>RSA还支持其他的<a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29" target="_blank" rel="noopener noreferrer"> padding schemes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>算法。JS web加密API支持下面这些RSA算法</p> <ul><li>RSASSA-PKCS1-v1_5</li> <li>RSA-PSS</li> <li>RSA-OAEP</li></ul> <h2 id="aes-advanced-encryption-standard-algorithm"><a href="#aes-advanced-encryption-standard-algorithm" class="header-anchor">#</a> AES (Advanced Encryption Standard) Algorithm</h2> <p>The advanced encryption standard algorithm is mostly known by its original name <strong>Rijndael</strong>. It is used for the encryption of electronic data and was established by the U.S.<a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology" target="_blank" rel="noopener noreferrer"> National Institute of Standards and Technology<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (NIST) in 2001. JavaScript’s Web Cryptography API supports different encryption models that use the AES block, they are:</p> <ul><li>AES-CTR</li> <li>AES-CBC</li> <li>AES-GCM</li> <li>AES-KW</li></ul> <h1 id="jsweb-加密api的使用场景"><a href="#jsweb-加密api的使用场景" class="header-anchor">#</a> JSweb 加密API的使用场景</h1> <p>很多JS应用需要实时加密。在这一节，我们看看实时加密的各类应用。</p> <h2 id="多元素认证"><a href="#多元素认证" class="header-anchor">#</a> 多元素认证</h2> <p>即使用户的密码被哈希或者被加密了，但是黑客们还是窃取用户的账户。为了确保登录账户是真正的使用者，很多应用要做多元素认证。</p> <p>而不是使用传输层的认证，比如TLS客户端认证应用使用灵活的用户密钥，这些密钥是使用用户代理预先生成的。</p> <h2 id="受保护的文档交换"><a href="#受保护的文档交换" class="header-anchor">#</a> 受保护的文档交换</h2> <p>加密的一个目标就是在第三方面前，能够确保信息的安全。JS 加密API允许你给文档签名，验证和加密。只允许拥有密钥的认证用户有权限访问文档。</p> <h2 id="云存储"><a href="#云存储" class="header-anchor">#</a> 云存储</h2> <p>使用JS加密API可以在上传文档之前就保护他们。应用使用用户选择的密钥，派生出一个加密的密钥，把文档加密了。然后再上传到服务器</p> <h2 id="安全消息"><a href="#安全消息" class="header-anchor">#</a> 安全消息</h2> <p>用户可以在网上使用OTR（无痕）的方式通信。通信双发可以使用验证码密钥（MAC）加密和解密信息，来保护数据。</p> <h2 id="js对象签名和加密-jose"><a href="#js对象签名和加密-jose" class="header-anchor">#</a> JS对象签名和加密(JOSE)</h2> <p>可以使用JS加密API来给JOSE的结构和信息进行交互。</p> <h1 id="怎么处理mitm攻击"><a href="#怎么处理mitm攻击" class="header-anchor">#</a> 怎么处理MitM攻击</h1> <p>MITM可以被称作中间攻击中的机器，也可是指中间攻击中的人。它是一种网络攻击，监听通信的双方，去修改他们的通信内容。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70118e8244594e53a7e5023ed3a08b6d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>例如，中间人可以在发送者的信息达到接受者之前就劫持信息。假如Nancy和Joy有一个加密会话。</p> <p>这时一个中间人James,获得了Nacy的密钥，他就可以解密信息，然后再发送给Joy之前进行篡改。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c36e4084774454882bc7830f7a05a55~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>一般怎么处理MITM攻击呢？</p> <ol><li>使用篡改检测是检验是否发生了MITM攻击的有效方式，通信双方可以对比响应时间的差异。</li> <li>双向认证可以有效减少MITM攻击，服务端和客户端互相验证</li> <li>取证分析同样很重要，它可以显示是否发生了MIIT攻击，以及攻击的资源。</li></ol> <h1 id="安全是个大话题"><a href="#安全是个大话题" class="header-anchor">#</a> 安全是个大话题</h1> <p>人人都希望自己在网上的通信交流是安全的，不会被泄漏出去。
开发者必须小心的选择第三方的工具和合作的供应商。要确保使用的工具在安全性和隐私性上都已经被相关的组织认证了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/23.html" class="prev">
        23.迭代器以及如何获得比generator更高的控制权
      </a></span> <span class="next"><a href="/feblog/howjswork/25.html">
        25.函数式编程和基本概念
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/28.6a8a79bd.js" defer></script>
  </body>
</html>
