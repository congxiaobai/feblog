<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/32.50330ec3.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" aria-current="page" class="active sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>本文阅读指数:3<br>
本文对设计模式介绍的比较简单。设计模式其实是非常重要的一个实践，但是大多数前端要么干脆不了解，要么了解了也很少实践。比较推荐大家深入学习一下设计模式。</p></blockquote> <h1 id="总览"><a href="#总览" class="header-anchor">#</a> 总览</h1> <p>设计模式已经成了标准方案，来解决一些开发中的通用问题。我认为这些设计模式已经成为行业标准了</p> <p>学习设计模式不仅会让你成为一个更牛掰的开发者，同时也会让你更好的理解一些框架是如何创建的。大多数的框架都采用了某种设计模式，学习之后会让你容易理解一些新出的框架。</p> <p>可以用任何语言来实现设计模式。它的灵活性很好，你可以随意使用和拓展。</p> <p>这一章我们会看看JS的设计模式，为什么需要这些模式，以及不同类型的设计模式。</p> <h1 id="设计模式是什么-我们为什么需要"><a href="#设计模式是什么-我们为什么需要" class="header-anchor">#</a> <strong>设计模式是什么?我们为什么需要？</strong></h1> <p>设计模式已经成为行业标准，我们可以称之为’templates‘。使用设计模式，可以让我们避免陷入疯狂的代码重复当中。</p> <p>使用设计模式的主要原因如下：</p> <ul><li>帮助我们写干净且有组织的代码。因为设计模式可以让我们代码结构更干净，容易调试和维护</li> <li>他们解决了类似的问题。当我们构建类，解耦代码，复用代码和对象时很容易产生问题。未来，代码的解耦会让开发对代码改动时减少很多Bug。</li> <li>合理使用设计模式，可以节省很多时间。因为这些模式已经很成熟了，可以明显解决节省时间。</li></ul> <h1 id="设计模式分类"><a href="#设计模式分类" class="header-anchor">#</a> <strong>设计模式分类</strong></h1> <p>设计模式主要分三类，创建型，结构型和行为型。
看看它们是如何被分类的。</p> <h2 id="创建型"><a href="#创建型" class="header-anchor">#</a> <strong>创建型</strong></h2> <p>这一类主要是为了创建对象。它为特殊的用户场景创建特殊的对象，并隐藏了创建的逻辑，只是暴露接口给我们。</p> <p>总的来说，我们使用相关接口创建特殊场景下的对象。主要的模式包含：</p> <ul><li>单例</li> <li>工厂</li> <li>抽象工厂</li> <li>建造者</li> <li>原型
我们会看看单例模式的工作原理</li></ul> <p><strong>单例模式</strong></p> <p>这种模式，确保一个类可以创建一个实例。</p> <p>这个模式有一些容易误解的参数，但是还是很容易实现。主要的步骤如下：</p> <ul><li>你的类创建一个对象</li> <li>创建一个实例</li> <li>阻止应用在其他地方再次实例化这个对象</li> <li>把实例当做资源分享</li></ul> <p>直接看代码吧，我们先创建一个类，然后稍后让它单例化。</p> <p>Step 1: 声明一个 <em>Manufacture</em></p> <div class="language- extra-class"><pre class="language-text"><code>class Database {
  constructor() {
  	this.connectionURL = {
      	name: &quot;&quot;,
        options: {}
    }
  }

  // Our connect method taking in two arguments
  connect(name, options) {
  	this.connectionURL.name = name;
  	this.connectionURL.options = options;
        console.log(`DB: ${name} connected!`);
  }

  // Disconnect method
  disconnect() {
    console.log(`${this.connectionURL.name} is disconnected!`);
  }
}

// Instantiating our class
const db = new Database()
console.log(db.connect(&quot;Facebook&quot;))
</code></pre></div><p>Step 2:实例化之后，让你的属性无法被修改</p> <div class="language- extra-class"><pre class="language-text"><code>class Database {
  constructor() {
  	this.connectionURL = {
      	name: &quot;&quot;,
        options: {}
    }
    
    // This disallows modifying the instance we created
    Object.freeze(this);
  }

  // Our connect method taking in two arguments
  connect(name, options) {
  	this.connectionURL.name = name;
  	this.connectionURL.options = options;
        console.log(`DB: ${name} connected!`);
  }

  // Disconnect method
  disconnect() {
    console.log(`${this.connectionURL.name} is disconnected!`);
  }
}

// Instantiating our class
const db = new Database();
console.log(db.connect(&quot;Facebook&quot;));
</code></pre></div><p>上面的代码中，不允许再增加或者改动属性了。在其他语言，比如JAVA中，我们可以创建一个 <strong>getInstance()方法</strong> ，用来达成单例模式。在上面的JS中，我们使用了<strong>constructor()</strong> 来替代。</p> <p>Step 3. 让我们的类自己实例化，并检查是否已经实例化过了。</p> <div class="language- extra-class"><pre class="language-text"><code>class Database {
  constructor() {
    // Check if our first instance has already been created
    if (Database.instance instanceof Database) {
        return Database.instance;   
    }
  	this.connectionURL = {
      	name: &quot;&quot;,
        options: {}
    }
    
    // This disallows modifying the instance we created
    Object.freeze(this);
    
    // Make our class an instance of itself
    Database.instance = this;
  }

  // Our connect method taking in two arguments
  connect(name, options) {
  	this.connectionURL.name = name;
  	this.connectionURL.options = options;
        console.log(`DB: ${name} connected!`);
  }

  // Disconnect method
  disconnect() {
    console.log(`${this.connectionURL.name} is disconnected!`);
  }
}

// Instantiating our class
const db = new Database();
console.log(db.connect(&quot;Facebook&quot;));
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// Check if our first instance has already been created
if (Database.instance instanceof Database) {
   return Database.instance;   
}
</code></pre></div><p>上面的代码中，我们第一次实例化之后，就会检查是否之前已经被实例化了，如果实例化了，就会返回之前实例化的。由此，避免重复实例化。</p> <p>我们创建两个实例，确认一下它们是否是一样的</p> <div class="language- extra-class"><pre class="language-text"><code>class Database {
  constructor() {
    if (Database.instance instanceof Database) {
   	 return Database.instance;   
    }
    this.connectionURL = {
      name: &quot;&quot;,
      options: {}
    }
    
    Database.instance = this;
 }

 
    connect(uri, options) {
        this.connectionURL.name = name;
        this.connectionURL.options = options;
        console.log(`DB: ${uri} connected!`);
    }

    disconnect() {
      console.log(`${this.connectionURL.name} is disconnected!`);
    }
}

const db = new Database()

const db1 = new Database()

console.log(db === db1)
// true
</code></pre></div><p>可以看到创建另一个实例是不允许的。
使用这个模式还要注意一下问题</p> <ul><li>并发场景。当2个以上的线程想去访问单例中的共享资源，此时有可能不会被立刻获取，会有性能瓶颈。</li> <li>单例非常像全局变量，所以很难面面俱到的测试到，因为应用中的每一部分都会用到。</li></ul> <h2 id="结构型"><a href="#结构型" class="header-anchor">#</a> <strong>结构型</strong></h2> <p>这个模式主要表示实体之间的关系，主要是对象和类的组合。这种模式的两个关键词是组合和继承。</p> <p>主要的模式包括：</p> <ul><li>适配模式</li> <li>外观模式</li> <li>桥接模式</li> <li>代理模式</li> <li>享元模式</li></ul> <p>我们主要看一下适配模式</p> <p><strong>适配模式</strong></p> <p>这种模式来桥接两个不兼容的类。我将这种模式当做一个包装器，把两个独立的接口拼接到一起。</p> <p>比如在真实情况下，我们可以生成一个套接字适配器，连接套接字和不兼容的插件。这种桥接就是适配模式。
我们看看JS中如何实现。我们会简单解释一下，同时不要跟外观模式混淆。</p> <div class="language- extra-class"><pre class="language-text"><code>import { first, middle, last } from &quot;random-name&quot;;

class randomName {
  generateFirstName() {
    return first();
  }
  
  generateMiddleName() {
    return middle();
  }
  
  generateLastName() {
    return last();
  }
}

export default new randomName();
</code></pre></div><p>上面的代码就是适配器，我们可以使用任意库。比如这样：</p> <div class="language- extra-class"><pre class="language-text"><code>import name from &quot;./random-name&quot;;

class PlugComponent {
  constructor() {
    this.firstName = name.generateFirstName();
    this.middleName = name.generateMiddleName();
    this.lastName = name.generateLastName();
  }
  
  generateFullName() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`
  }
}

const names = new PlugComponent()
console.log(names.generateFullName()) // Victor Victor Jonah
</code></pre></div><p>这种模式可以提升复用性和灵活性。</p> <h2 id="行为型"><a href="#行为型" class="header-anchor">#</a> <strong>行为型</strong></h2> <p>这种模式聚焦于对象间通信。开发者在让对象间通信时，能够保持解耦性和灵活性。</p> <p>这种模式主要包含：</p> <ul><li>责任链</li> <li>命令模式</li> <li>解释器</li> <li>观察者</li> <li>空对象模式</li></ul> <p>我们看一下空对象模式</p> <p><strong>空对象模式</strong></p> <p>这种模式避免返回null，它封装了null行为，并且返回客户端预期的值。大多时候，我们不允许使用null引用。所以我们要做Null检查，这会让我们的代码多很多if/else。使用了这种模式，就不用再写这种逻辑了。</p> <p>当我们不想返回Null值时，空对象模式很有用。日常中用来捕捉异常也是非常好用的。
来看看实现：</p> <div class="language- extra-class"><pre class="language-text"><code>class Cat {
  sound() {
    return 'meoow';
  }
}

class NullAnimal {
  sound() {
    return &quot;not an animal&quot;;
  }
}

const getAnimal = (type) =&gt; {
  return type === 'cat' ? new Cat() : new NullAnimal();
}

const results = ['cat', null]; 

const response = results.map((animal) =&gt; getAnimal(animal).sound());
// [&quot;meoow&quot;, &quot;not an animal&quot;]
</code></pre></div><p>我们没有返回Null引用，返回一个预期的值。</p> <h2 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> <strong>最佳实践</strong></h2> <p>要最佳实践，看看一些大原则</p> <ul><li><strong>编码前设计</strong>: 在编码实现之前做设计，是一把利刃。</li> <li><strong>KISS — 保持简单不做预设</strong>:如果你无法解释它，那它就不够简单。设计模式的目的是保持代码的简单和易于理解。</li> <li><strong>DRY — 不要重复自己</strong>:让你的函数可复用。不需要到处重复写。</li> <li><strong>关注分离点</strong>: 分离服务，让每一个子程序承担单一职责。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/28.html" class="prev">
        28.Deno 一瞥
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/32.50330ec3.js" defer></script>
  </body>
</html>
