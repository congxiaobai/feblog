<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概述 | 葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/26.f32df43c.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" aria-current="page" class="active sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>跨站请求伪造（CSRF），也被称为<strong>one-click attack</strong> 或者 <strong>session riding</strong>。也是一种web网站或应用的恶意攻击。这种攻击方式，是指攻击者替代受害者执行恶意请求。恶意应用传递这种请求的方式有很多，比如特殊处理的图片标签，隐藏的表单，AJAX请求等等，它们都是在用户不知情或者无戒心的情况下起作用。
XSS攻击是利用用户对部分网站的信任，CSRF则是利用网站对部分用户浏览器的信任。</p> <h1 id="csrf-攻击机制"><a href="#csrf-攻击机制" class="header-anchor">#</a> CSRF 攻击机制</h1> <p>执行一个CSRF攻击时，受害者提交了一个恶意请求。这个请求可能导致web应用执行一些危险行为，比如客户端和服务端数据的泄漏，修改会话状态或者操控用户的庄户。</p> <p>CSRF攻击是针对浏览的[confused deputy attack]（迷惑代理攻击）的一个案例。浏览器被攻击者欺骗，发送了一个伪造的请求。</p> <p>CSRF普遍具有以下特点：</p> <ul><li>设计依赖用户认证的网站和应用</li> <li>利用网站对该认证的信任</li> <li>欺骗用户浏览器，发送一个HTTP请求到目标网站</li> <li>这个HTTP请求产生了副作用</li></ul> <p>总览一下CSRF攻击的步骤：</p> <ul><li>受害者执行了一些可疑行为，比如访问攻击者控制的网页，链接等。</li> <li>这个行为的后果是代替受害者向攻击者的网站发送了一个请求</li> <li>如果网站此时有受害者的认证信息，那么这个请求就会被当成是受害者发送的一个合法的请求。</li></ul> <p>注意，CSRF利用的正是受害者激活的认证信息。</p> <p>大多数情况下，CSRF攻击不会窃取私人信息，而是会触发一些和用户账户相关的操作，比如改变他们的认证信息或者执行一次购买。强制用户从服务器获取数据对攻击者并没有好处，因为请求的回应攻击者是接受不到的。因此，他们会执行改变数据的请求。</p> <p>web应用中的session管理是基于cookies的，每次发送请求到服务端，浏览器都会附带上相关的cookie来表明当前用户的身份。即使是在不同的域名下，经常也会这么做。攻击者正是利用了这个漏洞。虽然CRFS经常被说成和session有关，但是它也会出现在其他的场景下---只要应用会自动在请求中添加用户的认证信息</p> <h1 id="example"><a href="#example" class="header-anchor">#</a> Example</h1> <p>Let’s look at the following example which illustrates a simple “Profile page” on a social network web app:
看一个简单的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$.get('htps://example.com/api/profile', function(data) {
    $('#username').val(data.name);
    $('#useremail').val(data.email);
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method='post' action='htps://example.com/api/profile'&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Your Profile:&lt;/legend&gt;
    &lt;label for='username'&gt; Name:&lt;/label&gt;
    &lt;input name='username' id='username' type='text'&gt; &lt;br&gt;&lt;br&gt;

    &lt;label for='email' &gt; Email:&lt;/label&gt;
    &lt;input name='email' id='useremail' type='email'&gt; &lt;br&gt;&lt;br&gt;
    
    &lt;button type='submit'&gt; Update &lt;/button&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>这个页面简单的加载了用户的账号数据，然后填充在表单中。如果表单编辑了，数据就会被提交并更新。
服务器接受了提交的数据，只要用户当前是认证过的。
现在看一下执行了CSRF的恶意页面。这个页面是攻击者创建的，并且寄宿在另一个域名下。这个页面的目地是向社交网络的发送一个请求：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE HTML&gt; 

&lt;html&gt;                                                       
    &lt;head&gt;&lt;/head&gt;                                                
    &lt;body&gt;                                                       
        &lt;form method='post' action='htps://example.com/api/profile'&gt; 
            &lt;input type='hidden' name='username' value=&quot;The Attacker&quot;&gt;   
            &lt;input type='hidden' name='email' value=&quot;the@attacker.com&quot;&gt;  
         &lt;/form&gt;                                                                                                          
        &lt;script&gt;                                                     
         document.forms[0].submit();                                  
        &lt;/script&gt;                                                    
     &lt;/body&gt;                                                      
 &lt;/html&gt;
</code></pre></div><p>这个页面包含了一个带有隐藏字段的表单，表单的action指向了同样的profile页面。</p> <p>一旦用户打开了恶意网站，表单就会自动向服务器提交数据。</p> <p>此时如果用户还没有认证账户，那么这个表达的危害是很小的，因为服务器会拒绝修改用户的数据。但是如果用户已经登录认证了，那么这个请求就是一个合法请求了，服务器就会去修改数据。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d9d4ecec5aa4719979c69cbf8be54bd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>攻击者主要是伪造了请求，并没有直接读取和窃取用户的cookie。
这个例子很简单，真实的攻击会更复杂更隐蔽。例如，CSRF攻击可以嵌入的iframe中，受害者是完全无感知的</p> <p>我们有很多办法来降低CSRF攻击的风险：</p> <h1 id="基于token预防"><a href="#基于token预防" class="header-anchor">#</a> 基于Token预防</h1> <p>This defense is one of the most popular and recommended methods to mitigate CSRF attacks. It can be achieved with two general approaches:
这是降低CSRF攻击最流行和最推荐的一种方式。它主要通过两个方法来达到效果：</p> <ul><li><strong>Stateful</strong> — 同步的token模式</li> <li><strong>Stateless</strong> — 基于token模式加密或者哈希</li></ul> <p>有很多库为这些技术提供开箱即用的实现</p> <h2 id="内置-csrf-实现"><a href="#内置-csrf-实现" class="header-anchor">#</a> 内置 CSRF 实现</h2> <p>在尝试构建应用之前，如果你使用的框架默认支持CSRF保护，那是最好不过了。但即使是这样，我们依然有责任正确的进行配置，比如秘钥管理和token管理</p> <p>如果你使用的框架没有内置的CSRF防护机制，那么你需要自己实现它。</p> <p>我们看一下在Express框架是怎么实现内置CSRF防护的。
Express提供了<code>csurf</code>的中间件，它做的就是CSRF保护。</p> <p>当然我们不会讨论细节，只看关键部分</p> <p>先写一个<code>index.js</code>:</p> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express');
const bodyParser = require('body-parser');
const csrf = require('csurf')
const cookieParser = require('cookie-parser')
const app = express();
const csrfProtection = csrf({ cookie: true });

app.use(cookieParser());
app.use(bodyParser.urlencoded({ extended: true }));
app.set('view engine', 'ejs');

app.get('/', csrfProtection, (req, res) =&gt; {
  res.render('index', { csrfToken: req.csrfToken() });
});

app.post('/profile', csrfProtection, (req, res, next) =&gt; {
  res.send(req.body.name);
});

app.listen(3000);
</code></pre></div><p>然后<code>views</code> 文件夹中, 我们添加 <code>index.ejs</code> :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form action='/profile' method='POST'&gt;
  &lt;input type='hidden' name='_csrf' value='&lt;%= csrfToken  %&gt;'&gt;  
  &lt;label for='name'&gt; Name:&lt;/label&gt; 
  &lt;input type='text' name='name'&gt;
  &lt;button type='submit'&gt; Update &lt;/button&gt;
&lt;/form&gt;
</code></pre></div><p>路由 <code>/</code> 将会渲染 <code>index.ejs</code> 模板，同时模板中的<code>csrfToken</code> 变量被赋值为CSRF token。</p> <p>在<code>index.ejs</code>中，csrfToken被赋值到隐藏字段中。当表单提交时，会向被保护的<code>/profile</code>路由发送请求。</p> <p>发现没有CSRF token,会抛出一个无效CSRF token的异常。</p> <h2 id="同步-token-模式"><a href="#同步-token-模式" class="header-anchor">#</a> 同步 Token 模式</h2> <p>同步 Token 模式允许服务端验证请求，确保他们的来源是合法的。
服务端为每一用户seesion和每一个请求生成一个tokern</p> <p>当请求同客户端发过来，服务端需要跟用户session中的token对比，验证请求中携带token存在并且有效</p> <p>大多数应用中，服务器使用HTTPsession用来表明用户的登录状态。在这个例子中，服务端生成了session，并且把session ID 发送到了客户端。这个ID大部分时间保存在客户端cookie中</p> <p>如果保存了session ID 的Cookie没有很好的被保护起来（比如配置httponly，同站，安全等），那它可能就会被浏览器中打开的其他页面访问到。</p> <p>每个请求都生成一次会更安全一点，因为攻击者利用token的时间更少了。但这样也可能带来用户体验变差。因为很可能用户点了一个返回按钮，但是页面包含的token已经失效了，服务器无法验证token，请求就不会被通过。</p> <p>CSRF token 需要有下面的特征:</p> <ul><li>每一个session都是独一无二的</li> <li>很难预测 — 一个安全的随机数</li></ul> <p>没有token，攻击者就无法创建一个有效请求，因此可以降低CSRF攻击。</p> <p>CSRF token也不能使用cookies传送，因为可能被攻击者截取或者访问到。</p> <p>也不能使用”GET“请求来传递CSRF token，因为有很多种方式可以泄漏出去。比如浏览器历史，日志文件，推荐标头信息等。</p> <p>CSRF tokens 可以通过这些方式传递:</p> <ul><li><strong>Hidden fields</strong> 表单中使用</li> <li><strong>Headers</strong> AJAX 调用时使用</li></ul> <p>比如表单中这样：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form action=’/api/payment’ method=’post’&gt;
    &lt;input type=’hidden&quot; name=’CSRFToken’ value=’WfF1szMUHhiokx9AHFply5L2xAOfjRkE’&gt;
&lt;/form&gt;
</code></pre></div><p>像上面的例子一样，token的值是在服务端生成。</p> <h2 id="token加密模式"><a href="#token加密模式" class="header-anchor">#</a> Token加密模式</h2> <p>对web应用模式来说，加密模式显然适配性更好，服务端也不用维护任何状态。</p> <p>服务器生成token，由用户的sessionID 和时间戳组成。这一对是用来加密的秘钥。一旦token生成，就会返回给客户端。和同步token一样，加密token需要在隐藏字段中或者ajax请求的请求头中。</p> <p>一旦服务器接收到请求，将会尝试去解密token</p> <p>如果解密失败，意味着请求遭到了某种侵入，请求就会失效。</p> <p>如果解密成功，会提取sessionID和时间戳。sessionID跟当前认证用户对比，时间戳跟当前服务器对比看是否超过了预定义的过期时间。
如果session ID 匹配，时间戳也没过期，那么请求被任务是安全的。</p> <h1 id="samesite-cookies"><a href="#samesite-cookies" class="header-anchor">#</a> SameSite Cookies</h1> <blockquote><p>关于SameSite的补充，[可以看这篇文章]([Cookie Samesite简析 - 知乎 (zhihu.com)]&gt; (https://zhuanlan.zhihu.com/p/266282015))</p></blockquote> <p>SameSite（同站）是cookie是一个属性，也是用来防止CSRF攻击的。
这个属性允许浏览器来决定跨站请求时要是否要带上cookies，这个属性的值有这些</p> <ul><li><code>Strict</code> —Cookies只会在当前的上下文中发送，第三方网站的请求不会发送。比如你在页面中点击了一个指向GitHub仓库的连接，那么跳转的时候，请求中不会携带cookies</li> <li><code>Lax</code> —cookies不会再一些容易出现CRSF攻击的请求方法中出现，比如<code>POST</code>。用户导航到源网站时，是可以携带cookies的，如果浏览器没有明确设置SameSite，这就是默认的cookie值。同样，假如此时你想访问一个GitHub的私人仓库，那么就会携带上你的cookies</li> <li><code>None</code>- 所有的请求都会携带上cookies，不论是当前源还是跨源请求。不过此时需要一个<code>Secure</code> 标记。</li></ul> <p>桌面浏览器和大部分手机浏览器都支持SameSite属性。
注意这个属性并不能替代token,他们两者是共存的，给用户增加双保险。</p> <h1 id="同源验证"><a href="#同源验证" class="header-anchor">#</a> 同源验证</h1> <p>这种方式需要两步验证HTTP请求头</p> <ul><li>验证请求发起的源，这个在 <code>Origin</code> 和 <code>Referer</code>头可以看到</li> <li>验证目标源</li></ul> <p>服务器需要验证请求源和目标源是匹配的。如果不匹配，请求被认为是跨源，就会被拒绝。这种验证是非常可靠的，因为这些头部信息是禁止修改的，只有浏览器可以操作它们。</p> <h1 id="double-submit-cookie"><a href="#double-submit-cookie" class="header-anchor">#</a> Double Submit Cookie</h1> <p>这是对token方案的一种替代，是一种无状态的方案。</p> <p>当用户访问web应用时，生成一个高安全等级的伪随机数，设置在cookies中，这个值跟session ID是独立的。</p> <p>服务器接受的每一个请求，都携带了这个随机数（通过隐藏表单或者请求参数）。如果两次发过来的值在服务端验证是匹配的，那么请求就被认定为合法，否则就会拒绝请求。</p> <h1 id="自定义请求头"><a href="#自定义请求头" class="header-anchor">#</a> 自定义请求头</h1> <p>这种方式对应用来说适配性最好，主要是在AJAX请求中处理，也依赖于API终结点。</p> <p>首先要使用同源策略，它会限制在它的源没，只能使用JS增加自定义头。浏览器默认不允许JS发起带有自定义头信息的跨源请求。</p> <p>这就要求一个稳定的 [CORS]配置方案，因为从其他源过来的请求会触发CORS的预防检查。</p> <p>允许你增加一个自定义头部信息，然后再服务端验证它的存在和正确性。
使用AJAX时建议可以这么做，<code>&lt;form&gt;</code>元素还是使用token的好。</p> <h1 id="interaction-based-defense"><a href="#interaction-based-defense" class="header-anchor">#</a> Interaction-Based Defense</h1> <p>用户行为是最有效的防止CSRF攻击的机制。常见的有两种方式：</p> <ul><li>预认证 —,在请求发起之前就强制用户认证</li> <li><a href="https://en.wikipedia.org/wiki/CAPTCHA" target="_blank" rel="noopener noreferrer">CAPTCHA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>这些都是对抗CSRF强有力的手段，但是也造成了对用户体验的负面影响。所以他们应该主要应用在一些比较关键的行为上，比如转账，下单等。</p> <h1 id="预认证防御"><a href="#预认证防御" class="header-anchor">#</a> 预认证防御</h1> <p>当用户还未认证时，在一些页面比如登录页，也可能会发生CSRF攻击。和已验证页面相比，这种攻击对预验证页面造成的影响是不同的</p> <p>假如有一个电子商务网站，受害者认证了自己。此时攻击者可以使用CSRF攻击，将受害者的账户换成自己的。当受害者输入他们的信息卡信息，攻击者就可以使用受害者的信用卡购物了。</p> <p>为了避免这种攻击，当用户尚未认证时，你可以创建一个预认证。登录表单必须要包含一个CSRF token，就像我们之前提到的那样</p> <p>一旦用户认证了，pre-session 就会变成真实的session。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/21.html" class="prev">
        21.XSS的5种方式和防范策略
      </a></span> <span class="next"><a href="/feblog/howjswork/23.html">
        23.迭代器以及如何获得比generator更高的控制权
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/26.f32df43c.js" defer></script>
  </body>
</html>
