<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概述 | 葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/19.9ccf9155.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" aria-current="page" class="active sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>设计应用时选择合适的存储机制是很重要的。一个好的存储引擎，应该确保数据稳定，减少带宽，提升性能。正确的存储缓存策略，是构建离线手机应用的核心之一，越来越多的用户想当然以为可以离线使用移动端网页程序。<br>
这一章，我们要讨论存储API和服务，照例提供一下引导帮助你在构建应用时做出正确的选择。</p> <h1 id="数据模型"><a href="#数据模型" class="header-anchor">#</a> 数据模型</h1> <p>数据的存储模型取决于数据内部的组织方式。这影响了整个应用的设计，要权衡性能和存储带来的问题。没有所谓更好，或者能解决所有问题的方案，一切都依赖于开发者自己。因此，我们先看看我们可以选择哪些数据模型</p> <ul><li><strong>结构型:</strong> 数据按照预定义的字段表来村存储，就像典型的SQL类数据库，他们具有很好的适配性，也便于动态查询。浏览器中的结构化存储是IndexedDB。</li> <li><strong>键值对:</strong> 键值对数据存储，类似于NoSQL数据库，通过唯一的键来存储和获取非结构化的数据。键值对数据存储，类似于哈希表，这样在访问索引时花费的时间是固定的。键/值数据型存储的很好的例子有浏览器端的 Cache API 和 服务器端 Apache Cassandra。</li> <li><strong>字节流:</strong> 这种简单的模型，把数据存储为定长，混淆字符串的字节变量，让应用层来控制其内部数据组织。该模型尤其适合于文件存储和其它层次型组织的 blob 数据。字节流存储的典型例子包括文件系统和云存储设备。</li></ul> <h1 id="持久化"><a href="#持久化" class="header-anchor">#</a> 持久化</h1> <p>网页程序的数据存储方法可以以数据的存储时长来进行分析：</p> <ul><li><strong>Session 持久化:</strong> 这种数据只要一个网页的session或者浏览器tab激活时持久化。 session持久性数据存储一个例子即 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener noreferrer">Session Storage API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>设备持久化:</strong> 这一类数据的持久化，是在一部分设备商跨session和浏览器tab的。一个设备持久化的存储的机制是<a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener noreferrer">Cache API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</li> <li><strong>全局持久化:</strong> 这一类数据持久化是跨session和设备的。因此，这是稳定的数据持久化方式。它不能在设备本身上存储，因此你需要一些服务端存储。</li></ul> <h1 id="浏览器中的数据持久化"><a href="#浏览器中的数据持久化" class="header-anchor">#</a> 浏览器中的数据持久化</h1> <p>现在有了一些浏览器的API支持数据存储。我们挑一些看看，并且做一个简单的比较，以便于你做出争取的选择。</p> <p>在选择合适的方式之前，要考虑一些事情。当然，首先你要先理解你的应用如何使用，后去维护和增强的。即使你已经有了答案，还是要考虑以下几个问题：</p> <ul><li><strong>浏览器支持</strong> — 优先选择已经标准化的，并且稳定的API，因为它们已经存在很久并且应用很广泛。这些API也有丰富的文档和社区开发者。</li> <li><strong>事务</strong> —有时，存储操作集成败的原子化是非常重要的。传统上上，数据库使用事务模型达到原子化。在事务模型中以把相关数据更新划分为任意的单元。</li> <li><strong>异步同步 —</strong> 有一些存储API是同步的，这样会阻塞当前线程。因此尽可能使用异步的。</li></ul> <h1 id="对比"><a href="#对比" class="header-anchor">#</a> 对比</h1> <p>看一下当前web开发者使用的API以及简单的横向对比一下</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0038d739397b4a65a4b59da02fa27e1f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="文件系统-api"><a href="#文件系统-api" class="header-anchor">#</a> 文件系统 API</h1> <p>使用文件系统的API，网络应用可以在用户本地文件系统的沙箱中创建，阅读，导航以及写文件。</p> <p>API分为几个部分：</p> <ul><li>读和操作文件: <code>File/Blob</code>, <code>FileList</code>, <code>FileReader</code></li> <li>创建和写文件: <code>Blob()</code>, <code>FileWriter</code></li> <li>目录和文件访问: <code>DirectoryReader</code>, <code>FileEntry/DirectoryEntry</code>, <code>LocalFileSystem</code></li></ul> <p>文件系统API是不标准的API。你不能在发布的程序中使用，因为它不是对所有用户生效。各个实现之间是不兼容的，比并且API可能会改变。</p> <p>文件和目录 API 接口文件系统用来表示一个文件系统。可从任意文件系统条目的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry/filesystem" target="_blank" rel="noopener noreferrer">filesystem<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 属性中获取这些 对象。少数浏览器提供了额外的 API 来创建和操作文件系统。</p> <p>该接口不会允许开发者访问用户的文件系统。相反，开发者会在浏览器沙箱内获得一个虚拟磁盘。若想要访问用户的文件系统，可以采取安装 Chrome 插件的方法。</p> <h2 id="请求一个文件系统"><a href="#请求一个文件系统" class="header-anchor">#</a> <strong>请求一个文件系统</strong></h2> <p>调用 <code>window.requestFileSystem()</code>，网络应用可以访问沙箱文件系统:
如果你第一次调用requestFileSystem()，会为你的应用创建新的存储。谨记，这个文件系统是沙箱，你的应用是无法访问其他的应用文件的。</p> <p>访问文件系统之后，你可以在文件和目录上执行大部分的标准行为。</p> <p>相比其他，文件系统是一个不同的存储方式，它旨在满足客户端存储不能满足的场景。一般来说，他们被用来处理大型二进制 blobs 文件或者在浏览器上下文之外的程序中分享数据。</p> <p>以下为使用 FileSystem 的好范例：</p> <ul><li>持久化上传--选择一个文件或者目录去上传，首先会拷贝文件到本地的沙箱，然后一次上传一个分片</li> <li>视频游戏，音乐或者其他的有很多媒体资源的应用</li> <li>离线的媒体/图片编辑器或者缓存加速的--数据块很大而且需要读写</li> <li>离线媒体播放器-它需要下载大文件，稍后播放或者快速的寻轨-缓冲</li> <li>离线网络邮件客户端---下载附件并本地存储</li></ul> <p>看看浏览器的支持情况：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02817e9b3c97471287ca8d2125b7e2c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="本地存储"><a href="#本地存储" class="header-anchor">#</a> 本地存储</h1> <p><code>localStorage</code> API允许你访问文档源的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener noreferrer">Storage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 对象。这个存储是跨浏览器session的。本地存储很类似<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.sessionStorage" target="_blank" rel="noopener noreferrer">sessionStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，除了localStorage中保存的数据没有过期时间，一旦页面关闭，sessionStorage中存储的数据就会被清理掉。</p> <p>无论是 localStorage 还是 sessionStorage 其数据只存储在特定的页面源中，所谓页面源包含协议，主机名和端口。
看一下浏览器支持情况</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6b5786e2fb048e0abc115a6dd95f297~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="session-存储"><a href="#session-存储" class="header-anchor">#</a> Session 存储</h1> <p>sessionStorage 属性允许你为当前的源获取session<a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener noreferrer">Storage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>对象。sessionStorage有点类似<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="noopener noreferrer">localStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。不同的是，存储在 localStorage 中的数据没有过期时间，而 sessionStorage 中的数据会在页面会话结束时丢失。页面会话的时效为浏览器打开时且在页面重载和恢复时。在新的选项卡中打开新页面或者窗口会导致重新初始化一个新的会话，这与会话 cookies 的工作机制是不一样的。</p> <p>同样，无论是 localStorage 还是 sessionStorage 其数据只存储在特定的页面源中</p> <p>看一下浏览器支持情况</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76bd47bcd2648238d66486111982f08~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="cookies"><a href="#cookies" class="header-anchor">#</a> Cookies</h1> <p>cookie是用户服务器发送给用户浏览器的一小片数据。浏览器可能存储它，并在之后的请求中返回给相同的服务器。典型的，它可以用来表示两个请求是否是同一个浏览器，以便保持用户的登录态。它为无状态的HTTP协议保存了有用的状态信息。</p> <p>使用cookies的主要场景:</p> <ul><li><strong>Session 管理 —</strong> 登录，购物车，游戏得分，或者服务器需要记住的其他信息</li> <li><strong>个人信息 —</strong> 用户的偏好，主题和其他个性设置。</li> <li><strong>跟踪 —</strong> 记录和分析用户行为</li></ul> <p>Cookies 一度是客户端存储的常用方式，这是因为当时只有这一种方式存储数据。现在推荐使用现代的存储APIS。Cookies包含在每一次请求中，所以会影响性能(特别是当在一个移动端请求数据的时候)。</p> <p>有两种cookies:</p> <ul><li><strong>Session cookies</strong> — 当客户端关闭时会被删除。网页浏览器可以使用恢复会话技术来固化大多数会话 cookie，就好像未曾关闭浏览器一样。</li> <li><strong>Permanent cookies</strong> — 和客户端关闭即过期相反，<em>permanent cookies</em>  会在指定的过期时间过期或者在一个指定的时间(Max-age)后过期。</li></ul> <p>注意，机密和敏感的信息不能保存，也不能在HTTP cookies中传输，因为cookie的机制本身就不安全。</p> <p>cookies已经在浏览器中广泛支持了</p> <h1 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h1> <p><strong>缓存</strong>接口为缓存的<a href="http://fetch.spec.whatwg.org/#request" target="_blank" rel="noopener noreferrer">Request<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> / <a href="http://fetch.spec.whatwg.org/#response" target="_blank" rel="noopener noreferrer">Response<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>对象提供了一个存储机制。注意缓存接口是被暴露到窗口作用域，就像worker一样。虽然 Cache 是在服务工作线程规范中定义的，但这并不表示一定要和服务工作线程一起使用。</p> <p>一个源可以拥有多个命名的缓存对象。开发者需要在脚本(比如在<a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker" target="_blank" rel="noopener noreferrer">服务工作线程中<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)中实现如何处理更新缓存即可。除非显示请求否则不会更新缓存中的对象，只能通过删除缓存对象，否则不会过期。使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener noreferrer">CacheStorage.open()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来打开指定命名的缓存对象，然后调用任意的缓存方法来维护缓存。</p> <p>开发者需要定时清除缓存条目。每个源在浏览器端都有限额的缓存数据。使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate" target="_blank" rel="noopener noreferrer">StorageEstimate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来估算使缓存配额使用率。浏览器尽力管理硬盘空间，但它有可能会删除指定源的缓存数据。浏览器可能会删除指定源的所有数据抑或不会。切记使用名称来对脚本进行版本控制且只操作可以安全操作的脚本版本。查看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API/Using_Service_Workers#Deleting_old_caches" target="_blank" rel="noopener noreferrer">Deleting old caches<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 以获取更多信息。</p> <p><strong>CacheStorage</strong> 接口表示 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener noreferrer">Cache<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 对象存储。</p> <p>接口:</p> <ul><li>给所有命名的缓存提供一个主目录，这个目录可以被ServiceWorker或者其他的worker访问</li> <li>维持一个字符串名和缓存对象的映射
使用CacheStorage.open()创建一个Cache实例。<br>
使用CacheStorage.match()检查给定的Request是否是CacheStorage 对象中的Cache对象的一个键。<br>
通过全局的caches属性访问CacheStorage。</li></ul> <h1 id="indexeddb"><a href="#indexeddb" class="header-anchor">#</a> IndexedDB</h1> <p>IndexedDB可以让你在浏览器中持久化存储数据。它可以让你创建一个具有丰富的查询功能的应用，并且不用关心网络。无论是否有网，你的应用都能正常工作。IndexedDB适用于大量数据（比如DVD仓库的借阅），并且不需要稳定的网络就能工作的软件（比如邮件客户端，代办列表，笔记本等。<br>
伴随网络应用变得复杂，IndexedDB 也越来越流行了。这一章我们就讨论一些细节。</p> <h2 id="初始化indexeddb"><a href="#初始化indexeddb" class="header-anchor">#</a> 初始化IndexedDB</h2> <p>IndexedDB 可以让使用'key'来存储和恢复保存的对象。数据库的所有改变都包含在事务当中，同样，indexedDB 尊徐同源策略。你只可以访问同域名下的数据。</p> <p>IndexedDB是一个异步API，可以在大多数的上下文中使用，包括WebWorkers。当然它也有同步的版本，但是已经被取消了。</p> <p>IndexedDB曾经有一个竞争伙伴，WebSQL，但是WebSQL已经被W3C放弃了。WebSQL数据库是一个关系型数据访问系统，而IndexedDB是一个索引表系统。</p> <p>不要根据其他数据库的经验来使用IndexedDB。相反的，你需要好好看文档。有一些关键的概念需要谨记：</p> <ul><li><strong>IndexedDB 存储键值对</strong> — 值可以是复杂结构的对象，键可以是这些对象的属性。你可以使对象中的任何属性创建索引，进行快速查找，比如排过序的枚举。键还可以是二进制对象。</li> <li><strong>IndexedDB 基于事务数据模型</strong> —
IndexedDB中做的一切事情，都发生在事务上下文的内部。不能在事务之外执行命令或者打开一个游标。同理，事务自动提交，不能手动提交</li> <li><strong>IndexedDB API 大多是异步的</strong> —API不会返回数据给你。相反的，你需要传递回调函数进去。你不能用同步的方式，在数据库中存储或者恢复一个值。相反的，你需要请求数据库操作的执行，当执行完成了，会发送一个事件通知，这个事件的类型告诉开发者操作的成败。这个跟[XMLHttpRequest]操作很相似。</li> <li><strong>IndexedDB需要很多request</strong> - request 对象接受前面提到的操作成功过着失败的事件。他们有onsuccess和onerror属性，和 readyState，result，errorCode 属性一样，用来告知请求状态。</li> <li><strong>IndexedDB 是面向对象的</strong> — IndexedDB不像传统的数据库，基于行列集。这种模式上的不同，影响我们构建应用的方式。</li> <li><strong>IndexedDB 不使用SQL</strong> —
它使用索引查询，索引会生成一个游标，使用游标可以遍历你查询的结果集。若不熟悉 NoSQL 系统，可以阅读 <a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener noreferrer">维基百科关于 NoSQL 的文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><strong>IndexedDB遵循同源策略</strong> — 源就是域名，应用层协议，以及执行的脚本文档的url端口的合集。每一个源都有自己的数据库，每一个数据库都有一个名字表示所处的源。</li></ul> <h2 id="indexeddb-的局限性"><a href="#indexeddb-的局限性" class="header-anchor">#</a> <strong>IndexedDB 的局限性</strong></h2> <p>IndexedDB 被设计用来满足大多数的客户端存储情况的。然而，它并没有被设计用来处理如下情况：</p> <ul><li><strong>国际化排序</strong> — 不同语言的字符串排序是不同的，因为不支持国际化的排序。因此，查询到的数据可以需要自己排一下序。</li> <li><strong>同步</strong> — 这个API的设计没有考虑和服务端的同步。你需要自己写代码来处理客户端和服务端的数据同步。</li> <li><strong>全文搜索</strong> — 没有类似于SQL中LIKE的操作</li></ul> <p>另外，在以下条件中，数据库会被清除</p> <ul><li><strong>用户请求清除</strong> — 很多浏览器是支持让用户擦除指定网址的数据的，包括cookie，书签，密码和IndexedDB数据。</li> <li><strong>浏览器是隐私模式</strong> — 一些浏览器有隐私模式或者匿名模式，当用户关闭会话时，浏览器自动清除数据库。</li> <li><strong>磁盘容量慢了</strong></li> <li><strong>数据损坏</strong> .</li></ul> <p>The exact circumstances and browser capabilities change over time, but the general philosophy of the browser vendors is to make the best effort to keep the data when possible.
具体的环境和浏览器能力日新月异，但是浏览器产商都朝着尽一切可能保存数据的方向努力。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/483fcf6c4e044919a9ce90e1f9ae300f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h1 id="选择合适的存储api"><a href="#选择合适的存储api" class="header-anchor">#</a> 选择合适的存储API</h1> <p>前面讲过，最好选择广泛应用，具有异步能力的API。这自然引出了以下几个技术点：</p> <ul><li>对于离线存储，使用[Cache API]。所有支持Service Worker的浏览器都可以支持它。Cache API 非常适用于排列已知 URL 的关联资源。</li> <li>使用IndexedDB 来存储应用状态和用户生成的内容。和只支持 Cache API 的浏览器相比，这使得用户可以在更多的浏览器中离线使用程序。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/15.html" class="prev">
        15.类，继承，Babel和TS的转换
      </a></span> <span class="next"><a href="/feblog/howjswork/17.html">
        17.影子DOM 内部构造及如何构建独立组件
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/19.9ccf9155.js" defer></script>
  </body>
</html>
