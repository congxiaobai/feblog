<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/13.b7203228.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" aria-current="page" class="active sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>客户端的Web应用已经越来越重了，这是由于人民群众日益增长的审美需求导致的。客户端需要提供更丰富的交互，实时计算等等。
复杂性的增长，让我们准确的知道运行期间任意时刻UI的状态、
当你构建一个框架或者库，需要通过监测 DOM 来响应并执行一些特定的操作，那就更困难了。</p> <h1 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h1> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener noreferrer">MutationObserver <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是现代浏览器提供的WEB API，用来监听DOM的变化。用它可以监听到最新增加/删除的节点，节点属性的改变，以及文本节点中文本的改变。</p> <p>什么场景下要这么做呢？</p> <ul><li>你想通知用户，他当前的页面已经改变了。</li> <li>使用一些根据DOM变化动态加载JS模块的框架</li> <li>如果是一个WYSIWYG编辑器，要实现undo/redo功能。通过MutationObserver API，你就知道发生了什么改变，然后轻松的undo它们。</li></ul> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671c241257594d3ab9f35813724325ef~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
看看MutationObserver 是如何起作用的。</p> <h2 id="怎么使用mutationobserver"><a href="#怎么使用mutationobserver" class="header-anchor">#</a> 怎么使用MutationObserver</h2> <p>在应用中实现<code>MutationObserver</code>是非常简单的。你可以在创建<code>MutationObserver</code> 实例时传递一个函数，这个函数会在每次DOM改变时触发。这个函数的第一个参数，是在一个批次中所有发生变化的DOM集合。每一个改变，包含了它的类型和发生的改变。</p> <div class="language- extra-class"><pre class="language-text"><code>var mutationObserver = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    console.log(mutation);
  });
});
</code></pre></div><p>创建的对象有三个方法</p> <ul><li><code>observe</code> — 开始监听变化。有两个参数，你想监听的DOM和一个配置的对象。</li> <li><code>disconnect</code> —  停止监听</li> <li><em><code>takeRecords</code></em> — 在回调触犯之前返回最近一个批次的变换，</li></ul> <p>启动监听:</p> <div class="language- extra-class"><pre class="language-text"><code>// Starts listening for changes in the root HTML element of the page.
mutationObserver.observe(document.documentElement, {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true,
  attributeOldValue: true,
  characterDataOldValue: true
});
</code></pre></div><p>看一个简单的例子</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;sample-div&quot; class=&quot;test&quot;&gt; Simple div &lt;/div&gt;
</code></pre></div><p>使用jQuery 删除<code>class</code> 属性</p> <div class="language- extra-class"><pre class="language-text"><code>$(&quot;#sample-div&quot;).removeAttr(&quot;class&quot;);
</code></pre></div><p>调用<code>mutationObserver.observe(...)</code> 之后，我们将会看到打印出<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener noreferrer">MutationRecord<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>日志
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ada84e679ea4df4b64e730cf6838341~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
这次的变化是通过移除 <code>class</code> 属性触发的.</p> <p>当任务完成之后，如果要停止监听DOM，要这么做</p> <div class="language- extra-class"><pre class="language-text"><code>// Stops the MutationObserver from listening for changes.
mutationObserver.disconnect();
</code></pre></div><p>如今 <code>MutationObserver</code> 已经被广泛支持了:</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da72fb1e3db24c878729126f014f2550~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="替代方案"><a href="#替代方案" class="header-anchor">#</a> 替代方案</h2> <p>但是<code>MutationObserver</code>还没有完全推开,在此之前开发者需要怎么做呢</p> <p>有一些其他的可选方案:</p> <ul><li><strong>Polling</strong></li> <li><strong>MutationEvents</strong></li> <li><strong>CSS animations</strong></li></ul> <h2 id="polling-轮询"><a href="#polling-轮询" class="header-anchor">#</a> Polling （轮询）</h2> <p>最简单暴力的方式是去轮询。使用浏览器的setInterval方法，可以设置一个任务，周期性的检查有什么变化。这个方式自然会影响到app的性能。</p> <h2 id="mutationevents"><a href="#mutationevents" class="header-anchor">#</a> MutationEvents</h2> <p>早在2000年，就引入了<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events" target="_blank" rel="noopener noreferrer">MutationEvents API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。尽管很有用，但是DOM的每一次改变都会触发mutation事件，这也引入了性能问题。如今<code>Muatation</code>API已经被遗弃了，很快所有的浏览器也都会不支持。
<code>MutationEvents</code>支持情况：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f318f380f58445ea5047623a74f5c48~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="css-动画"><a href="#css-动画" class="header-anchor">#</a> CSS 动画</h2> <p>一个相对陌生的替代方案是，是使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations" target="_blank" rel="noopener noreferrer">CSS animations<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.
听起来有点诡异。这个方案是创建一个动画，一旦DOM中添加元素就会被触发。动画一开始， <code>animationstart</code> 事件就会被触发：如果此时你添加了对该事件的监听，你就会知道DOM中添加了什么元素。动效的执行时间应该很小，这样用户觉察不到。</p> <p>首先，我们需要一个父元素包含它，然后插入节点监听</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=”container-element”&gt;&lt;/div&gt;
</code></pre></div><p>为了监听节点插入，我们需要设置一系列的<a href="https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp" target="_blank" rel="noopener noreferrer">关键帧<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，该动画在添加节点的时候启动：</p> <div class="language- extra-class"><pre class="language-text"><code>@keyframes nodeInserted { 
 from { opacity: 0.99; }
 to { opacity: 1; } 
}
</code></pre></div><p>关键帧创建之后，动画需要应用在你想监听的元素上。注意执行时间要断--这样浏览器中几乎感受不到</p> <div class="language- extra-class"><pre class="language-text"><code>#container-element * {
 animation-duration: 0.001s;
 animation-name: nodeInserted;
}
</code></pre></div><p>这个代码把动画添加到<code>container-element</code>的所有子节点上，当动画结束，会触发插入事件</p> <p>我们需要一个JS函数，作为事件的监听者。在函数内部，初始化<code>event.animationName</code>检查必须确保是我们所监听的动画</p> <div class="language- extra-class"><pre class="language-text"><code>var insertionListener = function(event) {
  // Making sure that this is the animation we want.
  if (event.animationName === &quot;nodeInserted&quot;) {
    console.log(&quot;Node has been inserted: &quot; + event.target);
  }
}
</code></pre></div><p>给父节点添加监听:</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener(“animationstart”, insertionListener, false); // standard + firefox
document.addEventListener(“MSAnimationStart”, insertionListener, false); // IE
document.addEventListener(“webkitAnimationStart”, insertionListener, false); // Chrome + Safari
</code></pre></div><p>CSS动画的支持情况：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ab8909e041444a9396fffb0a9c1ed8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p><code>MutationObserver</code>的提供了比上述都好的方案。它包含可每一个DOM中可能发生的变化，而且性能更好。最关键的是，几乎所有的浏览器都支持它，同时还有两个基于<code>MutationEvents</code>实现的polyfills</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/9.html" class="prev">
        9.网页推送机制
      </a></span> <span class="next"><a href="/feblog/howjswork/11.html">
        11.渲染引擎以及性能优化建议
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/13.b7203228.js" defer></script>
  </body>
</html>
