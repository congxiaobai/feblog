<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>葱白的工具箱</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Hello World">
    
    <link rel="preload" href="/feblog/assets/css/0.styles.90641447.css" as="style"><link rel="preload" href="/feblog/assets/js/app.af16a26a.js" as="script"><link rel="preload" href="/feblog/assets/js/2.bb248851.js" as="script"><link rel="preload" href="/feblog/assets/js/27.15cd01b9.js" as="script"><link rel="prefetch" href="/feblog/assets/js/10.1e7b7348.js"><link rel="prefetch" href="/feblog/assets/js/11.5df11de0.js"><link rel="prefetch" href="/feblog/assets/js/12.0cb13daa.js"><link rel="prefetch" href="/feblog/assets/js/13.b7203228.js"><link rel="prefetch" href="/feblog/assets/js/14.0d1b8841.js"><link rel="prefetch" href="/feblog/assets/js/15.40482005.js"><link rel="prefetch" href="/feblog/assets/js/16.975967de.js"><link rel="prefetch" href="/feblog/assets/js/17.80e3a75b.js"><link rel="prefetch" href="/feblog/assets/js/18.f8871089.js"><link rel="prefetch" href="/feblog/assets/js/19.9ccf9155.js"><link rel="prefetch" href="/feblog/assets/js/20.4f05958f.js"><link rel="prefetch" href="/feblog/assets/js/21.2532e6ba.js"><link rel="prefetch" href="/feblog/assets/js/22.10fa876d.js"><link rel="prefetch" href="/feblog/assets/js/23.9adf1998.js"><link rel="prefetch" href="/feblog/assets/js/24.8d4a2693.js"><link rel="prefetch" href="/feblog/assets/js/25.db370b93.js"><link rel="prefetch" href="/feblog/assets/js/26.f32df43c.js"><link rel="prefetch" href="/feblog/assets/js/28.6a8a79bd.js"><link rel="prefetch" href="/feblog/assets/js/29.3b89a9ef.js"><link rel="prefetch" href="/feblog/assets/js/3.bd55a964.js"><link rel="prefetch" href="/feblog/assets/js/30.921b4f31.js"><link rel="prefetch" href="/feblog/assets/js/31.3494180c.js"><link rel="prefetch" href="/feblog/assets/js/32.50330ec3.js"><link rel="prefetch" href="/feblog/assets/js/33.f0880d8a.js"><link rel="prefetch" href="/feblog/assets/js/34.e0057bb1.js"><link rel="prefetch" href="/feblog/assets/js/35.7703da2a.js"><link rel="prefetch" href="/feblog/assets/js/36.faf60c12.js"><link rel="prefetch" href="/feblog/assets/js/37.405fda0a.js"><link rel="prefetch" href="/feblog/assets/js/38.1e542b1a.js"><link rel="prefetch" href="/feblog/assets/js/39.64acf374.js"><link rel="prefetch" href="/feblog/assets/js/4.719e49fe.js"><link rel="prefetch" href="/feblog/assets/js/5.b7269ca1.js"><link rel="prefetch" href="/feblog/assets/js/6.004ca1a2.js"><link rel="prefetch" href="/feblog/assets/js/7.0bb92c79.js"><link rel="prefetch" href="/feblog/assets/js/8.e350d733.js"><link rel="prefetch" href="/feblog/assets/js/9.bd5a10e4.js">
    <link rel="stylesheet" href="/feblog/assets/css/0.styles.90641447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/feblog/" class="home-link router-link-active"><!----> <span class="site-name">葱白的工具箱</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/feblog/" class="nav-link">
  Coding集
</a></div><div class="nav-item"><a href="/feblog/book/" class="nav-link">
  披星集
</a></div><div class="nav-item"><a href="/feblog/atrcile/" class="nav-link">
  荷锄集
</a></div><div class="nav-item"><a href="/feblog/han/" class="nav-link">
  锄月集
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>与JS共舞</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/feblog/howjswork/1.html" class="sidebar-link">1.引擎，运行时，调用栈概述</a></li><li><a href="/feblog/howjswork/2.html" class="sidebar-link">2.V8 引擎中书写最优代码的 5 条小技巧</a></li><li><a href="/feblog/howjswork/3.html" class="sidebar-link">3.内存管理以及常见的内存泄漏处理</a></li><li><a href="/feblog/howjswork/4.html" class="sidebar-link">4.Event loop和异步编程</a></li><li><a href="/feblog/howjswork/5.html" class="sidebar-link">5.WebSockets 和HTTP2的正确姿势</a></li><li><a href="/feblog/howjswork/6.html" class="sidebar-link">6.WebAssembly以及使用它的场景</a></li><li><a href="/feblog/howjswork/7.html" class="sidebar-link">7.WebWorker和5个使用场景</a></li><li><a href="/feblog/howjswork/8.html" class="sidebar-link">8.Service Workers 的生命周期和使用场景</a></li><li><a href="/feblog/howjswork/9.html" class="sidebar-link">9.网页推送机制</a></li><li><a href="/feblog/howjswork/10.html" class="sidebar-link">10.使用MutationObserver 跟踪 DOM 变化</a></li><li><a href="/feblog/howjswork/11.html" class="sidebar-link">11.渲染引擎以及性能优化建议</a></li><li><a href="/feblog/howjswork/12.html" class="sidebar-link">12.网络层内部，以及性能，安全性的优化</a></li><li><a href="/feblog/howjswork/13.html" class="sidebar-link">13.CSS和JS动画以及优化建议</a></li><li><a href="/feblog/howjswork/14.html" class="sidebar-link">14.AST和优化建议</a></li><li><a href="/feblog/howjswork/15.html" class="sidebar-link">15.类，继承，Babel和TS的转换</a></li><li><a href="/feblog/howjswork/16.html" class="sidebar-link">16.存储引擎以及使用场景</a></li><li><a href="/feblog/howjswork/17.html" class="sidebar-link">17.影子DOM 内部构造及如何构建独立组件</a></li><li><a href="/feblog/howjswork/18.html" class="sidebar-link">18.WebRTC 及点对点网络通信机制</a></li><li><a href="/feblog/howjswork/19.html" class="sidebar-link">19.自定义元素机制</a></li><li><a href="/feblog/howjswork/20.html" class="sidebar-link">20.JS的异常处理以及在异步中处理异常的办法</a></li><li><a href="/feblog/howjswork/21.html" class="sidebar-link">21.XSS的5种方式和防范策略</a></li><li><a href="/feblog/howjswork/22.html" class="sidebar-link">22.CRFS攻击以及7种防范策略</a></li><li><a href="/feblog/howjswork/23.html" aria-current="page" class="active sidebar-link">23.迭代器以及如何获得比generator更高的控制权</a></li><li><a href="/feblog/howjswork/24.html" class="sidebar-link">24.加密和中间人（MITM）攻击</a></li><li><a href="/feblog/howjswork/25.html" class="sidebar-link">25.函数式编程和基本概念</a></li><li><a href="/feblog/howjswork/26.html" class="sidebar-link">26.多态的3种类型</a></li><li><a href="/feblog/howjswork/28.html" class="sidebar-link">28.Deno 一瞥</a></li><li><a href="/feblog/howjswork/29.html" class="sidebar-link">29.JS设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>在任何语言中，遍历集合中的每一项都是很常见的操作。JS也不例外的提供了一系列方式来进行集合的遍历，从简单的<code>for</code>循环到复杂的<code>map()</code> 和 <code>filter()</code>.</p></blockquote> <p><strong>迭代器（Iterators）</strong> 和 <strong>生成器（Generators）</strong> 带来了迭代的概念，并被内置的JS核心代码中，并且为用户提供了<code>for…of</code> 循环让用户自定义循环中的逻辑</p> <h1 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h1> <p>在JS中，迭代器是一个对象，定义了一个数列，以及在迭代结束时的返回值。
迭代器是实现了Iterator接口的任意对象。这个对象需要有一个<code>next()</code>方法和一个返回值，这个返回值要包含两个属性：</p> <ul><li><code>value</code>: 数列中的下一个值</li> <li><code>done</code>: 数列全部被访问之后，这个值为true。如果此时value属性也有值，那就是迭代器的返回值。</li></ul> <p>迭代器创建之后，只能通过<code>next()</code>方法迭代。访问到最后一个值时，再调用<code>next()</code>将会返回<code>{done: true}</code></p> <h1 id="使用迭代器"><a href="#使用迭代器" class="header-anchor">#</a> 使用迭代器</h1> <p>有时为了分配一个数组并遍历它，需要很多的资源。所以迭代器应该在必要的时候才使用。迭代器可以表示不限尺寸的数组。</p> <p>看一个简单的使用迭代器创建斐波那契数列的例子</p> <div class="language- extra-class"><pre class="language-text"><code>function makeFibonacciSequenceIterator(endIndex = Infinity) {
  let currentIndex = 0;
  let previousNumber = 0;
  let currentNumber = 1;

  return {
    next: () =&gt; {
      if (currentIndex &gt;= endIndex) { 
          return { value: currentNumber, done: true }; 
      }

      let result = { value: currentNumber, done: false };
      let nextNumber = currentNumber + previousNumber;
      previousNumber = currentNumber;
      currentNumber = nextNumber;
      currentIndex++;

      return result;
    }
  };
}
</code></pre></div><p>这个例子中，迭代器会生成斐波那契数字，一直到<code>endIndex</code>。迭代器每次迭代，回返回当前的斐波那契数字。</p> <p>我们看一下使用效果：</p> <div class="language- extra-class"><pre class="language-text"><code>let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5); 
// Generates the first 5 numbers.
let result = fibonacciSequenceIterator.next();
while (!result.done) {
    console.log(result.value); // 1 1 2 3 5 8
    result = fibonacciSequenceIterator.next();
}
</code></pre></div><h1 id="定义可迭代对象"><a href="#定义可迭代对象" class="header-anchor">#</a> 定义可迭代对象</h1> <p>上面的代码有一个潜在的问题，就是没有办法验证这个迭代器是否有效。虽然它的返回值中包含了<code>next()</code>方法，但很有可能只是个巧合，很多对象都有这个方法，但是它们并不能迭代。
因此JS在定义可迭代对象时多了一些要求。</p> <p>我们用<code>for…of</code>来检验上面的例子，会发现JS是无法识别这个迭代对象的：</p> <div class="language- extra-class"><pre class="language-text"><code>let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);

for (let x of fibonacciSequenceIterator) {
    console.log(x);
}
</code></pre></div><p>代码会抛出异常</p> <p><code>Uncaught TypeError: fibonacciSequenceIterator is not iterable</code></p> <p>一些JS内置类型，比如<code>Array</code> <code>Map</code>,是默认可以迭代的，而其他的类型就不行。</p> <p>普通对象要想可迭代，必须实现<code>@@iterator</code>，同时具有一个<code>Symbol.iterator</code>关键属性。这个属性是一个函数，并返回当前迭代到的内容。</p> <p>上面的例子可以这么改造一下:</p> <div class="language- extra-class"><pre class="language-text"><code>function makeFibonacciSequenceIterator(endIndex = Infinity) {
  let currentIndex = 0;
  let previousNumber = 0;
  let currentNumber = 1;

  let iterator = {};
  iterator[Symbol.iterator] = () =&gt; {
    return {
      next: () =&gt; {
        if (currentIndex &gt;= endIndex) { 
            return { value: currentNumber, done: true }; 
        }
        
        const result = { value: currentNumber, done: false };
        const nextNumber = currentNumber + previousNumber;
        previousNumber = currentNumber;
        currentNumber = nextNumber;
        currentIndex++;

        return result;
      }
    }
  };

  return iterator;
}
</code></pre></div><p>现在，我们就有了一个可迭代对象了，使用<code>for…of</code>操作试一下：</p> <div class="language- extra-class"><pre class="language-text"><code>let fibonacciSequenceIterator = makeFibonacciSequenceIterator(5);

for (let x of fibonacciSequenceIterator) {
    console.log(x); //1 1 2 3 5 8
}
</code></pre></div><h1 id="生成器"><a href="#生成器" class="header-anchor">#</a> 生成器</h1> <p>自定义迭代器用处很大，在某些场景下非常有效。但是创建和维护它们，需要非常小心的维护它们内部的状态。</p> <p>而生成器函数提供了一个替代方案，允许开发者定义迭代的步骤，你可以写一个不会持续执行的函数，我们使用<code>function*</code>语法来写。</p> <p>调用生成器函数，不会初次执行代码，相反它返回了一个特殊类型的迭代器，称之为生成器。调用生成器的next方法生成一个值时，生成器函数就继续执行，直到遇到yield关键字。</p> <p>生成器可以当做是一个函数，返回一系列的值而不是一个单独的值，并且它是需要被连续调用的。</p> <p>生成器的语法包含一个<code>yield</code> ，它可以暂停方法的执行，直到请求下一个值。</p> <p>看看如何使用生成器生成斐波那契数列</p> <div class="language- extra-class"><pre class="language-text"><code>function* makeFibonacciSequenceGenerator(endIndex = Infinity) {
    let previousNumber = 0;
    let currentNumber = 1;
    
    for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) {
        yield currentNumber;
        let nextNumber = currentNumber + previousNumber;
        previousNumber = currentNumber;
        currentNumber = nextNumber;
    }
}

let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(5);

for (let x of fibonacciSequenceGenerator) {
    console.log(x);
}
</code></pre></div><p>可以看到这个实现更容易，也更好维护。</p> <h2 id="比生成器更高的控制权"><a href="#比生成器更高的控制权" class="header-anchor">#</a> 比生成器更高的控制权</h2> <p>迭代器显式定义了<code>next()</code>函数，这是JS接口的需要。使用生成器，则会隐式添加<code>next()</code>函数。这是迭代器生成有效可迭代对象的方式。</p> <p>迭代器隐式定义的 <code>next()</code> 函数接受一个参数，这个参数可以用来修改迭代器的内部状态，传递给<code>next()</code>的值会被 <code>yield</code> 声明接收到。</p> <p>深度改造一下上面的案例，这样你可以控制每一步可以跳过多少数字</p> <div class="language- extra-class"><pre class="language-text"><code>function* makeFibonacciSequenceGenerator(endIndex = Infinity) {
    let previousNumber = 0;
    let currentNumber = 1;
    let skipCount = 0;
    
    for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) {
        if (skipCount === 0) {
            skipCount = yield currentNumber; // skipCount is the parameter passed through the invocation of `fibonacciSequenceGenerator.next(value)` below.
            skipCount = skipCount === undefined ? 0 : skipCount; // makes sure that there is an input
        } else if (skipCount &gt; 0){
            skipCount--;
        }
        
        let nextNumber = currentNumber + previousNumber;
        previousNumber = currentNumber;
        currentNumber = nextNumber;
    }
}

let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);

console.log(fibonacciSequenceGenerator.next().value);  // prints 1
console.log(fibonacciSequenceGenerator.next(3).value); // prints 5 since 1, 2, and 3 are skipped.
console.log(fibonacciSequenceGenerator.next().value);  // prints 8
console.log(fibonacciSequenceGenerator.next(1).value); // prints 21 since 13 is skipped.
</code></pre></div><p>需要注意，第一次调用<code>next()</code>传递的参数会被忽略</p> <p>另一个重要的特性是，可以调用<code>throw()</code>方法来让生成器抛出一个异常。迭代器当前挂起的上下文会抛出这个异常，
如果迭代器内部没有捕捉这个异常，它会通过调用<code>throw()</code>向上传播，那么后续的<code>next()</code>调用会将done属性设置为true。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>function* makeFibonacciSequenceGenerator(endIndex = Infinity) {
    let previousNumber = 0;
    let currentNumber = 1;
    let skipCount = 0;
    
    try {
      for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) {
          if (skipCount === 0) {
              skipCount = yield currentNumber;
              skipCount = skipCount === undefined ? 0 : skipCount;
          } else if (skipCount &gt; 0){
              skipCount--;
          }
 
          let nextNumber = currentNumber + previousNumber;
          previousNumber = currentNumber;
          currentNumber = nextNumber;
      }
    } catch(err) {
    	console.log(err.message); // will print ‘External throw’ on the fourth iteration.
    }
}
 
let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);

console.log(fibonacciSequenceGenerator.next(1).value);
console.log(fibonacciSequenceGenerator.next(3).value);
console.log(fibonacciSequenceGenerator.next().value);
fibonacciSequenceGenerator.throw(new Error('External throw'));
console.log(fibonacciSequenceGenerator.next(1).value); // undefined will be printed since the generator is done.
</code></pre></div><p>生成器也是通过调用<code>return(value)</code>方法来结束的。</p> <div class="language- extra-class"><pre class="language-text"><code>let fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(50);

console.log(fibonacciSequenceGenerator.next().value); // 1
console.log(fibonacciSequenceGenerator.next(3).value); // 5
console.log(fibonacciSequenceGenerator.next().value);   // 8
console.log(fibonacciSequenceGenerator.return(374).value); // 374
console.log(fibonacciSequenceGenerator.next(1).value); // undefined
</code></pre></div><h2 id="异步生成器"><a href="#异步生成器" class="header-anchor">#</a> 异步生成器</h2> <p>可以在异步上下文中定义和使用生成器。异步生成器可以异步的生成一系列的值。
异步的语法是很好理解的。在定义<code>function*</code>时在加上<code>async</code>就可以了。
那么在迭代生成的数列时，就需要使用<code>await</code>关键字。
我们把上面的例子再改造一下：</p> <div class="language- extra-class"><pre class="language-text"><code>async function* makeFibonacciSequenceGenerator(endIndex = Infinity) {
    let previousNumber = 0;
    let currentNumber = 1;
    
    for (let currentIndex = 0; currentIndex &lt; endIndex; currentIndex++) {
        await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // a simple timeout as an example.
        yield currentNumber;
        let nextNumber = currentNumber + previousNumber;
        previousNumber = currentNumber;
        currentNumber = nextNumber;
    }
}

(async () =&gt; {
  const fibonacciSequenceGenerator = makeFibonacciSequenceGenerator(6);
  for await (let x of fibonacciSequenceGenerator) {
    console.log(x); // 1, then 1, then 2, then 3, then 5, then 8 (with delay in between).
  }
})();
</code></pre></div><p>异步生成器中，我们可以使用await，它是基于promise的。<code>next()</code>方法会返回一个<code>Promsie</code>。
有时候你不想使用生成器，但是你还是想定义一个迭代对象，你可以使用<code>Symbol.asyncIterator</code> 而不是 <code>Symbol.iterator</code>。
虽然，相比迭代器，生成器更加简单一点，但是调试起来也麻烦一点。如果使用的是异步上下文的，就更麻烦了，当调用<code>throw()</code>方法时，栈跟踪的信息非常有限，从这些信息中debug是几乎不可能的，你需要向你的用户获取更多的上下文信息。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feblog/howjswork/22.html" class="prev">
        22.CRFS攻击以及7种防范策略
      </a></span> <span class="next"><a href="/feblog/howjswork/24.html">
        24.加密和中间人（MITM）攻击
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/feblog/assets/js/app.af16a26a.js" defer></script><script src="/feblog/assets/js/2.bb248851.js" defer></script><script src="/feblog/assets/js/27.15cd01b9.js" defer></script>
  </body>
</html>
